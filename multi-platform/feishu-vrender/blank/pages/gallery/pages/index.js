(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VRender = {}));
})(this, (function (exports) { 'use strict';

  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return e;
    };
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function (t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function (t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw new Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(typeof e + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function (e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function () {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function (e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw new Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function (t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function (t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      catch: function (t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  function _typeof(o) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof(o);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        var F = function () {};
        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
      didErr = false,
      err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  var Generator = /*#__PURE__*/function () {
    function Generator() {
      _classCallCheck(this, Generator);
    }
    _createClass(Generator, null, [{
      key: "GenAutoIncrementId",
      value: function GenAutoIncrementId() {
        return Generator.auto_increment_id++;
      }
    }]);
    return Generator;
  }();
  Generator.auto_increment_id = 0;

  var ContainerModule = /*#__PURE__*/_createClass(function ContainerModule(registry) {
    _classCallCheck(this, ContainerModule);
    this.id = Generator.GenAutoIncrementId(), this.registry = registry;
  });

  var NAMED_TAG = "named";
  var INJECT_TAG = "inject";
  var MULTI_INJECT_TAG = "multi_inject";
  var TAGGED = "inversify:tagged";
  var PARAM_TYPES = "inversify:paramtypes";

  var Metadata = /*#__PURE__*/function () {
    function Metadata(key, value) {
      _classCallCheck(this, Metadata);
      this.key = key, this.value = value;
    }
    _createClass(Metadata, [{
      key: "toString",
      value: function toString() {
        return this.key === NAMED_TAG ? "named: ".concat(String(this.value).toString(), " ") : "tagged: { key:".concat(this.key.toString(), ", value: ").concat(String(this.value), " }");
      }
    }]);
    return Metadata;
  }();

  var Reflect$1 = (function (Reflect) {
    var target;
    return function (exporter) {
      var hasOwn = Object.prototype.hasOwnProperty,
        supportsSymbol = "function" == typeof Symbol,
        toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive",
        iteratorSymbol = supportsSymbol && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator",
        supportsCreate = "function" == typeof Object.create,
        supportsProto = {
          __proto__: []
        } instanceof Array,
        downLevel = !supportsCreate && !supportsProto,
        HashMap = {
          create: supportsCreate ? function () {
            return MakeDictionary(Object.create(null));
          } : supportsProto ? function () {
            return MakeDictionary({
              __proto__: null
            });
          } : function () {
            return MakeDictionary({});
          },
          has: downLevel ? function (map, key) {
            return hasOwn.call(map, key);
          } : function (map, key) {
            return key in map;
          },
          get: downLevel ? function (map, key) {
            return hasOwn.call(map, key) ? map[key] : void 0;
          } : function (map, key) {
            return map[key];
          }
        },
        functionPrototype = Object.getPrototypeOf(Function),
        usePolyfill = "object" == (typeof process === "undefined" ? "undefined" : _typeof(process)) && process.env && "true" === process.env.REFLECT_METADATA_USE_MAP_POLYFILL,
        _Map = usePolyfill || "function" != typeof Map || "function" != typeof Map.prototype.entries ? CreateMapPolyfill() : Map,
        Metadata = (usePolyfill || "function" != typeof Set || "function" != typeof Set.prototype.entries ? CreateSetPolyfill() : Set, new (usePolyfill || "function" != typeof WeakMap ? CreateWeakMapPolyfill() : WeakMap)());
      function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
      }
      function hasMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target, propertyKey);
      }
      function hasOwnMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
      }
      function getMetadata(metadataKey, target, propertyKey) {
        if (!IsObject(target)) throw new TypeError();
        return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target, propertyKey);
      }
      function GetOrCreateMetadataMap(O, P, Create) {
        var targetMetadata = Metadata.get(O);
        if (IsUndefined(targetMetadata)) {
          if (!Create) return;
          targetMetadata = new _Map(), Metadata.set(O, targetMetadata);
        }
        var metadataMap = targetMetadata.get(P);
        if (IsUndefined(metadataMap)) {
          if (!Create) return;
          metadataMap = new _Map(), targetMetadata.set(P, metadataMap);
        }
        return metadataMap;
      }
      function OrdinaryHasMetadata(MetadataKey, O, P) {
        if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return !0;
        var parent = OrdinaryGetPrototypeOf(O);
        return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
      }
      function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, !1);
        return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
      }
      function OrdinaryGetMetadata(MetadataKey, O, P) {
        if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = OrdinaryGetPrototypeOf(O);
        return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
      }
      function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = GetOrCreateMetadataMap(O, P, !1);
        if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
      }
      function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        GetOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue);
      }
      function Type(x) {
        if (null === x) return 1;
        switch (_typeof(x)) {
          case "undefined":
            return 0;
          case "boolean":
            return 2;
          case "string":
            return 3;
          case "symbol":
            return 4;
          case "number":
            return 5;
          case "object":
            return null === x ? 1 : 6;
          default:
            return 6;
        }
      }
      function IsUndefined(x) {
        return void 0 === x;
      }
      function IsNull(x) {
        return null === x;
      }
      function IsSymbol(x) {
        return "symbol" == _typeof(x);
      }
      function IsObject(x) {
        return "object" == _typeof(x) ? null !== x : "function" == typeof x;
      }
      function ToPrimitive(input, PreferredType) {
        switch (Type(input)) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            return input;
        }
        var hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default",
          exoticToPrim = GetMethod(input, toPrimitiveSymbol);
        if (void 0 !== exoticToPrim) {
          var result = exoticToPrim.call(input, hint);
          if (IsObject(result)) throw new TypeError();
          return result;
        }
        return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
      }
      function OrdinaryToPrimitive(O, hint) {
        if ("string" === hint) {
          var toString_1 = O.toString;
          if (IsCallable(toString_1)) {
            var result = toString_1.call(O);
            if (!IsObject(result)) return result;
          }
          var _valueOf = O.valueOf;
          if (IsCallable(_valueOf)) {
            var _result = _valueOf.call(O);
            if (!IsObject(_result)) return _result;
          }
        } else {
          var _valueOf2 = O.valueOf;
          if (IsCallable(_valueOf2)) {
            var _result2 = _valueOf2.call(O);
            if (!IsObject(_result2)) return _result2;
          }
          var toString_2 = O.toString;
          if (IsCallable(toString_2)) {
            var _result3 = toString_2.call(O);
            if (!IsObject(_result3)) return _result3;
          }
        }
        throw new TypeError();
      }
      function ToBoolean(argument) {
        return !!argument;
      }
      function ToString(argument) {
        return "" + argument;
      }
      function ToPropertyKey(argument) {
        var key = ToPrimitive(argument, 3);
        return IsSymbol(key) ? key : ToString(key);
      }
      function IsCallable(argument) {
        return "function" == typeof argument;
      }
      function GetMethod(V, P) {
        var func = V[P];
        if (null != func) {
          if (!IsCallable(func)) throw new TypeError();
          return func;
        }
      }
      function OrdinaryGetPrototypeOf(O) {
        var proto = Object.getPrototypeOf(O);
        if ("function" != typeof O || O === functionPrototype) return proto;
        if (proto !== functionPrototype) return proto;
        var prototype = O.prototype,
          prototypeProto = prototype && Object.getPrototypeOf(prototype);
        if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
        var constructor = prototypeProto.constructor;
        return "function" != typeof constructor || constructor === O ? proto : constructor;
      }
      function CreateMapPolyfill() {
        var cacheSentinel = {},
          arraySentinel = [],
          MapIterator = function () {
            function MapIterator(keys, values, selector) {
              this._index = 0, this._keys = keys, this._values = values, this._selector = selector;
            }
            return MapIterator.prototype["@@iterator"] = function () {
              return this;
            }, MapIterator.prototype[iteratorSymbol] = function () {
              return this;
            }, MapIterator.prototype.next = function () {
              var index = this._index;
              if (index >= 0 && index < this._keys.length) {
                var result = this._selector(this._keys[index], this._values[index]);
                return index + 1 >= this._keys.length ? (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel) : this._index++, {
                  value: result,
                  done: !1
                };
              }
              return {
                value: void 0,
                done: !0
              };
            }, MapIterator.prototype["throw"] = function (error) {
              throw this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), error;
            }, MapIterator.prototype["return"] = function (value) {
              return this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), {
                value: value,
                done: !0
              };
            }, MapIterator;
          }();
        return function () {
          function Map() {
            this._keys = [], this._values = [], this._cacheKey = cacheSentinel, this._cacheIndex = -2;
          }
          return Object.defineProperty(Map.prototype, "size", {
            get: function get() {
              return this._keys.length;
            },
            enumerable: !0,
            configurable: !0
          }), Map.prototype.has = function (key) {
            return this._find(key, !1) >= 0;
          }, Map.prototype.get = function (key) {
            var index = this._find(key, !1);
            return index >= 0 ? this._values[index] : void 0;
          }, Map.prototype.set = function (key, value) {
            var index = this._find(key, !0);
            return this._values[index] = value, this;
          }, Map.prototype["delete"] = function (key) {
            var index = this._find(key, !1);
            if (index >= 0) {
              var size = this._keys.length;
              for (var i = index + 1; i < size; i++) this._keys[i - 1] = this._keys[i], this._values[i - 1] = this._values[i];
              return this._keys.length--, this._values.length--, key === this._cacheKey && (this._cacheKey = cacheSentinel, this._cacheIndex = -2), !0;
            }
            return !1;
          }, Map.prototype.clear = function () {
            this._keys.length = 0, this._values.length = 0, this._cacheKey = cacheSentinel, this._cacheIndex = -2;
          }, Map.prototype.keys = function () {
            return new MapIterator(this._keys, this._values, getKey);
          }, Map.prototype.values = function () {
            return new MapIterator(this._keys, this._values, getValue);
          }, Map.prototype.entries = function () {
            return new MapIterator(this._keys, this._values, getEntry);
          }, Map.prototype["@@iterator"] = function () {
            return this.entries();
          }, Map.prototype[iteratorSymbol] = function () {
            return this.entries();
          }, Map.prototype._find = function (key, insert) {
            return this._cacheKey !== key && (this._cacheIndex = this._keys.indexOf(this._cacheKey = key)), this._cacheIndex < 0 && insert && (this._cacheIndex = this._keys.length, this._keys.push(key), this._values.push(void 0)), this._cacheIndex;
          }, Map;
        }();
        function getKey(key, _) {
          return key;
        }
        function getValue(_, value) {
          return value;
        }
        function getEntry(key, value) {
          return [key, value];
        }
      }
      function CreateSetPolyfill() {
        return function () {
          function Set() {
            this._map = new _Map();
          }
          return Object.defineProperty(Set.prototype, "size", {
            get: function get() {
              return this._map.size;
            },
            enumerable: !0,
            configurable: !0
          }), Set.prototype.has = function (value) {
            return this._map.has(value);
          }, Set.prototype.add = function (value) {
            return this._map.set(value, value), this;
          }, Set.prototype["delete"] = function (value) {
            return this._map["delete"](value);
          }, Set.prototype.clear = function () {
            this._map.clear();
          }, Set.prototype.keys = function () {
            return this._map.keys();
          }, Set.prototype.values = function () {
            return this._map.values();
          }, Set.prototype.entries = function () {
            return this._map.entries();
          }, Set.prototype["@@iterator"] = function () {
            return this.keys();
          }, Set.prototype[iteratorSymbol] = function () {
            return this.keys();
          }, Set;
        }();
      }
      function CreateWeakMapPolyfill() {
        var UUID_SIZE = 16,
          keys = HashMap.create(),
          rootKey = CreateUniqueKey();
        return function () {
          function WeakMap() {
            this._key = CreateUniqueKey();
          }
          return WeakMap.prototype.has = function (target) {
            var table = GetOrCreateWeakMapTable(target, !1);
            return void 0 !== table && HashMap.has(table, this._key);
          }, WeakMap.prototype.get = function (target) {
            var table = GetOrCreateWeakMapTable(target, !1);
            return void 0 !== table ? HashMap.get(table, this._key) : void 0;
          }, WeakMap.prototype.set = function (target, value) {
            return GetOrCreateWeakMapTable(target, !0)[this._key] = value, this;
          }, WeakMap.prototype["delete"] = function (target) {
            var table = GetOrCreateWeakMapTable(target, !1);
            return void 0 !== table && delete table[this._key];
          }, WeakMap.prototype.clear = function () {
            this._key = CreateUniqueKey();
          }, WeakMap;
        }();
        function CreateUniqueKey() {
          var key;
          do {
            key = "@@WeakMap@@" + CreateUUID();
          } while (HashMap.has(keys, key));
          return keys[key] = !0, key;
        }
        function GetOrCreateWeakMapTable(target, create) {
          if (!hasOwn.call(target, rootKey)) {
            if (!create) return;
            Object.defineProperty(target, rootKey, {
              value: HashMap.create()
            });
          }
          return target[rootKey];
        }
        function FillRandomBytes(buffer, size) {
          for (var i = 0; i < size; ++i) buffer[i] = 255 * Math.random() | 0;
          return buffer;
        }
        function GenRandomBytes(size) {
          return "function" == typeof Uint8Array ? "undefined" != typeof crypto ? crypto.getRandomValues(new Uint8Array(size)) : FillRandomBytes(new Uint8Array(size), size) : FillRandomBytes(new Array(size), size);
        }
        function CreateUUID() {
          var data = GenRandomBytes(UUID_SIZE);
          data[6] = 79 & data[6] | 64, data[8] = 191 & data[8] | 128;
          var result = "";
          for (var offset = 0; offset < UUID_SIZE; ++offset) {
            var _byte = data[offset];
            4 !== offset && 6 !== offset && 8 !== offset || (result += "-"), _byte < 16 && (result += "0"), result += _byte.toString(16).toLowerCase();
          }
          return result;
        }
      }
      function MakeDictionary(obj) {
        return obj.__ = void 0, delete obj.__, obj;
      }
      exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
    }((target = Reflect, function (key, value) {
      "function" != typeof target[key] && Object.defineProperty(target, key, {
        configurable: !0,
        writable: !0,
        value: value
      });
    })), Reflect;
  })({});

  function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
    var _paramOrPropertyMetad;
    var metadatas = [metadata];
    var paramsOrPropertiesMetadata = {};
    Reflect$1.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect$1.getMetadata(metadataKey, annotationTarget));
    var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
    void 0 === paramOrPropertyMetadata && (paramOrPropertyMetadata = []), (_paramOrPropertyMetad = paramOrPropertyMetadata).push.apply(_paramOrPropertyMetad, metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, Reflect$1.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
  }
  function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
    _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
  }
  function createTaggedDecorator(metadata) {
    return function (target, targetKey, indexOrPropertyDescriptor) {
      tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
    };
  }
  function injectBase(metadataKey) {
    return function (serviceIdentifier) {
      return function (target, targetKey, indexOrPropertyDescriptor) {
        return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
      };
    };
  }

  var inject = injectBase(INJECT_TAG);

  var multiInject = injectBase(MULTI_INJECT_TAG);

  function injectable() {
    return function (target) {
      return Reflect$1.defineMetadata(PARAM_TYPES, null, target), target;
    };
  }

  function named(name) {
    return createTaggedDecorator(new Metadata(NAMED_TAG, name));
  }

  var BindingScopeEnum = {
      Singleton: "Singleton",
      Transient: "Transient"
    },
    BindingTypeEnum = {
      ConstantValue: "ConstantValue",
      Constructor: "Constructor",
      DynamicValue: "DynamicValue",
      Factory: "Factory",
      Function: "Function",
      Instance: "Instance",
      Invalid: "Invalid",
      Provider: "Provider"
    };

  var Binding = /*#__PURE__*/function () {
    function Binding(serviceIdentifier, scope) {
      _classCallCheck(this, Binding);
      this.id = Generator.GenAutoIncrementId(), this.activated = !1, this.serviceIdentifier = serviceIdentifier, this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = function (request) {
        return !0;
      }, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.dynamicValue = null;
    }
    _createClass(Binding, [{
      key: "clone",
      value: function clone() {
        var clone = new Binding(this.serviceIdentifier, this.scope);
        return clone.activated = clone.scope === BindingScopeEnum.Singleton && this.activated, clone.implementationType = this.implementationType, clone.dynamicValue = this.dynamicValue, clone.scope = this.scope, clone.type = this.type, clone.provider = this.provider, clone.constraint = this.constraint, clone.cache = this.cache, clone;
      }
    }]);
    return Binding;
  }();

  var MetadataReader = /*#__PURE__*/function () {
    function MetadataReader() {
      _classCallCheck(this, MetadataReader);
    }
    _createClass(MetadataReader, [{
      key: "getConstructorMetadata",
      value: function getConstructorMetadata(constructorFunc) {
        return {
          compilerGeneratedMetadata: Reflect$1.getMetadata(PARAM_TYPES, constructorFunc),
          userGeneratedMetadata: Reflect$1.getMetadata(TAGGED, constructorFunc) || {}
        };
      }
    }, {
      key: "getPropertiesMetadata",
      value: function getPropertiesMetadata(constructorFunc) {
        throw new Error("暂未实现");
      }
    }]);
    return MetadataReader;
  }();

  var taggedConstraint = function taggedConstraint(key) {
    return function (value) {
      var constraint = function constraint(request) {
        if (null == request) return !1;
        if (request.key === key && request.value === value) return !0;
        if (null == request.constructorArgsMetadata) return !1;
        var constructorArgsMetadata = request.constructorArgsMetadata;
        for (var i = 0; i < constructorArgsMetadata.length; i++) if (constructorArgsMetadata[i].key === key && constructorArgsMetadata[i].value === value) return !0;
        return !1;
      };
      return constraint.metaData = new Metadata(key, value), constraint;
    };
  };
  var namedConstraint = taggedConstraint(NAMED_TAG);

  var BindingInSyntax = /*#__PURE__*/function () {
    function BindingInSyntax(binding) {
      _classCallCheck(this, BindingInSyntax);
      this._binding = binding;
    }
    _createClass(BindingInSyntax, [{
      key: "inRequestScope",
      value: function inRequestScope() {
        throw new Error("暂未实现");
      }
    }, {
      key: "inSingletonScope",
      value: function inSingletonScope() {
        return this._binding.scope = BindingScopeEnum.Singleton, this;
      }
    }, {
      key: "inTransientScope",
      value: function inTransientScope() {
        return this._binding.scope = BindingScopeEnum.Transient, this;
      }
    }, {
      key: "whenTargetNamed",
      value: function whenTargetNamed(name) {
        return this._binding.constraint = namedConstraint(name), this;
      }
    }]);
    return BindingInSyntax;
  }();

  var BindingToSyntax = /*#__PURE__*/function () {
    function BindingToSyntax(binding) {
      _classCallCheck(this, BindingToSyntax);
      this._binding = binding;
    }
    _createClass(BindingToSyntax, [{
      key: "to",
      value: function to(constructor) {
        return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, new BindingInSyntax(this._binding);
      }
    }, {
      key: "toSelf",
      value: function toSelf() {
        var self = this._binding.serviceIdentifier;
        return this.to(self);
      }
    }, {
      key: "toDynamicValue",
      value: function toDynamicValue(func) {
        return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInSyntax(this._binding);
      }
    }, {
      key: "toConstantValue",
      value: function toConstantValue(value) {
        return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
      }
    }, {
      key: "toFactory",
      value: function toFactory(factory) {
        return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
      }
    }, {
      key: "toService",
      value: function toService(service) {
        this.toDynamicValue(function (context) {
          return context.container.get(service);
        });
      }
    }]);
    return BindingToSyntax;
  }();

  var Container = /*#__PURE__*/function () {
    function Container(containerOptions) {
      _classCallCheck(this, Container);
      var options = containerOptions || {};
      options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = new Map(), this._metadataReader = new MetadataReader();
    }
    _createClass(Container, [{
      key: "load",
      value: function load(module) {
        var containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
        module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
      }
    }, {
      key: "get",
      value: function get(serviceIdentifier) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, !1);
        return this._get(getArgs);
      }
    }, {
      key: "getAll",
      value: function getAll(serviceIdentifier) {
        var getArgs = this._getAllArgs(serviceIdentifier);
        return this._get(getArgs);
      }
    }, {
      key: "getTagged",
      value: function getTagged(serviceIdentifier, key, value) {
        var getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value);
        return this._get(getArgs);
      }
    }, {
      key: "getNamed",
      value: function getNamed(serviceIdentifier, named) {
        return this.getTagged(serviceIdentifier, NAMED_TAG, named);
      }
    }, {
      key: "isBound",
      value: function isBound(serviceIdentifier) {
        return this._bindingDictionary.has(serviceIdentifier);
      }
    }, {
      key: "bind",
      value: function bind(serviceIdentifier) {
        var scope = this.options.defaultScope,
          binding = new Binding(serviceIdentifier, scope),
          list = this._bindingDictionary.get(serviceIdentifier) || [];
        return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), new BindingToSyntax(binding);
      }
    }, {
      key: "unbind",
      value: function unbind(serviceIdentifier) {
        this._bindingDictionary["delete"](serviceIdentifier);
      }
    }, {
      key: "rebind",
      value: function rebind(serviceIdentifier) {
        return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
      }
    }, {
      key: "_getContainerModuleHelpersFactory",
      value: function _getContainerModuleHelpersFactory() {
        var _this = this;
        var setModuleId = function setModuleId(bindingToSyntax, moduleId) {
            bindingToSyntax._binding.moduleId = moduleId;
          },
          getBindFunction = function getBindFunction(moduleId) {
            return function (serviceIdentifier) {
              var bindingToSyntax = _this.bind(serviceIdentifier);
              return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
            };
          },
          getUnbindFunction = function getUnbindFunction() {
            return function (serviceIdentifier) {
              return _this.unbind(serviceIdentifier);
            };
          },
          getIsboundFunction = function getIsboundFunction() {
            return function (serviceIdentifier) {
              return _this.isBound(serviceIdentifier);
            };
          },
          getRebindFunction = function getRebindFunction(moduleId) {
            return function (serviceIdentifier) {
              var bindingToSyntax = _this.rebind(serviceIdentifier);
              return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
            };
          };
        return function (mId) {
          return {
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(),
            rebindFunction: getRebindFunction(mId),
            unbindFunction: getUnbindFunction(),
            unbindAsyncFunction: function unbindAsyncFunction(serviceIdentifier) {
              return null;
            }
          };
        };
      }
    }, {
      key: "_getNotAllArgs",
      value: function _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
        return {
          avoidConstraints: !1,
          isMultiInject: isMultiInject,
          serviceIdentifier: serviceIdentifier,
          key: key,
          value: value
        };
      }
    }, {
      key: "_getAllArgs",
      value: function _getAllArgs(serviceIdentifier) {
        return {
          avoidConstraints: !0,
          isMultiInject: !0,
          serviceIdentifier: serviceIdentifier
        };
      }
    }, {
      key: "_get",
      value: function _get(getArgs) {
        var _this2 = this;
        var result = [];
        return this._bindingDictionary.get(getArgs.serviceIdentifier).filter(function (b) {
          return b.constraint(getArgs);
        }).forEach(function (binding) {
          result.push(_this2._resolveFromBinding(binding));
        }), getArgs.isMultiInject || 1 !== result.length ? result : result[0];
      }
    }, {
      key: "_getChildRequest",
      value: function _getChildRequest(binding) {
        var _this3 = this;
        var constr = binding.implementationType,
          _this$_metadataReader = this._metadataReader.getConstructorMetadata(constr),
          userGeneratedMetadata = _this$_metadataReader.userGeneratedMetadata,
          keys = Object.keys(userGeneratedMetadata),
          arr = [];
        var _loop = function _loop() {
          var constructorArgsMetadata = userGeneratedMetadata[i],
            targetMetadataMap = {};
          constructorArgsMetadata.forEach(function (md) {
            targetMetadataMap[md.key] = md.value;
          });
          var metadata = {
              inject: targetMetadataMap[INJECT_TAG],
              multiInject: targetMetadataMap[MULTI_INJECT_TAG]
            },
            injectIdentifier = metadata.inject || metadata.multiInject,
            target = {
              serviceIdentifier: injectIdentifier,
              constructorArgsMetadata: constructorArgsMetadata
            },
            request = {
              injectIdentifier: injectIdentifier,
              metadata: constructorArgsMetadata,
              bindings: _this3._bindingDictionary.get(injectIdentifier).filter(function (b) {
                return b.constraint(target);
              })
            };
          arr.push(request);
        };
        for (var i = 0; i < keys.length; i++) {
          _loop();
        }
        return arr;
      }
    }, {
      key: "_resolveFromBinding",
      value: function _resolveFromBinding(binding) {
        var result = this._getResolvedFromBinding(binding);
        return this._saveToScope(binding, result), result;
      }
    }, {
      key: "_getResolvedFromBinding",
      value: function _getResolvedFromBinding(binding) {
        var result;
        switch (binding.type) {
          case BindingTypeEnum.ConstantValue:
          case BindingTypeEnum.Function:
            result = binding.cache;
            break;
          case BindingTypeEnum.Instance:
            result = this._resolveInstance(binding, binding.implementationType);
            break;
          default:
            result = binding.dynamicValue({
              container: this
            });
        }
        return result;
      }
    }, {
      key: "_resolveInstance",
      value: function _resolveInstance(binding, constr) {
        if (binding.activated) return binding.cache;
        var childRequests = this._getChildRequest(binding);
        return this._createInstance(constr, childRequests);
      }
    }, {
      key: "_createInstance",
      value: function _createInstance(constr, childRequests) {
        if (childRequests.length) {
          return _construct(constr, _toConsumableArray(this._resolveRequests(childRequests)));
        }
        return new constr();
      }
    }, {
      key: "_resolveRequests",
      value: function _resolveRequests(childRequests) {
        var _this4 = this;
        return childRequests.map(function (request) {
          return request.bindings.length > 1 ? request.bindings.map(function (binding) {
            return _this4._resolveFromBinding(binding);
          }) : _this4._resolveFromBinding(request.bindings[0]);
        });
      }
    }, {
      key: "_saveToScope",
      value: function _saveToScope(binding, result) {
        binding.scope === BindingScopeEnum.Singleton && (binding.cache = result, binding.activated = !0);
      }
    }]);
    return Container;
  }();

  var ContributionProvider = Symbol("ContributionProvider");
  var ContributionProviderCache = /*#__PURE__*/function () {
    function ContributionProviderCache(serviceIdentifier, container) {
      _classCallCheck(this, ContributionProviderCache);
      this.serviceIdentifier = serviceIdentifier, this.container = container;
    }
    _createClass(ContributionProviderCache, [{
      key: "getContributions",
      value: function getContributions() {
        var _this$caches;
        return this.caches || (this.caches = [], this.container && this.container.isBound(this.serviceIdentifier) && (_this$caches = this.caches).push.apply(_this$caches, _toConsumableArray(this.container.getAll(this.serviceIdentifier)))), this.caches;
      }
    }]);
    return ContributionProviderCache;
  }();
  function bindContributionProvider(bind, id) {
    bind(ContributionProvider).toDynamicValue(function (_ref) {
      var container = _ref.container;
      return new ContributionProviderCache(id, container);
    }).inSingletonScope().whenTargetNamed(id);
  }
  function bindContributionProviderNoSingletonScope(bind, id) {
    bind(ContributionProvider).toDynamicValue(function (_ref2) {
      var container = _ref2.container;
      return new ContributionProviderCache(id, container);
    }).whenTargetNamed(id);
  }

  var Hook = /*#__PURE__*/function () {
    function Hook(args, name) {
      _classCallCheck(this, Hook);
      this._args = args, this.name = name, this.taps = [];
    }
    _createClass(Hook, [{
      key: "tap",
      value: function tap(options, fn) {
        this._tap("sync", options, fn);
      }
    }, {
      key: "unTap",
      value: function unTap(options, fn) {
        var name = "string" == typeof options ? options.trim() : options.name;
        name && (this.taps = this.taps.filter(function (tap) {
          return tap.name !== name && (!fn || tap.fn === fn);
        }));
      }
    }, {
      key: "_parseOptions",
      value: function _parseOptions(type, options, fn) {
        var _options;
        if ("string" == typeof options) _options = {
          name: options.trim()
        };else if ("object" != _typeof(options) || null === options) throw new Error("Invalid tap options");
        if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
        return _options = Object.assign({
          type: type,
          fn: fn
        }, _options), _options;
      }
    }, {
      key: "_tap",
      value: function _tap(type, options, fn) {
        this._insert(this._parseOptions(type, options, fn));
      }
    }, {
      key: "_insert",
      value: function _insert(item) {
        var before;
        "string" == typeof item.before ? before = new Set([item.before]) : Array.isArray(item.before) && (before = new Set(item.before));
        var stage = 0;
        "number" == typeof item.stage && (stage = item.stage);
        var i = this.taps.length;
        for (; i > 0;) {
          i--;
          var x = this.taps[i];
          this.taps[i + 1] = x;
          var xStage = x.stage || 0;
          if (before) {
            if (before.has(x.name)) {
              before["delete"](x.name);
              continue;
            }
            if (before.size > 0) continue;
          }
          if (!(xStage > stage)) {
            i++;
            break;
          }
        }
        this.taps[i] = item;
      }
    }]);
    return Hook;
  }();

  var SyncHook = /*#__PURE__*/function (_Hook) {
    _inherits(SyncHook, _Hook);
    var _super = _createSuper(SyncHook);
    function SyncHook() {
      _classCallCheck(this, SyncHook);
      return _super.apply(this, arguments);
    }
    _createClass(SyncHook, [{
      key: "call",
      value: function call() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this.taps.map(function (t) {
          return t.fn;
        }).forEach(function (cb) {
          return cb.apply(void 0, args);
        });
      }
    }]);
    return SyncHook;
  }(Hook);

  var EnvContribution = Symbol["for"]("EnvContribution");
  var VGlobal = Symbol["for"]("VGlobal");

  var __decorate$1H = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$1h = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$S = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultGlobal = /*#__PURE__*/function () {
    function DefaultGlobal(contributions) {
      _classCallCheck(this, DefaultGlobal);
      this.contributions = contributions, this.id = Generator.GenAutoIncrementId(), this.hooks = {
        onSetEnv: new SyncHook(["lastEnv", "env", "global"])
      }, this.measureTextMethod = "native", this.optimizeVisible = !1;
    }
    _createClass(DefaultGlobal, [{
      key: "env",
      get: function get() {
        return this._env;
      }
    }, {
      key: "devicePixelRatio",
      get: function get() {
        return this._env || this.setEnv("browser"), this.envContribution.getDevicePixelRatio();
      }
    }, {
      key: "supportEvent",
      get: function get() {
        return this._env || this.setEnv("browser"), this.envContribution.supportEvent;
      },
      set: function set(support) {
        this._env || this.setEnv("browser"), this.envContribution.supportEvent = support;
      }
    }, {
      key: "supportsTouchEvents",
      get: function get() {
        return this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents;
      },
      set: function set(support) {
        this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents = support;
      }
    }, {
      key: "supportsPointerEvents",
      get: function get() {
        return this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents;
      },
      set: function set(support) {
        this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents = support;
      }
    }, {
      key: "supportsMouseEvents",
      get: function get() {
        return this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents;
      },
      set: function set(support) {
        this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents = support;
      }
    }, {
      key: "applyStyles",
      get: function get() {
        return this._env || this.setEnv("browser"), this.envContribution.applyStyles;
      },
      set: function set(support) {
        this._env || this.setEnv("browser"), this.envContribution.applyStyles = support;
      }
    }, {
      key: "bindContribution",
      value: function bindContribution(params) {
        var _this = this;
        var promiseArr = [];
        if (this.contributions.getContributions().forEach(function (contribution) {
          var data = contribution.configure(_this, params);
          data && data.then && promiseArr.push(data);
        }), promiseArr.length) return Promise.all(promiseArr);
      }
    }, {
      key: "getDynamicCanvasCount",
      value: function getDynamicCanvasCount() {
        return this._env || this.setEnv("browser"), this.envContribution.getDynamicCanvasCount();
      }
    }, {
      key: "getStaticCanvasCount",
      value: function getStaticCanvasCount() {
        return this._env || this.setEnv("browser"), this.envContribution.getStaticCanvasCount();
      }
    }, {
      key: "setEnv",
      value: function setEnv(env, params) {
        if (params && !0 === params.force || this._env !== env) return this.deactiveCurrentEnv(), this.activeEnv(env, params);
      }
    }, {
      key: "deactiveCurrentEnv",
      value: function deactiveCurrentEnv() {
        this.envContribution && this.envContribution.release();
      }
    }, {
      key: "activeEnv",
      value: function activeEnv(env, params) {
        var _this2 = this;
        var lastEnv = this._env;
        this._env = env;
        var data = this.bindContribution(params);
        if (data && data.then) return data.then(function () {
          _this2.envParams = params, _this2.hooks.onSetEnv.call(lastEnv, env, _this2);
        });
        this.envParams = params, this.hooks.onSetEnv.call(lastEnv, env, this);
      }
    }, {
      key: "setActiveEnvContribution",
      value: function setActiveEnvContribution(contribution) {
        this.envContribution = contribution;
      }
    }, {
      key: "createCanvas",
      value: function createCanvas(params) {
        return this._env || this.setEnv("browser"), this.envContribution.createCanvas(params);
      }
    }, {
      key: "createOffscreenCanvas",
      value: function createOffscreenCanvas(params) {
        return this._env || this.setEnv("browser"), this.envContribution.createOffscreenCanvas(params);
      }
    }, {
      key: "releaseCanvas",
      value: function releaseCanvas(canvas) {
        return this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(canvas);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        return this._env || this.setEnv("browser"), this.envContribution.addEventListener(type, listener, options);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        return this._env || this.setEnv("browser"), this.envContribution.removeEventListener(type, listener, options);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(event);
      }
    }, {
      key: "getRequestAnimationFrame",
      value: function getRequestAnimationFrame() {
        return this._env || this.setEnv("browser"), this.envContribution.getRequestAnimationFrame();
      }
    }, {
      key: "getCancelAnimationFrame",
      value: function getCancelAnimationFrame() {
        return this._env || this.setEnv("browser"), this.envContribution.getCancelAnimationFrame();
      }
    }, {
      key: "getElementById",
      value: function getElementById(str) {
        return this._env || this.setEnv("browser"), this.envContribution.getElementById ? this.envContribution.getElementById(str) : null;
      }
    }, {
      key: "getRootElement",
      value: function getRootElement() {
        return this._env || this.setEnv("browser"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;
      }
    }, {
      key: "getDocument",
      value: function getDocument() {
        return this._env || this.setEnv("browser"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;
      }
    }, {
      key: "mapToCanvasPoint",
      value: function mapToCanvasPoint(event, domElement) {
        return this._env || this.setEnv("browser"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event, domElement) : null;
      }
    }, {
      key: "loadImage",
      value: function loadImage(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadImage(url);
      }
    }, {
      key: "loadSvg",
      value: function loadSvg(str) {
        return this._env || this.setEnv("browser"), this.envContribution.loadSvg(str);
      }
    }, {
      key: "loadJson",
      value: function loadJson(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadJson(url);
      }
    }, {
      key: "loadArrayBuffer",
      value: function loadArrayBuffer(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadArrayBuffer(url);
      }
    }, {
      key: "loadBlob",
      value: function loadBlob(url) {
        return this._env || this.setEnv("browser"), this.envContribution.loadBlob(url);
      }
    }, {
      key: "isChrome",
      value: function isChrome() {
        return null != this._isChrome || (this._env || this.setEnv("browser"), this._isChrome = "browser" === this._env && navigator.userAgent.indexOf("Chrome") > -1), this._isChrome;
      }
    }, {
      key: "isSafari",
      value: function isSafari() {
        return null != this._isSafari || (this._env || this.setEnv("browser"), this._isSafari = "browser" === this._env && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)), this._isSafari;
      }
    }, {
      key: "getNativeAABBBounds",
      value: function getNativeAABBBounds(dom) {
        return this._env || this.setEnv("browser"), this.envContribution.getNativeAABBBounds(dom);
      }
    }, {
      key: "removeDom",
      value: function removeDom(dom) {
        return this._env || this.setEnv("browser"), this.envContribution.removeDom(dom);
      }
    }, {
      key: "createDom",
      value: function createDom(params) {
        return this._env || this.setEnv("browser"), this.envContribution.createDom(params);
      }
    }, {
      key: "getElementTop",
      value: function getElementTop(dom) {
        var baseWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return this._env || this.setEnv("browser"), this.envContribution.getElementTop(dom, baseWindow);
      }
    }, {
      key: "getElementLeft",
      value: function getElementLeft(dom) {
        var baseWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return this._env || this.setEnv("browser"), this.envContribution.getElementLeft(dom, baseWindow);
      }
    }, {
      key: "getElementTopLeft",
      value: function getElementTopLeft(dom) {
        var baseWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return this._env || this.setEnv("browser"), this.envContribution.getElementTopLeft(dom, baseWindow);
      }
    }]);
    return DefaultGlobal;
  }();
  exports.DefaultGlobal = __decorate$1H([injectable(), __param$S(0, inject(ContributionProvider)), __param$S(0, named(EnvContribution)), __metadata$1h("design:paramtypes", [Object])], exports.DefaultGlobal);

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  var eventemitter3 = {exports: {}};

  (function (module) {

    var has = Object.prototype.hasOwnProperty,
      prefix = '~';

    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @private
     */
    function Events() {}

    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);

      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }

    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }

    /**
     * Add a listener for a given event.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} once Specify if the listener is a one-time listener.
     * @returns {EventEmitter}
     * @private
     */
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
      }
      var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }

    /**
     * Clear event by name.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} evt The Event name.
     * @private
     */
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
    }

    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }

    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [],
        events,
        name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };

    /**
     * Return the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Array} The registered listeners.
     * @public
     */
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };

    /**
     * Return the number of listeners listening to a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Number} The number of listeners.
     * @public
     */
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };

    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length,
          j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };

    /**
     * Add a listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };

    /**
     * Add a one-time listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };

    /**
     * Remove the listeners of a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {*} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }

        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
      }
      return this;
    };

    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {(String|Symbol)} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };

    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;

    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;

    //
    // Expose the module.
    //
    {
      module.exports = EventEmitter;
    }
  })(eventemitter3);
  var eventemitter3Exports = eventemitter3.exports;
  var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

  var isType = function isType(value, type) {
    return Object.prototype.toString.call(value) === "[object ".concat(type, "]");
  };
  var isType$1 = isType;

  var isBoolean = function isBoolean(value) {
    var fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return fuzzy ? "boolean" == typeof value : !0 === value || !1 === value || isType$1(value, "Boolean");
  };
  var isBoolean$1 = isBoolean;

  var isFunction = function isFunction(value) {
    return "function" == typeof value;
  };
  var isFunction$1 = isFunction;

  var isNil = function isNil(value) {
    return null == value;
  };
  var isNil$1 = isNil;

  var isValid = function isValid(value) {
    return null != value;
  };
  var isValid$1 = isValid;

  var isObject = function isObject(value) {
    var type = _typeof(value);
    return null !== value && "object" === type || "function" === type;
  };
  var isObject$1 = isObject;

  var isUndefined = function isUndefined(value) {
    return void 0 === value;
  };
  var isUndefined$1 = isUndefined;

  var isString = function isString(value) {
    var fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var type = _typeof(value);
    return fuzzy ? "string" === type : "string" === type || isType$1(value, "String");
  };
  var isString$1 = isString;

  var isArray = function isArray(value) {
    return Array.isArray ? Array.isArray(value) : isType$1(value, "Array");
  };
  var isArray$1 = isArray;

  var isNumber = function isNumber(value) {
    var fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var type = _typeof(value);
    return fuzzy ? "number" === type : "number" === type || isType$1(value, "Number");
  };
  var isNumber$1 = isNumber;

  var isValidNumber = function isValidNumber(value) {
    return isNumber$1(value) && Number.isFinite(value);
  };
  var isValidNumber$1 = isValidNumber;

  var isValidUrl = function isValidUrl(value) {
    return new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(value);
  };
  var isValidUrl$1 = isValidUrl;

  var isBase64 = function isBase64(value) {
    return new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp|svg\+xml)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(value);
  };
  var isBase64$1 = isBase64;

  var hasOwnProperty = Object.prototype.hasOwnProperty,
    has = function has(object, key) {
      return null != object && hasOwnProperty.call(object, key);
    };
  var has$1 = has;

  function arrayEqual(a, b) {
    if (!isArray$1(a) || !isArray$1(b)) return !1;
    if (a.length !== b.length) return !1;
    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
    return !0;
  }

  var DEFAULT_ABSOLUTE_TOLERATE = 1e-10,
    DEFAULT_RELATIVE_TOLERATE = 1e-10;
  function isNumberClose(a, b) {
    var relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RELATIVE_TOLERATE;
    var absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ABSOLUTE_TOLERATE;
    var abs = absTol,
      rel = relTol * Math.max(a, b);
    return Math.abs(a - b) <= Math.max(abs, rel);
  }

  var clamp = function clamp(input, min, max) {
    return input < min ? min : input > max ? max : input;
  };
  var clamp$1 = clamp;

  var epsilon = 1e-12;
  var pi = Math.PI;
  var halfPi$1 = pi / 2;
  var tau = 2 * pi;
  var pi2 = 2 * Math.PI;
  var abs = Math.abs;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var max = Math.max;
  var min = Math.min;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  var pow = Math.pow;
  function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
  }
  function asin(x) {
    return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);
  }
  function pointAt(x1, y1, x2, y2, t) {
    var x, y;
    return "number" == typeof x1 && "number" == typeof x2 && (x = (1 - t) * x1 + t * x2), "number" == typeof y1 && "number" == typeof y2 && (y = (1 - t) * y1 + t * y2), {
      x: x,
      y: y
    };
  }
  function crossProduct$1(dir1, dir2) {
    return dir1[0] * dir2[1] - dir1[1] * dir2[0];
  }
  function fuzzyEqualVec(a, b) {
    return abs(a[0] - b[0]) + abs(a[1] - b[1]) < 1e-12;
  }
  function getDecimalPlaces(n) {
    var dStr = n.toString().split(/[eE]/),
      s = (dStr[0].split(".")[1] || "").length - (+dStr[1] || 0);
    return s > 0 ? s : 0;
  }

  var Point = /*#__PURE__*/function () {
    function Point() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var x1 = arguments.length > 2 ? arguments[2] : undefined;
      var y1 = arguments.length > 3 ? arguments[3] : undefined;
      _classCallCheck(this, Point);
      this.x = 0, this.y = 0, this.x = x, this.y = y, this.x1 = x1, this.y1 = y1;
    }
    _createClass(Point, [{
      key: "clone",
      value: function clone() {
        return new Point(this.x, this.y);
      }
    }, {
      key: "copyFrom",
      value: function copyFrom(p) {
        return this.x = p.x, this.y = p.y, this.x1 = p.x1, this.y1 = p.y1, this.defined = p.defined, this.context = p.context, this;
      }
    }, {
      key: "set",
      value: function set(x, y) {
        return this.x = x, this.y = y, this;
      }
    }, {
      key: "add",
      value: function add(point) {
        return isNumber$1(point) ? (this.x += point, void (this.y += point)) : (this.x += point.x, this.y += point.y, this);
      }
    }, {
      key: "sub",
      value: function sub(point) {
        return isNumber$1(point) ? (this.x -= point, void (this.y -= point)) : (this.x -= point.x, this.y -= point.y, this);
      }
    }, {
      key: "multi",
      value: function multi(point) {
        throw new Error("暂不支持");
      }
    }, {
      key: "div",
      value: function div(point) {
        throw new Error("暂不支持");
      }
    }]);
    return Point;
  }();
  var PointService = /*#__PURE__*/function () {
    function PointService() {
      _classCallCheck(this, PointService);
    }
    _createClass(PointService, null, [{
      key: "distancePP",
      value: function distancePP(p1, p2) {
        return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
      }
    }, {
      key: "distanceNN",
      value: function distanceNN(x, y, x1, y1) {
        return sqrt(pow(x - x1, 2) + pow(y - y1, 2));
      }
    }, {
      key: "distancePN",
      value: function distancePN(point, x, y) {
        return sqrt(pow(x - point.x, 2) + pow(y - point.y, 2));
      }
    }, {
      key: "pointAtPP",
      value: function pointAtPP(p1, p2, t) {
        return new Point((p2.x - p1.x) * t + p1.x, (p2.y - p1.y) * t + p1.y);
      }
    }]);
    return PointService;
  }();

  function transformBoundsWithMatrix(out, bounds, matrix) {
    var x1 = bounds.x1,
      y1 = bounds.y1,
      x2 = bounds.x2,
      y2 = bounds.y2;
    return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x1 + matrix.c * y1 + matrix.e, matrix.b * x1 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y1 + matrix.e, matrix.b * x2 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y2 + matrix.e, matrix.b * x2 + matrix.d * y2 + matrix.f), out.add(matrix.a * x1 + matrix.c * y2 + matrix.e, matrix.b * x1 + matrix.d * y2 + matrix.f), bounds);
  }
  var Bounds = /*#__PURE__*/function () {
    function Bounds(bounds) {
      _classCallCheck(this, Bounds);
      bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
    }
    _createClass(Bounds, [{
      key: "clone",
      value: function clone() {
        return new Bounds(this);
      }
    }, {
      key: "clear",
      value: function clear() {
        return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
      }
    }, {
      key: "empty",
      value: function empty() {
        return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
      }
    }, {
      key: "equals",
      value: function equals(b) {
        return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
      }
    }, {
      key: "setValue",
      value: function setValue() {
        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        return this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this;
      }
    }, {
      key: "set",
      value: function set() {
        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        return x2 < x1 ? (this.x2 = x1, this.x1 = x2) : (this.x1 = x1, this.x2 = x2), y2 < y1 ? (this.y2 = y1, this.y1 = y2) : (this.y1 = y1, this.y2 = y2), this;
      }
    }, {
      key: "add",
      value: function add() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return x < this.x1 && (this.x1 = x), y < this.y1 && (this.y1 = y), x > this.x2 && (this.x2 = x), y > this.y2 && (this.y2 = y), this;
      }
    }, {
      key: "expand",
      value: function expand() {
        var d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return isArray$1(d) ? (this.y1 -= d[0], this.x2 += d[1], this.y2 += d[2], this.x1 -= d[3]) : (this.x1 -= d, this.y1 -= d, this.x2 += d, this.y2 += d), this;
      }
    }, {
      key: "round",
      value: function round() {
        return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
      }
    }, {
      key: "translate",
      value: function translate() {
        var dx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var dy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
      }
    }, {
      key: "rotate",
      value: function rotate() {
        var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var p = this.rotatedPoints(angle, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
      }
    }, {
      key: "scale",
      value: function scale() {
        var sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var p = this.scalePoints(sx, sy, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]);
      }
    }, {
      key: "union",
      value: function union(b) {
        return b.x1 < this.x1 && (this.x1 = b.x1), b.y1 < this.y1 && (this.y1 = b.y1), b.x2 > this.x2 && (this.x2 = b.x2), b.y2 > this.y2 && (this.y2 = b.y2), this;
      }
    }, {
      key: "intersect",
      value: function intersect(b) {
        return b.x1 > this.x1 && (this.x1 = b.x1), b.y1 > this.y1 && (this.y1 = b.y1), b.x2 < this.x2 && (this.x2 = b.x2), b.y2 < this.y2 && (this.y2 = b.y2), this;
      }
    }, {
      key: "encloses",
      value: function encloses(b) {
        return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
      }
    }, {
      key: "alignsWith",
      value: function alignsWith(b) {
        return b && (this.x1 === b.x1 || this.x2 === b.x2 || this.y1 === b.y1 || this.y2 === b.y2);
      }
    }, {
      key: "intersects",
      value: function intersects(b) {
        return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
      }
    }, {
      key: "contains",
      value: function contains() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(p) {
        return !(p.x < this.x1 || p.x > this.x2 || p.y < this.y1 || p.y > this.y2);
      }
    }, {
      key: "width",
      value: function width() {
        return this.empty() ? 0 : this.x2 - this.x1;
      }
    }, {
      key: "height",
      value: function height() {
        return this.empty() ? 0 : this.y2 - this.y1;
      }
    }, {
      key: "scaleX",
      value: function scaleX() {
        var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this.x1 *= s, this.x2 *= s, this;
      }
    }, {
      key: "scaleY",
      value: function scaleY() {
        var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        return this.y1 *= s, this.y2 *= s, this;
      }
    }, {
      key: "transformWithMatrix",
      value: function transformWithMatrix(matrix) {
        return transformBoundsWithMatrix(this, this, matrix), this;
      }
    }, {
      key: "copy",
      value: function copy(b) {
        return this.x1 = b.x1, this.y1 = b.y1, this.x2 = b.x2, this.y2 = b.y2, this;
      }
    }, {
      key: "rotatedPoints",
      value: function rotatedPoints(angle, x, y) {
        var x1 = this.x1,
          y1 = this.y1,
          x2 = this.x2,
          y2 = this.y2,
          cos = Math.cos(angle),
          sin = Math.sin(angle),
          cx = x - x * cos + y * sin,
          cy = y - x * sin - y * cos;
        return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
      }
    }, {
      key: "scalePoints",
      value: function scalePoints(sx, sy, x, y) {
        var x1 = this.x1,
          y1 = this.y1,
          x2 = this.x2,
          y2 = this.y2;
        return [sx * x1 + (1 - sx) * x, sy * y1 + (1 - sy) * y, sx * x2 + (1 - sx) * x, sy * y2 + (1 - sy) * y];
      }
    }]);
    return Bounds;
  }();
  var AABBBounds = /*#__PURE__*/function (_Bounds) {
    _inherits(AABBBounds, _Bounds);
    var _super = _createSuper(AABBBounds);
    function AABBBounds() {
      _classCallCheck(this, AABBBounds);
      return _super.apply(this, arguments);
    }
    return _createClass(AABBBounds);
  }(Bounds);

  function degreeToRadian(degree) {
    return degree * (Math.PI / 180);
  }
  function radianToDegree(radian) {
    return 180 * radian / Math.PI;
  }
  var clampRadian = function clampRadian() {
    var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    if (angle < 0) for (; angle < -tau;) angle += tau;else if (angle > 0) for (; angle > tau;) angle -= tau;
    return angle;
  };
  var clampAngleByRadian = clampRadian;
  function getAngleByPoint(center, point) {
    return Math.atan2(point.y - center.y, point.x - center.x);
  }

  var Matrix = /*#__PURE__*/function () {
    function Matrix() {
      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var f = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      _classCallCheck(this, Matrix);
      this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f;
    }
    _createClass(Matrix, [{
      key: "equalToMatrix",
      value: function equalToMatrix(m2) {
        return !(this.e !== m2.e || this.f !== m2.f || this.a !== m2.a || this.d !== m2.d || this.b !== m2.b || this.c !== m2.c);
      }
    }, {
      key: "equalTo",
      value: function equalTo(a, b, c, d, e, f) {
        return !(this.e !== e || this.f !== f || this.a !== a || this.d !== d || this.b !== b || this.c !== c);
      }
    }, {
      key: "setValue",
      value: function setValue(a, b, c, d, e, f) {
        return this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f, this;
      }
    }, {
      key: "reset",
      value: function reset() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
      }
    }, {
      key: "getInverse",
      value: function getInverse() {
        var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f,
          m = new Matrix(),
          dt = a * d - b * c;
        return m.a = d / dt, m.b = -b / dt, m.c = -c / dt, m.d = a / dt, m.e = (c * f - d * e) / dt, m.f = -(a * f - b * e) / dt, m;
      }
    }, {
      key: "rotate",
      value: function rotate(rad) {
        var c = Math.cos(rad),
          s = Math.sin(rad),
          m11 = this.a * c + this.c * s,
          m12 = this.b * c + this.d * s,
          m21 = this.a * -s + this.c * c,
          m22 = this.b * -s + this.d * c;
        return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this;
      }
    }, {
      key: "rotateByCenter",
      value: function rotateByCenter(rad, cx, cy) {
        var cos = Math.cos(rad),
          sin = Math.sin(rad),
          rotateM13 = (1 - cos) * cx + sin * cy,
          rotateM23 = (1 - cos) * cy - sin * cx,
          m11 = cos * this.a - sin * this.b,
          m21 = sin * this.a + cos * this.b,
          m12 = cos * this.c - sin * this.d,
          m22 = sin * this.c + cos * this.d,
          m13 = cos * this.e - sin * this.f + rotateM13,
          m23 = sin * this.e + cos * this.f + rotateM23;
        return this.a = m11, this.b = m21, this.c = m12, this.d = m22, this.e = m13, this.f = m23, this;
      }
    }, {
      key: "scale",
      value: function scale(sx, sy) {
        return this.a *= sx, this.b *= sx, this.c *= sy, this.d *= sy, this;
      }
    }, {
      key: "setScale",
      value: function setScale(sx, sy) {
        return this.b = this.b / this.a * sx, this.c = this.c / this.d * sy, this.a = sx, this.d = sy, this;
      }
    }, {
      key: "transform",
      value: function transform(a, b, c, d, e, f) {
        return this.multiply(a, b, c, d, e, f), this;
      }
    }, {
      key: "translate",
      value: function translate(x, y) {
        return this.e += this.a * x + this.c * y, this.f += this.b * x + this.d * y, this;
      }
    }, {
      key: "transpose",
      value: function transpose() {
        var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f;
        return this.a = b, this.b = a, this.c = d, this.d = c, this.e = f, this.f = e, this;
      }
    }, {
      key: "multiply",
      value: function multiply(a2, b2, c2, d2, e2, f2) {
        var a1 = this.a,
          b1 = this.b,
          c1 = this.c,
          d1 = this.d,
          m11 = a1 * a2 + c1 * b2,
          m12 = b1 * a2 + d1 * b2,
          m21 = a1 * c2 + c1 * d2,
          m22 = b1 * c2 + d1 * d2,
          dx = a1 * e2 + c1 * f2 + this.e,
          dy = b1 * e2 + d1 * f2 + this.f;
        return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this.e = dx, this.f = dy, this;
      }
    }, {
      key: "interpolate",
      value: function interpolate(m2, t) {
        var m = new Matrix();
        return m.a = this.a + (m2.a - this.a) * t, m.b = this.b + (m2.b - this.b) * t, m.c = this.c + (m2.c - this.c) * t, m.d = this.d + (m2.d - this.d) * t, m.e = this.e + (m2.e - this.e) * t, m.f = this.f + (m2.f - this.f) * t, m;
      }
    }, {
      key: "transformPoint",
      value: function transformPoint(source, target) {
        var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          e = this.e,
          f = this.f,
          dt = a * d - b * c,
          nextA = d / dt,
          nextB = -b / dt,
          nextC = -c / dt,
          nextD = a / dt,
          nextE = (c * f - d * e) / dt,
          nextF = -(a * f - b * e) / dt,
          x = source.x,
          y = source.y;
        target.x = x * nextA + y * nextC + nextE, target.y = x * nextB + y * nextD + nextF;
      }
    }, {
      key: "onlyTranslate",
      value: function onlyTranslate() {
        var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        return this.a === scale && 0 === this.b && 0 === this.c && this.d === scale;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
      }
    }, {
      key: "toTransformAttrs",
      value: function toTransformAttrs() {
        var a = this.a,
          b = this.b,
          c = this.c,
          d = this.d,
          delta = a * d - b * c,
          result = {
            x: this.e,
            y: this.f,
            rotateDeg: 0,
            scaleX: 0,
            scaleY: 0,
            skewX: 0,
            skewY: 0
          };
        if (0 !== a || 0 !== b) {
          var r = Math.sqrt(a * a + b * b);
          result.rotateDeg = b > 0 ? Math.acos(a / r) : -Math.acos(a / r), result.scaleX = r, result.scaleY = delta / r, result.skewX = (a * c + b * d) / delta, result.skewY = 0;
        } else if (0 !== c || 0 !== d) {
          var s = Math.sqrt(c * c + d * d);
          result.rotateDeg = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s)), result.scaleX = delta / s, result.scaleY = s, result.skewX = 0, result.skewY = (a * c + b * d) / delta;
        }
        return result.rotateDeg = radianToDegree(result.rotateDeg), result;
      }
    }]);
    return Matrix;
  }();
  function normalTransform(out, origin, x, y, scaleX, scaleY, angle, rotateCenter) {
    var oa = origin.a,
      ob = origin.b,
      oc = origin.c,
      od = origin.d,
      oe = origin.e,
      of = origin.f,
      cosTheta = cos(angle),
      sinTheta = sin(angle);
    var rotateCenterX, rotateCenterY;
    rotateCenter ? (rotateCenterX = rotateCenter[0], rotateCenterY = rotateCenter[1]) : (rotateCenterX = x, rotateCenterY = y);
    var offsetX = rotateCenterX - x,
      offsetY = rotateCenterY - y,
      a1 = oa * cosTheta + oc * sinTheta,
      b1 = ob * cosTheta + od * sinTheta,
      c1 = oc * cosTheta - oa * sinTheta,
      d1 = od * cosTheta - ob * sinTheta;
    out.a = scaleX * a1, out.b = scaleX * b1, out.c = scaleY * c1, out.d = scaleY * d1, out.e = oe + oa * rotateCenterX + oc * rotateCenterY - a1 * offsetX - c1 * offsetY, out.f = of + ob * rotateCenterX + od * rotateCenterY - b1 * offsetX - d1 * offsetY;
  }

  var LRU = /*#__PURE__*/function () {
    function LRU() {
      _classCallCheck(this, LRU);
      this.CLEAN_THRESHOLD = 1e3, this.L_TIME = 1e3, this.R_COUNT = 1, this.R_TIMESTAMP_MAX_SIZE = 20;
    }
    _createClass(LRU, [{
      key: "clearCache",
      value: function clearCache(cache, params) {
        var _params$CLEAN_THRESHO = params.CLEAN_THRESHOLD,
          CLEAN_THRESHOLD = _params$CLEAN_THRESHO === void 0 ? this.CLEAN_THRESHOLD : _params$CLEAN_THRESHO,
          _params$L_TIME = params.L_TIME,
          L_TIME = _params$L_TIME === void 0 ? this.L_TIME : _params$L_TIME,
          _params$R_COUNT = params.R_COUNT,
          R_COUNT = _params$R_COUNT === void 0 ? this.R_COUNT : _params$R_COUNT;
        if (cache.size < CLEAN_THRESHOLD) return 0;
        var clearNum = 0;
        var clear = function clear(key) {
            clearNum++, cache["delete"](key);
          },
          now = Date.now();
        return cache.forEach(function (item, key) {
          if (item.timestamp.length < R_COUNT) return clear(key);
          var useCount = 0;
          for (; now - item.timestamp[item.timestamp.length - 1 - useCount] < L_TIME && (useCount++, !(useCount >= R_COUNT)););
          if (useCount < R_COUNT) return clear(key);
          for (; now - item.timestamp[0] > L_TIME;) item.timestamp.shift();
        }), clearNum;
      }
    }, {
      key: "addLimitedTimestamp",
      value: function addLimitedTimestamp(cacheItem, t, params) {
        var _params$R_TIMESTAMP_M = params.R_TIMESTAMP_MAX_SIZE,
          R_TIMESTAMP_MAX_SIZE = _params$R_TIMESTAMP_M === void 0 ? this.R_TIMESTAMP_MAX_SIZE : _params$R_TIMESTAMP_M;
        cacheItem.timestamp.length > R_TIMESTAMP_MAX_SIZE && cacheItem.timestamp.shift(), cacheItem.timestamp.push(t);
      }
    }, {
      key: "clearTimeStamp",
      value: function clearTimeStamp(cache, params) {
        var _params$L_TIME2 = params.L_TIME,
          L_TIME = _params$L_TIME2 === void 0 ? this.L_TIME : _params$L_TIME2,
          now = Date.now();
        cache.forEach(function (item) {
          for (; now - item.timestamp[0] > L_TIME;) item.timestamp.shift();
        });
      }
    }, {
      key: "clearItemTimestamp",
      value: function clearItemTimestamp(cacheItem, params) {
        var _params$L_TIME3 = params.L_TIME,
          L_TIME = _params$L_TIME3 === void 0 ? this.L_TIME : _params$L_TIME3,
          now = Date.now();
        for (; now - cacheItem.timestamp[0] > L_TIME;) cacheItem.timestamp.shift();
      }
    }]);
    return LRU;
  }();

  function hslToRgb(h, s, l) {
    s /= 100, l /= 100;
    var c = (1 - Math.abs(2 * l - 1)) * s,
      x = c * (1 - Math.abs(h / 60 % 2 - 1)),
      m = l - c / 2;
    var r = 0,
      g = 0,
      b = 0;
    return 0 <= h && h < 60 ? (r = c, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c) : 240 <= h && h < 300 ? (r = x, g = 0, b = c) : 300 <= h && h < 360 && (r = c, g = 0, b = x), r = Math.round(255 * (r + m)), g = Math.round(255 * (g + m)), b = Math.round(255 * (b + m)), {
      r: r,
      g: g,
      b: b
    };
  }

  function rgbToHsl(r, g, b) {
    r /= 255, g /= 255, b /= 255;
    var cMin = Math.min(r, g, b),
      cMax = Math.max(r, g, b),
      delta = cMax - cMin;
    var h = 0,
      s = 0,
      l = 0;
    return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(100 * s).toFixed(1), l = +(100 * l).toFixed(1), {
      h: h,
      s: s,
      l: l
    };
  }

  var REG_HEX = /^#([0-9a-f]{3,8})$/,
    DEFAULT_COLORS_OPACITY = {
      transparent: 4294967040
    };
  var DEFAULT_COLORS = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  function hex(value) {
    return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
  }
  function rgb(value) {
    return isNumber$1(value) ? new RGB(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray$1(value) ? new RGB(value[0], value[1], value[2]) : new RGB(255, 255, 255);
  }
  function rgba(value) {
    return isNumber$1(value) ? new RGB(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray$1(value) ? new RGB(value[0], value[1], value[2], value[3]) : new RGB(255, 255, 255, 1);
  }
  function SRGBToLinear(c) {
    return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055;
  }
  var Color = /*#__PURE__*/function () {
    function Color(value) {
      _classCallCheck(this, Color);
      var color = Color.parseColorString(value);
      color ? this.color = color : (console.warn("Warn: \u4F20\u5165".concat(value, "\u65E0\u6CD5\u89E3\u6790\u4E3AColor")), this.color = new RGB(255, 255, 255));
    }
    _createClass(Color, [{
      key: "toRGBA",
      value: function toRGBA() {
        return this.color.formatRgb();
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.color.formatRgb();
      }
    }, {
      key: "toHex",
      value: function toHex() {
        return this.color.formatHex();
      }
    }, {
      key: "toHsl",
      value: function toHsl() {
        return this.color.formatHsl();
      }
    }, {
      key: "brighter",
      value: function brighter(k) {
        var _this$color = this.color,
          r = _this$color.r,
          g = _this$color.g,
          b = _this$color.b;
        return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k))), this;
      }
    }, {
      key: "add",
      value: function add(color) {
        var _this$color2 = this.color,
          r = _this$color2.r,
          g = _this$color2.g,
          b = _this$color2.b;
        return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
      }
    }, {
      key: "sub",
      value: function sub(color) {
        return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
      }
    }, {
      key: "multiply",
      value: function multiply(color) {
        var _this$color3 = this.color,
          r = _this$color3.r,
          g = _this$color3.g,
          b = _this$color3.b;
        return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
      }
    }, {
      key: "getHSVBrightness",
      value: function getHSVBrightness() {
        return Math.max(this.color.r, this.color.g, this.color.b) / 255;
      }
    }, {
      key: "getHSLBrightness",
      value: function getHSLBrightness() {
        return .5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
      }
    }, {
      key: "setHsl",
      value: function setHsl(h, s, l) {
        var opacity = this.color.opacity,
          hsl = rgbToHsl(this.color.r, this.color.g, this.color.b),
          rgb = hslToRgb(isNil$1(h) ? hsl.h : clamp$1(h, 0, 360), isNil$1(s) ? hsl.s : s >= 0 && s <= 1 ? 100 * s : s, isNil$1(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
        return this.color = new RGB(rgb.r, rgb.g, rgb.b, opacity), this;
      }
    }, {
      key: "setRGB",
      value: function setRGB(r, g, b) {
        return !isNil$1(r) && (this.color.r = r), !isNil$1(g) && (this.color.g = g), !isNil$1(b) && (this.color.b = b), this;
      }
    }, {
      key: "setHex",
      value: function setHex(value) {
        var formatValue = "".concat(value).trim().toLowerCase(),
          isHex = REG_HEX.exec(formatValue),
          hex = parseInt(isHex[1], 16),
          hexLength = isHex[1].length;
        return 3 === hexLength ? new RGB((hex >> 8 & 15) + ((hex >> 8 & 15) << 4), (hex >> 4 & 15) + ((hex >> 4 & 15) << 4), (15 & hex) + ((15 & hex) << 4), 1) : 6 === hexLength ? rgb(hex) : 8 === hexLength ? new RGB(hex >> 24 & 255, hex >> 16 & 255, hex >> 8 & 255, (255 & hex) / 255) : this;
      }
    }, {
      key: "setColorName",
      value: function setColorName(name) {
        var hex = DEFAULT_COLORS[name.toLowerCase()];
        return void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + name), this;
      }
    }, {
      key: "setScalar",
      value: function setScalar(scalar) {
        return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
      }
    }, {
      key: "setOpacity",
      value: function setOpacity() {
        var o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        return this.color.opacity = o, this;
      }
    }, {
      key: "getLuminance",
      value: function getLuminance() {
        return (.2126 * this.color.r + .7152 * this.color.g + .0722 * this.color.b) / 255;
      }
    }, {
      key: "getLuminance2",
      value: function getLuminance2() {
        return (.2627 * this.color.r + .678 * this.color.g + .0593 * this.color.b) / 255;
      }
    }, {
      key: "getLuminance3",
      value: function getLuminance3() {
        return (.299 * this.color.r + .587 * this.color.g + .114 * this.color.b) / 255;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Color(this.color.toString());
      }
    }, {
      key: "copyGammaToLinear",
      value: function copyGammaToLinear(color) {
        var gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
      }
    }, {
      key: "copyLinearToGamma",
      value: function copyLinearToGamma(color) {
        var gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
      }
    }, {
      key: "convertGammaToLinear",
      value: function convertGammaToLinear(gammaFactor) {
        return this.copyGammaToLinear(this, gammaFactor), this;
      }
    }, {
      key: "convertLinearToGamma",
      value: function convertLinearToGamma(gammaFactor) {
        return this.copyLinearToGamma(this, gammaFactor), this;
      }
    }, {
      key: "copySRGBToLinear",
      value: function copySRGBToLinear(color) {
        return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
      }
    }, {
      key: "copyLinearToSRGB",
      value: function copyLinearToSRGB(color) {
        return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
      }
    }, {
      key: "convertSRGBToLinear",
      value: function convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
    }, {
      key: "convertLinearToSRGB",
      value: function convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
    }], [{
      key: "Brighter",
      value: function Brighter(source) {
        var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        return 1 === b ? source : new Color(source).brighter(b).toRGBA();
      }
    }, {
      key: "SetOpacity",
      value: function SetOpacity(source) {
        var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        return 1 === o ? source : new Color(source).setOpacity(o).toRGBA();
      }
    }, {
      key: "getColorBrightness",
      value: function getColorBrightness(source) {
        var model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hsl";
        var color = source instanceof Color ? source : new Color(source);
        switch (model) {
          case "hsv":
          default:
            return color.getHSVBrightness();
          case "hsl":
            return color.getHSLBrightness();
          case "lum":
            return color.getLuminance();
          case "lum2":
            return color.getLuminance2();
          case "lum3":
            return color.getLuminance3();
        }
      }
    }, {
      key: "parseColorString",
      value: function parseColorString(value) {
        if (isValid$1(DEFAULT_COLORS_OPACITY[value])) return rgba(DEFAULT_COLORS_OPACITY[value]);
        if (isValid$1(DEFAULT_COLORS[value])) return rgb(DEFAULT_COLORS[value]);
        var formatValue = "".concat(value).trim().toLowerCase(),
          isHex = REG_HEX.exec(formatValue);
        if (isHex) {
          var _hex = parseInt(isHex[1], 16),
            hexLength = isHex[1].length;
          return 3 === hexLength ? new RGB((_hex >> 8 & 15) + ((_hex >> 8 & 15) << 4), (_hex >> 4 & 15) + ((_hex >> 4 & 15) << 4), (15 & _hex) + ((15 & _hex) << 4), 1) : 6 === hexLength ? rgb(_hex) : 8 === hexLength ? new RGB(_hex >> 24 & 255, _hex >> 16 & 255, _hex >> 8 & 255, (255 & _hex) / 255) : void 0;
        }
        if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
          var aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
          return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
        }
        if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
          var _aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","),
            _rgb = hslToRgb(parseInt(_aColor[0], 10), parseInt(_aColor[1], 10), parseInt(_aColor[2], 10));
          return new RGB(_rgb.r, _rgb.g, _rgb.b, parseFloat(_aColor[3]));
        }
      }
    }]);
    return Color;
  }();
  var RGB = /*#__PURE__*/function () {
    function RGB(r, g, b, opacity) {
      _classCallCheck(this, RGB);
      this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), isValid$1(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
    }
    _createClass(RGB, [{
      key: "formatHex",
      value: function formatHex() {
        return "#".concat(hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity)));
      }
    }, {
      key: "formatRgb",
      value: function formatRgb() {
        var opacity = this.opacity;
        return "".concat(1 === opacity ? "rgb(" : "rgba(").concat(this.r, ",").concat(this.g, ",").concat(this.b).concat(1 === opacity ? ")" : ",".concat(opacity, ")"));
      }
    }, {
      key: "formatHsl",
      value: function formatHsl() {
        var opacity = this.opacity,
          _rgbToHsl = rgbToHsl(this.r, this.g, this.b),
          h = _rgbToHsl.h,
          s = _rgbToHsl.s,
          l = _rgbToHsl.l;
        return "".concat(1 === opacity ? "hsl(" : "hsla(").concat(h, ",").concat(s, "%,").concat(l, "%").concat(1 === opacity ? ")" : ",".concat(opacity, ")"));
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.formatHex();
      }
    }]);
    return RGB;
  }();

  function sub(out, v1, v2) {
    out[0] = v1[0] - v2[0], out[1] = v1[1] - v2[1];
  }
  var x11, x12, y11, y12, x21, x22, y21, y22;
  function isIntersect(left1, right1, left2, right2) {
    var _temp,
      min1 = left1[0],
      max1 = right1[0],
      min2 = left2[0],
      max2 = right2[0];
    return max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), max2 < min2 && (_temp = max2, max2 = min2, min2 = _temp), !(max1 < min2 || max2 < min1) && (min1 = left1[1], max1 = right1[1], min2 = left2[1], max2 = right2[1], max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), max2 < min2 && (_temp = max2, max2 = min2, min2 = _temp), !(max1 < min2 || max2 < min1));
  }
  function getIntersectPoint(left1, right1, left2, right2) {
    if (!isIntersect(left1, right1, left2, right2)) return !1;
    var dir1 = [0, 0],
      dir2 = [0, 0],
      tempVec = [0, 0];
    if (sub(dir1, right1, left1), sub(dir2, right2, left2), fuzzyEqualVec(dir1, dir2)) return !0;
    sub(tempVec, left2, left1);
    var t = crossProduct$1(tempVec, dir2) / crossProduct$1(dir1, dir2);
    return t >= 0 && t <= 1 && [left1[0] + dir1[0] * t, left1[1] + dir1[1] * t];
  }
  function getRectIntersect(bbox1, bbox2, format) {
    var _ref, _ref2, _ref3, _ref4;
    return null === bbox1 ? bbox2 : null === bbox2 ? bbox1 : (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, format && (x11 > x12 && (_ref = [x12, x11], x11 = _ref[0], x12 = _ref[1], _ref), y11 > y12 && (_ref2 = [y12, y11], y11 = _ref2[0], y12 = _ref2[1], _ref2), x21 > x22 && (_ref3 = [x22, x21], x21 = _ref3[0], x22 = _ref3[1], _ref3), y21 > y22 && (_ref4 = [y22, y21], y21 = _ref4[0], y22 = _ref4[1], _ref4)), x11 >= x22 || x12 <= x21 || y11 >= y22 || y12 <= y21 ? {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    } : {
      x1: Math.max(x11, x21),
      y1: Math.max(y11, y21),
      x2: Math.min(x12, x22),
      y2: Math.min(y12, y22)
    });
  }
  var InnerBBox;
  !function (InnerBBox) {
    InnerBBox[InnerBBox.NONE = 0] = "NONE", InnerBBox[InnerBBox.BBOX1 = 1] = "BBOX1", InnerBBox[InnerBBox.BBOX2 = 2] = "BBOX2";
  }(InnerBBox || (InnerBBox = {}));
  function isRectIntersect(bbox1, bbox2, format) {
    var _ref9, _ref10, _ref11, _ref12;
    return !bbox1 || !bbox2 || (format ? (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, x11 > x12 && (_ref9 = [x12, x11], x11 = _ref9[0], x12 = _ref9[1], _ref9), y11 > y12 && (_ref10 = [y12, y11], y11 = _ref10[0], y12 = _ref10[1], _ref10), x21 > x22 && (_ref11 = [x22, x21], x21 = _ref11[0], x22 = _ref11[1], _ref11), y21 > y22 && (_ref12 = [y22, y21], y21 = _ref12[0], y22 = _ref12[1], _ref12), !(x11 > x22 || x12 < x21 || y11 > y22 || y12 < y21)) : !(bbox1.x1 > bbox2.x2 || bbox1.x2 < bbox2.x1 || bbox1.y1 > bbox2.y2 || bbox1.y2 < bbox2.y1));
  }

  var eastAsianCharacterInfo = function eastAsianCharacterInfo(character) {
    var x = character.charCodeAt(0),
      y = 2 === character.length ? character.charCodeAt(1) : 0,
      codePoint = x;
    return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
  };

  function getContextFont$1(text) {
    var defaultAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _text$fontStyle = text.fontStyle,
      fontStyle = _text$fontStyle === void 0 ? defaultAttr.fontStyle : _text$fontStyle,
      _text$fontVariant = text.fontVariant,
      fontVariant = _text$fontVariant === void 0 ? defaultAttr.fontVariant : _text$fontVariant,
      _text$fontWeight = text.fontWeight,
      fontWeight = _text$fontWeight === void 0 ? defaultAttr.fontWeight : _text$fontWeight,
      _text$fontSize = text.fontSize,
      fontSize = _text$fontSize === void 0 ? defaultAttr.fontSize : _text$fontSize,
      _text$fontFamily = text.fontFamily,
      fontFamily = _text$fontFamily === void 0 ? defaultAttr.fontFamily : _text$fontFamily;
    return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize + "px " + (fontFamily || "sans-serif");
  }

  var TextMeasure = /*#__PURE__*/function () {
    function TextMeasure(option, textSpec) {
      _classCallCheck(this, TextMeasure);
      this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = !1, this._notSupportCanvas = !1, this._notSupportVRender = !1, this._userSpec = {}, this.specialCharSet = "-/: .,@%'\"~", this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid$1(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid$1(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
    }
    _createClass(TextMeasure, [{
      key: "initContext",
      value: function initContext() {
        if (this._notSupportCanvas) return !1;
        if (isNil$1(this._canvas) && (isValid$1(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil$1(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid$1(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil$1(this._context) && isValid$1(this._canvas)) {
          var context = this._canvas.getContext("2d");
          isValid$1(context) && (context.save(), context.font = getContextFont$1(this.textSpec), this._contextSaved = !0, this._context = context);
        }
        return !isNil$1(this._context) || (this._notSupportCanvas = !0, !1);
      }
    }, {
      key: "_initSpec",
      value: function _initSpec() {
        var _a, _b, _c;
        var _this$_option$default = this._option.defaultFontParams,
          defaultFontParams = _this$_option$default === void 0 ? {} : _this$_option$default,
          _this$_userSpec = this._userSpec,
          _this$_userSpec$fontS = _this$_userSpec.fontStyle,
          fontStyle = _this$_userSpec$fontS === void 0 ? defaultFontParams.fontStyle : _this$_userSpec$fontS,
          _this$_userSpec$fontV = _this$_userSpec.fontVariant,
          fontVariant = _this$_userSpec$fontV === void 0 ? defaultFontParams.fontVariant : _this$_userSpec$fontV,
          _this$_userSpec$fontW = _this$_userSpec.fontWeight,
          fontWeight = _this$_userSpec$fontW === void 0 ? null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal" : _this$_userSpec$fontW,
          _this$_userSpec$fontS2 = _this$_userSpec.fontSize,
          fontSize = _this$_userSpec$fontS2 === void 0 ? null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12 : _this$_userSpec$fontS2,
          _this$_userSpec$fontF = _this$_userSpec.fontFamily,
          fontFamily = _this$_userSpec$fontF === void 0 ? null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif" : _this$_userSpec$fontF,
          align = _this$_userSpec.align,
          _this$_userSpec$textA = _this$_userSpec.textAlign,
          textAlign = _this$_userSpec$textA === void 0 ? null != align ? align : "center" : _this$_userSpec$textA,
          baseline = _this$_userSpec.baseline,
          _this$_userSpec$textB = _this$_userSpec.textBaseline,
          textBaseline = _this$_userSpec$textB === void 0 ? null != baseline ? baseline : "middle" : _this$_userSpec$textB,
          ellipsis = _this$_userSpec.ellipsis,
          limit = _this$_userSpec.limit;
        var _this$_userSpec$lineH = this._userSpec.lineHeight,
          lineHeight = _this$_userSpec$lineH === void 0 ? fontSize : _this$_userSpec$lineH;
        if (isString$1(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
          var scale = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
          lineHeight = fontSize * scale;
        }
        return {
          fontStyle: fontStyle,
          fontVariant: fontVariant,
          fontFamily: fontFamily,
          fontSize: fontSize,
          fontWeight: fontWeight,
          textAlign: textAlign,
          textBaseline: textBaseline,
          ellipsis: ellipsis,
          limit: limit,
          lineHeight: lineHeight
        };
      }
    }, {
      key: "measure",
      value: function measure(text, method) {
        switch (method) {
          case "vrender":
          case "canopus":
            return this.fullMeasure(text);
          case "canvas":
            return this.measureWithNaiveCanvas(text);
          case "simple":
            return this.quickMeasureWithoutCanvas(text);
          default:
            return this.quickMeasure(text);
        }
      }
    }, {
      key: "fullMeasure",
      value: function fullMeasure(text) {
        if (isNil$1(text)) return {
          width: 0,
          height: 0
        };
        if (isNil$1(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text);
        var _this$textSpec = this.textSpec,
          fontFamily = _this$textSpec.fontFamily,
          fontSize = _this$textSpec.fontSize,
          fontWeight = _this$textSpec.fontWeight,
          textAlign = _this$textSpec.textAlign,
          textBaseline = _this$textSpec.textBaseline,
          ellipsis = _this$textSpec.ellipsis,
          limit = _this$textSpec.limit,
          lineHeight = _this$textSpec.lineHeight;
        var size;
        try {
          var bounds = this._option.getTextBounds({
            text: text,
            fontFamily: fontFamily,
            fontSize: fontSize,
            fontWeight: fontWeight,
            textAlign: textAlign,
            textBaseline: textBaseline,
            ellipsis: !!ellipsis,
            maxLineWidth: limit || 1 / 0,
            lineHeight: lineHeight
          });
          size = {
            width: bounds.width(),
            height: bounds.height()
          };
        } catch (e) {
          this._notSupportVRender = !0, size = this.measureWithNaiveCanvas(text);
        }
        return size;
      }
    }, {
      key: "measureWithNaiveCanvas",
      value: function measureWithNaiveCanvas(text) {
        return this._measureReduce(text, this._measureWithNaiveCanvas.bind(this));
      }
    }, {
      key: "_measureWithNaiveCanvas",
      value: function _measureWithNaiveCanvas(text) {
        var _a;
        if (!this.initContext()) return this._quickMeasureWithoutCanvas(text);
        var metrics = this._context.measureText(text),
          _this$textSpec2 = this.textSpec,
          fontSize = _this$textSpec2.fontSize,
          lineHeight = _this$textSpec2.lineHeight;
        return {
          width: metrics.width,
          height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize
        };
      }
    }, {
      key: "quickMeasure",
      value: function quickMeasure(text) {
        return this._measureReduce(text, this._quickMeasure.bind(this));
      }
    }, {
      key: "_quickMeasure",
      value: function _quickMeasure(text) {
        var totalSize = {
          width: 0,
          height: 0
        };
        for (var i = 0; i < text.length; i++) {
          var _char = text[i];
          var size = this._measureSpecialChar(_char);
          isNil$1(size) && TextMeasure.NUMBERS_CHAR_SET.includes(_char) && (size = this._measureNumberChar()), isNil$1(size) && ["F", "W"].includes(eastAsianCharacterInfo(_char)) && (size = this._measureFullSizeChar()), isNil$1(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height);
        }
        return totalSize;
      }
    }, {
      key: "quickMeasureWithoutCanvas",
      value: function quickMeasureWithoutCanvas(text) {
        return this._measureReduce(text, this._quickMeasureWithoutCanvas.bind(this));
      }
    }, {
      key: "_quickMeasureWithoutCanvas",
      value: function _quickMeasureWithoutCanvas(text) {
        var _a;
        var totalSize = {
            width: 0,
            height: 0
          },
          _this$textSpec3 = this.textSpec,
          fontSize = _this$textSpec3.fontSize,
          lineHeight = _this$textSpec3.lineHeight;
        for (var i = 0; i < text.length; i++) {
          var _char2 = text[i],
            size = ["F", "W"].includes(eastAsianCharacterInfo(_char2)) ? 1 : .53;
          totalSize.width += size * fontSize;
        }
        return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
      }
    }, {
      key: "_measureReduce",
      value: function _measureReduce(text, processor) {
        var _a;
        var _this$textSpec4 = this.textSpec,
          fontSize = _this$textSpec4.fontSize,
          lineHeight = _this$textSpec4.lineHeight,
          defaultResult = {
            width: 0,
            height: 0
          };
        if (isNil$1(text)) return defaultResult;
        if (isArray$1(text)) {
          var textArr = text.filter(isValid$1).map(function (s) {
            return s.toString();
          });
          return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
            width: textArr.reduce(function (maxWidth, cur) {
              return Math.max(maxWidth, processor(cur).width);
            }, 0),
            height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
          };
        }
        return processor(text.toString());
      }
    }, {
      key: "_measureNumberChar",
      value: function _measureNumberChar() {
        if (isNil$1(this._numberCharSize)) {
          var numberBounds = this._standardMethod(TextMeasure.NUMBERS_CHAR_SET);
          this._numberCharSize = {
            width: numberBounds.width / TextMeasure.NUMBERS_CHAR_SET.length,
            height: numberBounds.height
          };
        }
        return this._numberCharSize;
      }
    }, {
      key: "_measureFullSizeChar",
      value: function _measureFullSizeChar() {
        return isNil$1(this._fullCharSize) && (this._fullCharSize = this._standardMethod(TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
      }
    }, {
      key: "_measureLetterChar",
      value: function _measureLetterChar() {
        if (isNil$1(this._letterCharSize)) {
          var alphabetBounds = this._standardMethod(TextMeasure.ALPHABET_CHAR_SET);
          this._letterCharSize = {
            width: alphabetBounds.width / TextMeasure.ALPHABET_CHAR_SET.length,
            height: alphabetBounds.height
          };
        }
        return this._letterCharSize;
      }
    }, {
      key: "_measureSpecialChar",
      value: function _measureSpecialChar(_char3) {
        return isValid$1(this._specialCharSizeMap[_char3]) ? this._specialCharSizeMap[_char3] : this.specialCharSet.includes(_char3) ? (this._specialCharSizeMap[_char3] = this._standardMethod(_char3), this._specialCharSizeMap[_char3]) : null;
      }
    }, {
      key: "release",
      value: function release() {
        isValid$1(this._canvas) && (this._canvas = null), isValid$1(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = !1), this._context = null);
      }
    }]);
    return TextMeasure;
  }();
  TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure.NUMBERS_CHAR_SET = "0123456789", TextMeasure.FULL_SIZE_CHAR = "字";

  var hasConsole = "undefined" != typeof console;
  function log(method, level, input) {
    var args = [level].concat([].slice.call(input));
    hasConsole && console[method].apply(console, args);
  }
  var LoggerLevel;
  !function (LoggerLevel) {
    LoggerLevel[LoggerLevel.None = 0] = "None", LoggerLevel[LoggerLevel.Error = 1] = "Error", LoggerLevel[LoggerLevel.Warn = 2] = "Warn", LoggerLevel[LoggerLevel.Info = 3] = "Info", LoggerLevel[LoggerLevel.Debug = 4] = "Debug";
  }(LoggerLevel || (LoggerLevel = {}));
  var Logger = /*#__PURE__*/function () {
    function Logger() {
      var level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LoggerLevel.None;
      var method = arguments.length > 1 ? arguments[1] : undefined;
      _classCallCheck(this, Logger);
      this._onErrorHandler = [], this._level = level, this._method = method;
    }
    _createClass(Logger, [{
      key: "addErrorHandler",
      value: function addErrorHandler(handler) {
        this._onErrorHandler.find(function (h) {
          return h === handler;
        }) || this._onErrorHandler.push(handler);
      }
    }, {
      key: "removeErrorHandler",
      value: function removeErrorHandler(handler) {
        var index = this._onErrorHandler.findIndex(function (h) {
          return h === handler;
        });
        index < 0 || this._onErrorHandler.splice(index, 1);
      }
    }, {
      key: "callErrorHandler",
      value: function callErrorHandler() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        this._onErrorHandler.forEach(function (h) {
          return h.apply(void 0, args);
        });
      }
    }, {
      key: "canLogInfo",
      value: function canLogInfo() {
        return this._level >= LoggerLevel.Info;
      }
    }, {
      key: "canLogDebug",
      value: function canLogDebug() {
        return this._level >= LoggerLevel.Debug;
      }
    }, {
      key: "canLogError",
      value: function canLogError() {
        return this._level >= LoggerLevel.Error;
      }
    }, {
      key: "canLogWarn",
      value: function canLogWarn() {
        return this._level >= LoggerLevel.Warn;
      }
    }, {
      key: "level",
      value: function level(levelValue) {
        return arguments.length ? (this._level = +levelValue, this) : this._level;
      }
    }, {
      key: "error",
      value: function error() {
        var _a;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return this._level >= LoggerLevel.Error && (this._onErrorHandler.length ? this.callErrorHandler.apply(this, args) : log(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
      }
    }, {
      key: "warn",
      value: function warn() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", args), this;
      }
    }, {
      key: "info",
      value: function info() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", args), this;
      }
    }, {
      key: "debug",
      value: function debug() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        return this._level >= LoggerLevel.Debug && log(this._method || "log", "DEBUG", args), this;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(level, method) {
        return Logger._instance && isNumber$1(level) ? Logger._instance.level(level) : Logger._instance || (Logger._instance = new Logger(level, method)), Logger._instance;
      }
    }, {
      key: "setInstance",
      value: function setInstance(logger) {
        return Logger._instance = logger;
      }
    }, {
      key: "setInstanceLevel",
      value: function setInstanceLevel(level) {
        Logger._instance ? Logger._instance.level(level) : Logger._instance = new Logger(level);
      }
    }, {
      key: "clearInstance",
      value: function clearInstance() {
        Logger._instance = null;
      }
    }]);
    return Logger;
  }();
  Logger._instance = null;

  var circleThreshold = tau - 1e-8;
  var BoundsContext = /*#__PURE__*/function () {
    function BoundsContext(bounds) {
      _classCallCheck(this, BoundsContext);
      this.init(bounds);
    }
    _createClass(BoundsContext, [{
      key: "init",
      value: function init(bounds) {
        this.bounds = bounds;
      }
    }, {
      key: "arc",
      value: function arc(cx, cy, r, sa, ea, ccw) {
        if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r, cy - r), void this.bounds.add(cx + r, cy + r);
        var s,
          i,
          x,
          y,
          xmin = 1 / 0,
          xmax = -1 / 0,
          ymin = 1 / 0,
          ymax = -1 / 0;
        function update(a) {
          x = r * Math.cos(a), y = r * Math.sin(a), x < xmin && (xmin = x), x > xmax && (xmax = x), y < ymin && (ymin = y), y > ymax && (ymax = y);
        }
        if (update(sa), update(ea), ea !== sa) if ((sa %= tau) < 0 && (sa += tau), (ea %= tau) < 0 && (ea += tau), ea < sa && (ccw = !ccw, s = sa, sa = ea, ea = s), ccw) for (ea -= tau, s = sa - sa % halfPi$1, i = 0; i < 4 && s > ea; ++i, s -= halfPi$1) update(s);else for (s = sa - sa % halfPi$1 + halfPi$1, i = 0; i < 4 && s < ea; ++i, s += halfPi$1) update(s);
        this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
      }
    }, {
      key: "arcTo",
      value: function arcTo(x1, y1, x2, y2, radius) {
        throw new Error("不支持arcTo");
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);
      }
    }, {
      key: "closePath",
      value: function closePath() {}
    }, {
      key: "ellipse",
      value: function ellipse() {
        throw new Error("不支持ellipse");
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y) {
        this.bounds.add(x, y);
      }
    }, {
      key: "moveTo",
      value: function moveTo(x, y) {
        this.bounds.add(x, y);
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(cpx, cpy, x, y) {
        this.bounds.add(cpx, cpy), this.bounds.add(x, y);
      }
    }, {
      key: "rect",
      value: function rect(x, y, w, h) {
        this.bounds.add(x, y), this.bounds.add(x + w, y + h);
      }
    }, {
      key: "clear",
      value: function clear() {
        this.bounds.clear();
      }
    }, {
      key: "release",
      value: function release() {}
    }]);
    return BoundsContext;
  }();

  var CurvePath = /*#__PURE__*/function () {
    function CurvePath() {
      _classCallCheck(this, CurvePath);
      this.curves = [], this.bounds = new AABBBounds();
    }
    _createClass(CurvePath, [{
      key: "getCurveLengths",
      value: function getCurveLengths() {
        return this.curves.map(function (curve) {
          return curve.getLength();
        });
      }
    }, {
      key: "getPointAt",
      value: function getPointAt(t) {
        return {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "getLength",
      value: function getLength() {
        return 0;
      }
    }, {
      key: "getBounds",
      value: function getBounds() {
        return this.bounds;
      }
    }]);
    return CurvePath;
  }();

  var rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi,
    commandLengths = {
      m: 2,
      l: 2,
      h: 1,
      v: 1,
      c: 6,
      s: 4,
      q: 4,
      t: 2,
      a: 7,
      M: 2,
      L: 2,
      H: 1,
      V: 1,
      C: 6,
      S: 4,
      Q: 4,
      T: 2,
      A: 7
    };
  var enumCommandMap = {
    A: 0,
    AT: 1,
    C: 2,
    Z: 3,
    E: 4,
    L: 5,
    M: 6,
    Q: 7,
    R: 8
  };
  var currPath, coordsStr, commandChar, coordStr, coordNumber, standardCommandLen;
  function parseSvgPath(str) {
    if (!str) return [];
    var paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
    if (null === paths) return [];
    var currCommandData, coordsStrArr;
    var result = [];
    for (var i = 0, len = paths.length; i < len; i++) if (currPath = paths[i], coordsStr = currPath.slice(1), commandChar = currPath[0], currCommandData = [commandChar], coordsStrArr = coordsStr.match(rePathCommand), null !== coordsStrArr) {
      for (var _i = 0, _len = coordsStrArr.length; _i < _len; _i++) coordStr = coordsStrArr[_i], coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
      if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
        var subCommand = void 0;
        for (var _i2 = 1, _len2 = currCommandData.length; _i2 < _len2; _i2 += standardCommandLen) {
          subCommand = [commandChar];
          for (var j = _i2, subLen = _i2 + standardCommandLen; j < subLen; j++) subCommand.push(currCommandData[j]);
          result.push(subCommand);
        }
      } else result.push(currCommandData);
    } else result.push(currCommandData);
    return result;
  }

  exports.UpdateTag = void 0;
  !function (UpdateTag) {
    UpdateTag[UpdateTag.NONE = 0] = "NONE", UpdateTag[UpdateTag.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", UpdateTag[UpdateTag.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag[UpdateTag.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", UpdateTag[UpdateTag.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag[UpdateTag.INIT = 179] = "INIT", UpdateTag[UpdateTag.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag[UpdateTag.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", UpdateTag[UpdateTag.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", UpdateTag[UpdateTag.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LAYOUT = 128] = "UPDATE_LAYOUT", UpdateTag[UpdateTag.CLEAR_LAYOUT = 127] = "CLEAR_LAYOUT";
  }(exports.UpdateTag || (exports.UpdateTag = {}));
  exports.IContainPointMode = void 0;
  !function (IContainPointMode) {
    IContainPointMode[IContainPointMode.GLOBAL = 1] = "GLOBAL", IContainPointMode[IContainPointMode.LOCAL = 16] = "LOCAL", IContainPointMode[IContainPointMode.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode[IContainPointMode.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
  }(exports.IContainPointMode || (exports.IContainPointMode = {}));
  exports.AttributeUpdateType = void 0;
  !function (AttributeUpdateType) {
    AttributeUpdateType[AttributeUpdateType.INIT = 0] = "INIT", AttributeUpdateType[AttributeUpdateType.DEFAULT = 1] = "DEFAULT", AttributeUpdateType[AttributeUpdateType.STATE = 2] = "STATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_BIND = 10] = "ANIMATE_BIND", AttributeUpdateType[AttributeUpdateType.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType[AttributeUpdateType.ANIMATE_START = 12] = "ANIMATE_START", AttributeUpdateType[AttributeUpdateType.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType[AttributeUpdateType.TRANSLATE = 20] = "TRANSLATE", AttributeUpdateType[AttributeUpdateType.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType[AttributeUpdateType.SCALE = 22] = "SCALE", AttributeUpdateType[AttributeUpdateType.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType[AttributeUpdateType.ROTATE = 24] = "ROTATE", AttributeUpdateType[AttributeUpdateType.ROTATE_TO = 25] = "ROTATE_TO";
  }(exports.AttributeUpdateType || (exports.AttributeUpdateType = {}));
  exports.AnimateStatus = void 0;
  !function (AnimateStatus) {
    AnimateStatus[AnimateStatus.INITIAL = 0] = "INITIAL", AnimateStatus[AnimateStatus.RUNNING = 1] = "RUNNING", AnimateStatus[AnimateStatus.PAUSED = 2] = "PAUSED", AnimateStatus[AnimateStatus.END = 3] = "END";
  }(exports.AnimateStatus || (exports.AnimateStatus = {}));
  exports.AnimateMode = void 0;
  !function (AnimateMode) {
    AnimateMode[AnimateMode.NORMAL = 0] = "NORMAL", AnimateMode[AnimateMode.SET_ATTR_IMMEDIATELY = 1] = "SET_ATTR_IMMEDIATELY";
  }(exports.AnimateMode || (exports.AnimateMode = {}));
  exports.AnimateStepType = void 0;
  !function (AnimateStepType) {
    AnimateStepType.wait = "wait", AnimateStepType.from = "from", AnimateStepType.to = "to", AnimateStepType.customAnimate = "customAnimate";
  }(exports.AnimateStepType || (exports.AnimateStepType = {}));
  exports.Direction = void 0;
  !function (Direction) {
    Direction[Direction.ROW = 1] = "ROW", Direction[Direction.COLUMN = 2] = "COLUMN";
  }(exports.Direction || (exports.Direction = {}));
  exports.CurveTypeEnum = void 0;
  !function (CurveTypeEnum) {
    CurveTypeEnum[CurveTypeEnum.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum[CurveTypeEnum.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", CurveTypeEnum[CurveTypeEnum.ArcCurve = 2] = "ArcCurve", CurveTypeEnum[CurveTypeEnum.LineCurve = 3] = "LineCurve", CurveTypeEnum[CurveTypeEnum.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum[CurveTypeEnum.MoveCurve = 5] = "MoveCurve";
  }(exports.CurveTypeEnum || (exports.CurveTypeEnum = {}));
  exports.BaseRenderContributionTime = void 0;
  !function (BaseRenderContributionTime) {
    BaseRenderContributionTime[BaseRenderContributionTime.beforeFillStroke = 0] = "beforeFillStroke", BaseRenderContributionTime[BaseRenderContributionTime.afterFillStroke = 1] = "afterFillStroke";
  }(exports.BaseRenderContributionTime || (exports.BaseRenderContributionTime = {}));

  function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
    var th = degreeToRadian(rotateX),
      sin_th = Math.sin(th),
      cos_th = Math.cos(th),
      px = cos_th * (ox - x) * .5 + sin_th * (oy - y) * .5,
      py = cos_th * (oy - y) * .5 - sin_th * (ox - x) * .5;
    var pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
    pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
    var a00 = cos_th / rx,
      a01 = sin_th / rx,
      a10 = -sin_th / ry,
      a11 = cos_th / ry,
      x0 = a00 * ox + a01 * oy,
      y0 = a10 * ox + a11 * oy,
      x1 = a00 * x + a01 * y,
      y1 = a10 * x + a11 * y;
    var sfactor_sq = 1 / ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) - .25;
    sfactor_sq < 0 && (sfactor_sq = 0);
    var sfactor = Math.sqrt(sfactor_sq);
    sweep === large && (sfactor = -sfactor);
    var xc = .5 * (x0 + x1) - sfactor * (y1 - y0),
      yc = .5 * (y0 + y1) + sfactor * (x1 - x0),
      th0 = Math.atan2(y0 - yc, x0 - xc);
    var th_arc = Math.atan2(y1 - yc, x1 - xc) - th0;
    th_arc < 0 && 1 === sweep ? th_arc += tau : th_arc > 0 && 0 === sweep && (th_arc -= tau);
    var segs = Math.ceil(Math.abs(th_arc / (halfPi$1 + .001))),
      result = [];
    for (var i = 0; i < segs; ++i) {
      var th2 = th0 + i * th_arc / segs,
        th3 = th0 + (i + 1) * th_arc / segs;
      result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
    }
    return result;
  }
  function bezier(params) {
    var cx = params[0],
      cy = params[1],
      th0 = params[2],
      th1 = params[3],
      rx = params[4],
      ry = params[5],
      sin_th = params[6],
      cos_th = params[7],
      a00 = cos_th * rx,
      a01 = -sin_th * ry,
      a10 = sin_th * rx,
      a11 = cos_th * ry,
      cos_th0 = Math.cos(th0),
      sin_th0 = Math.sin(th0),
      cos_th1 = Math.cos(th1),
      sin_th1 = Math.sin(th1),
      th_half = .5 * (th1 - th0),
      sin_th_h2 = Math.sin(.5 * th_half),
      t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half),
      x1 = cx + cos_th0 - t * sin_th0,
      y1 = cy + sin_th0 + t * cos_th0,
      x3 = cx + cos_th1,
      y3 = cy + sin_th1,
      x2 = x3 + t * sin_th1,
      y2 = y3 - t * cos_th1;
    return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
  }
  function drawArc(context, x, y, coords) {
    var seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
    for (var i = 0; i < seg.length; ++i) {
      var bez = bezier(seg[i]);
      context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
    }
  }
  var addArcToBezierPath$1 = function addArcToBezierPath(bezierPath, startAngle, endAngle, cx, cy, rx, ry) {
    var delta = Math.abs(endAngle - startAngle),
      len = 4 * Math.tan(delta / 4) / 3,
      dir = endAngle < startAngle ? -1 : 1,
      c1 = Math.cos(startAngle),
      s1 = Math.sin(startAngle),
      c2 = Math.cos(endAngle),
      s2 = Math.sin(endAngle),
      x1 = c1 * rx + cx,
      y1 = s1 * ry + cy,
      x4 = c2 * rx + cx,
      y4 = s2 * ry + cy,
      hx = rx * len * dir,
      hy = ry * len * dir;
    bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  };

  var commandFuncs = [function (command, context, x, y, sx, sy, z) {
    return context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z);
  }, function (command, context, x, y, sx, sy, z) {
    return context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z);
  }, function (command, context, x, y, sx, sy, z) {
    return context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z);
  }, function (command, context, x, y) {
    return context.closePath();
  }, function (command, context, x, y, sx, sy) {
    return context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]);
  }, function (command, context, x, y, sx, sy, z) {
    return context.lineTo(command[1] * sx + x, command[2] * sy + y, z);
  }, function (command, context, x, y, sx, sy, z) {
    return context.moveTo(command[1] * sx + x, command[2] * sy + y, z);
  }, function (command, context, x, y, sx, sy, z) {
    return context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z);
  }, function (command, context, x, y, sx, sy, z) {
    return context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z);
  }];
  function renderCommandList(commandList, context) {
    var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var sx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var sy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var z = arguments.length > 6 ? arguments[6] : undefined;
    for (var i = 0; i < commandList.length; i++) {
      var command = commandList[i];
      commandFuncs[command[0]](command, context, x, y, sx, sy, z);
    }
  }

  var Curve = /*#__PURE__*/function () {
    function Curve() {
      _classCallCheck(this, Curve);
    }
    _createClass(Curve, [{
      key: "getLength",
      value: function getLength(direction) {
        return null != direction ? this.calcProjLength(direction) : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
      }
    }]);
    return Curve;
  }();

  function snapLength(xArr, yArr) {
    var totalLength = 0;
    var count = xArr.length;
    for (var i = 0; i < count; i++) {
      var x = xArr[i],
        y = yArr[i],
        nextX = xArr[(i + 1) % count],
        nextY = yArr[(i + 1) % count];
      totalLength += PointService.distanceNN(x, y, nextX, nextY);
    }
    return totalLength / 2;
  }
  function cubicLength(p0, p1, p2, p3, iterationCount) {
    return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
  }
  function cubicCalc(p0, p1, p2, p3, t) {
    var one = 1 - t;
    return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
  }
  function cubicPointAt(p0, p1, p2, p3, t) {
    var x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t),
      y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
    return new Point(x, y);
  }

  function divideCubic(curve, t) {
    var p0 = curve.p0,
      p1 = curve.p1,
      p2 = curve.p2,
      p3 = curve.p3,
      pt = cubicPointAt(p0, p1, p2, p3, t),
      c1 = PointService.pointAtPP(p0, p1, t),
      c2 = PointService.pointAtPP(p1, p2, t),
      c3 = PointService.pointAtPP(p2, p3, t),
      c12 = PointService.pointAtPP(c1, c2, t),
      c23 = PointService.pointAtPP(c2, c3, t);
    return [new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3)];
  }
  var CubicBezierCurve = /*#__PURE__*/function (_Curve) {
    _inherits(CubicBezierCurve, _Curve);
    var _super = _createSuper(CubicBezierCurve);
    function CubicBezierCurve(p0, p1, p2, p3) {
      var _this;
      _classCallCheck(this, CubicBezierCurve);
      _this = _super.call(this), _this.type = exports.CurveTypeEnum.CubicBezierCurve, _this.p0 = p0, _this.p1 = p1, _this.p2 = p2, _this.p3 = p3;
      return _this;
    }
    _createClass(CubicBezierCurve, [{
      key: "_validPoint",
      value: function _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
      }
    }, {
      key: "getPointAt",
      value: function getPointAt(t) {
        if (!1 !== this.defined) return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
        throw new Error("defined为false的点不能getPointAt");
      }
    }, {
      key: "calcLength",
      value: function calcLength() {
        return this._validPoint() ? cubicLength(this.p0, this.p1, this.p2, this.p3) : 60;
      }
    }, {
      key: "calcProjLength",
      value: function calcProjLength(direction) {
        return direction === exports.Direction.ROW ? abs(this.p0.x - this.p3.x) : direction === exports.Direction.COLUMN ? abs(this.p0.y - this.p3.y) : 0;
      }
    }, {
      key: "getAngleAt",
      value: function getAngleAt(t) {
        var minT = max(t - .01, 0),
          maxT = min(t + .01, 1),
          minP = this.getPointAt(minT),
          maxP = this.getPointAt(maxT);
        return atan2(maxP.y - minP.y, maxP.x - minP.x);
      }
    }]);
    return CubicBezierCurve;
  }(Curve);

  function divideLinear(curve, t) {
    var p0 = curve.p0,
      p1 = curve.p1,
      c1 = PointService.pointAtPP(p0, p1, t);
    return [new LineCurve(p0, c1), new LineCurve(c1, p1)];
  }
  var LineCurve = /*#__PURE__*/function (_Curve) {
    _inherits(LineCurve, _Curve);
    var _super = _createSuper(LineCurve);
    function LineCurve(p0, p1) {
      var _this;
      _classCallCheck(this, LineCurve);
      _this = _super.call(this), _this.type = exports.CurveTypeEnum.LineCurve, _this.p0 = p0, _this.p1 = p1;
      return _this;
    }
    _createClass(LineCurve, [{
      key: "getPointAt",
      value: function getPointAt(t) {
        if (!1 !== this.defined) return PointService.pointAtPP(this.p0, this.p1, t);
        throw new Error("defined为false的点不能getPointAt");
      }
    }, {
      key: "getAngleAt",
      value: function getAngleAt(t) {
        return null == this.angle && (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
      }
    }, {
      key: "_validPoint",
      value: function _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
      }
    }, {
      key: "calcLength",
      value: function calcLength() {
        return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
      }
    }, {
      key: "calcProjLength",
      value: function calcProjLength(direction) {
        return direction === exports.Direction.ROW ? abs(this.p0.x - this.p1.x) : direction === exports.Direction.COLUMN ? abs(this.p0.y - this.p1.y) : 0;
      }
    }]);
    return LineCurve;
  }(Curve);

  var SegContext = /*#__PURE__*/function () {
    function SegContext(curveType, direction) {
      _classCallCheck(this, SegContext);
      this.init(curveType, direction);
    }
    _createClass(SegContext, [{
      key: "endX",
      get: function get() {
        return this._lastX;
      }
    }, {
      key: "endY",
      get: function get() {
        return this._lastY;
      }
    }, {
      key: "init",
      value: function init(curveType, direction) {
        this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, this.direction = direction, this.curves = [];
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
        var curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
        curve.originP1 = this._lastOriginP, curve.originP2 = p, curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
      }
    }, {
      key: "closePath",
      value: function closePath() {
        if (this.curves.length < 2) return;
        var lastCurve = this.curves[this.curves.length - 1];
        this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
      }
    }, {
      key: "ellipse",
      value: function ellipse() {
        throw new Error("SegContext不支持调用ellipse");
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y, defined, p) {
        var curve = this.addLinearCurve(x, y, defined, this._lastOriginP, p);
        this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
      }
    }, {
      key: "moveTo",
      value: function moveTo(x, y, p) {
        return this._lastX = this._startX = x, this._lastY = this._startY = y, this._lastOriginP = p, this._startOriginP = p, this;
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(cpx, cpy, x, y) {
        throw new Error("SegContext不支持调用quadraticCurveTo");
      }
    }, {
      key: "clear",
      value: function clear() {
        this.curves = [], this.length = NaN;
      }
    }, {
      key: "tryUpdateLength",
      value: function tryUpdateLength(direction) {
        return this.getLength(direction);
      }
    }, {
      key: "addLinearCurve",
      value: function addLinearCurve(x, y, defined, p1, p2) {
        var curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
        return curve.originP1 = p1, curve.originP2 = p2, curve.defined = defined, curve;
      }
    }, {
      key: "getPointAt",
      value: function getPointAt(t) {
        throw new Error("暂未实现");
      }
    }, {
      key: "getCurveLengths",
      value: function getCurveLengths() {
        return [];
      }
    }, {
      key: "getLength",
      value: function getLength(direction) {
        var _a, _b;
        if (direction === exports.Direction.COLUMN) {
          if (!this.curves.length) return 0;
          var sc = this.curves[0],
            ec = this.curves[this.curves.length - 1],
            endP = null !== (_a = ec.p3) && void 0 !== _a ? _a : ec.p1;
          return abs(sc.p0.y - endP.y);
        }
        if (direction === exports.Direction.ROW) {
          if (!this.curves.length) return 0;
          var _sc = this.curves[0],
            _ec = this.curves[this.curves.length - 1],
            _endP = null !== (_b = _ec.p3) && void 0 !== _b ? _b : _ec.p1;
          return abs(_sc.p0.x - _endP.x);
        }
        return Number.isFinite(this.length) || (this.length = this.curves.reduce(function (l, c) {
          return l + c.getLength();
        }, 0)), this.length;
      }
    }]);
    return SegContext;
  }();
  var ReflectSegContext = /*#__PURE__*/function (_SegContext) {
    _inherits(ReflectSegContext, _SegContext);
    var _super = _createSuper(ReflectSegContext);
    function ReflectSegContext() {
      _classCallCheck(this, ReflectSegContext);
      return _super.apply(this, arguments);
    }
    _createClass(ReflectSegContext, [{
      key: "bezierCurveTo",
      value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
        return _get(_getPrototypeOf(ReflectSegContext.prototype), "bezierCurveTo", this).call(this, cp1y, cp1x, cp2y, cp2x, y, x, defined, p);
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y, defined, p) {
        return _get(_getPrototypeOf(ReflectSegContext.prototype), "lineTo", this).call(this, y, x, defined, p);
      }
    }, {
      key: "moveTo",
      value: function moveTo(x, y, p) {
        return _get(_getPrototypeOf(ReflectSegContext.prototype), "moveTo", this).call(this, y, x, p);
      }
    }, {
      key: "clear",
      value: function clear() {
        return _get(_getPrototypeOf(ReflectSegContext.prototype), "clear", this).call(this);
      }
    }]);
    return ReflectSegContext;
  }(SegContext);

  function genCurveSegments(path, points) {
    var defined0 = !1;
    for (var i = 0, n = points.length; i <= n; i++) i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), defined0 && path.point(points[i]);
  }
  function genSegContext(curveType, direction, points) {
    var curveDirection = null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? exports.Direction.ROW : exports.Direction.COLUMN;
    return "monotoneY" === curveType ? new ReflectSegContext(curveType, curveDirection) : new SegContext(curveType, curveDirection);
  }

  var Linear = /*#__PURE__*/function () {
    function Linear(context, startPoint) {
      _classCallCheck(this, Linear);
      this.context = context, startPoint && (this.startPoint = startPoint);
    }
    _createClass(Linear, [{
      key: "areaStart",
      value: function areaStart() {
        this._line = 0;
      }
    }, {
      key: "areaEnd",
      value: function areaEnd() {
        this._line = NaN;
      }
    }, {
      key: "lineStart",
      value: function lineStart() {
        this._point = 0, this.startPoint && this.point(this.startPoint);
      }
    }, {
      key: "lineEnd",
      value: function lineEnd() {
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
      }
    }, {
      key: "point",
      value: function point(p) {
        var x = p.x,
          y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
            break;
          case 1:
            this._point = 2;
          default:
            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);
        }
        this._lastDefined = p.defined;
      }
    }, {
      key: "tryUpdateLength",
      value: function tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    }]);
    return Linear;
  }();
  function genLinearSegments(points) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var direction = params.direction,
      startPoint = params.startPoint;
    if (points.length < 2 - Number(!!startPoint)) return null;
    var segContext = genSegContext("linear", direction, points);
    return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
  }
  function genLinearTypeSegments(path, points) {
    return genCurveSegments(path, points);
  }

  function _point$1(curveClass, x, y, defined, p) {
    curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined, curveClass.lastPoint1);
  }
  var Basis = /*#__PURE__*/function () {
    function Basis(context, startPoint) {
      _classCallCheck(this, Basis);
      this.context = context, this.startPoint = startPoint;
    }
    _createClass(Basis, [{
      key: "areaStart",
      value: function areaStart() {
        this._line = 0;
      }
    }, {
      key: "areaEnd",
      value: function areaEnd() {
        this._line = NaN;
      }
    }, {
      key: "lineStart",
      value: function lineStart() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
      }
    }, {
      key: "lineEnd",
      value: function lineEnd() {
        if (2 === this._point) _point$1(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
      }
    }, {
      key: "point",
      value: function point(p) {
        var x = p.x,
          y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
            break;
          case 1:
            this._point = 2;
            break;
          default:
            _point$1(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        }
        this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
      }
    }, {
      key: "tryUpdateLength",
      value: function tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    }]);
    return Basis;
  }();
  function genBasisTypeSegments(path, points) {
    return genCurveSegments(path, points);
  }
  function genBasisSegments(points) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var direction = params.direction,
      startPoint = params.startPoint;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
    var segContext = genSegContext("basis", direction, points);
    return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
  }

  function sign(x) {
    return x < 0 ? -1 : 1;
  }
  function slope3(curveClass, x2, y2) {
    var h0 = curveClass._x1 - curveClass._x0,
      h1 = x2 - curveClass._x1,
      s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)),
      s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
  }
  function slope2(curveClass, t) {
    var h = curveClass._x1 - curveClass._x0;
    return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;
  }
  function _point(curveClass, t0, t1, defined, p) {
    var x0 = curveClass._x0,
      y0 = curveClass._y0,
      x1 = curveClass._x1,
      y1 = curveClass._y1,
      dx = (x1 - x0) / 3;
    curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined, curveClass.lastPoint1);
  }
  var MonotoneX = /*#__PURE__*/function () {
    function MonotoneX(context, startPoint) {
      _classCallCheck(this, MonotoneX);
      this.context = context, this.startPoint = startPoint;
    }
    _createClass(MonotoneX, [{
      key: "areaStart",
      value: function areaStart() {
        this._line = 0;
      }
    }, {
      key: "areaEnd",
      value: function areaEnd() {
        this._line = NaN;
      }
    }, {
      key: "lineStart",
      value: function lineStart() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
      }
    }, {
      key: "lineEnd",
      value: function lineEnd() {
        switch (this._point) {
          case 2:
            this.context.lineTo(this._x1, this._y1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
            break;
          case 3:
            _point(this, this._t0, slope2(this, this._t0), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
        }
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
      }
    }, {
      key: "point",
      value: function point(p) {
        var t1 = NaN;
        var x = p.x,
          y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3, _point(this, slope2(this, t1 = slope3(this, x, y)), t1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
            break;
          default:
            _point(this, this._t0, t1 = slope3(this, x, y), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        }
        this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = !1 !== p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
      }
    }, {
      key: "tryUpdateLength",
      value: function tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    }]);
    return MonotoneX;
  }();
  var MonotoneY = /*#__PURE__*/function (_MonotoneX) {
    _inherits(MonotoneY, _MonotoneX);
    var _super = _createSuper(MonotoneY);
    function MonotoneY(context, startPoint) {
      _classCallCheck(this, MonotoneY);
      return _super.call(this, context, startPoint);
    }
    _createClass(MonotoneY, [{
      key: "point",
      value: function point(p) {
        return _get(_getPrototypeOf(MonotoneY.prototype), "point", this).call(this, {
          y: p.x,
          x: p.y,
          defined: p.defined
        });
      }
    }]);
    return MonotoneY;
  }(MonotoneX);
  function genMonotoneXTypeSegments(path, points) {
    return genCurveSegments(path, points);
  }
  function genMonotoneXSegments(points) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var direction = params.direction,
      startPoint = params.startPoint;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
    var segContext = genSegContext("monotoneX", direction, points);
    return genMonotoneXTypeSegments(new MonotoneX(segContext, startPoint), points), segContext;
  }
  function genMonotoneYTypeSegments(path, points) {
    return genCurveSegments(path, points);
  }
  function genMonotoneYSegments(points) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var direction = params.direction,
      startPoint = params.startPoint;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
    var segContext = genSegContext("monotoneY", direction, points);
    return genMonotoneYTypeSegments(new MonotoneY(segContext, startPoint), points), segContext;
  }

  var Step$1 = /*#__PURE__*/function () {
    function Step(context) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .5;
      var startPoint = arguments.length > 2 ? arguments[2] : undefined;
      _classCallCheck(this, Step);
      this.context = context, this._t = t, this.startPoint = startPoint;
    }
    _createClass(Step, [{
      key: "areaStart",
      value: function areaStart() {
        this._line = 0;
      }
    }, {
      key: "areaEnd",
      value: function areaEnd() {
        this._line = NaN;
      }
    }, {
      key: "lineStart",
      value: function lineStart() {
        this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
      }
    }, {
      key: "lineEnd",
      value: function lineEnd() {
        0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, !1 !== this._lastDefined, this.lastPoint), (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
      }
    }, {
      key: "point",
      value: function point(p) {
        var x = p.x,
          y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
            break;
          case 1:
            this._point = 2;
          default:
            if (this._t <= 0) this.context.lineTo(this._x, y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this.context.lineTo(x1, this._y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x1, y, !1 !== this._lastDefined && !1 !== p.defined, p);
            }
        }
        this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
      }
    }, {
      key: "tryUpdateLength",
      value: function tryUpdateLength() {
        return this.context.tryUpdateLength();
      }
    }]);
    return Step;
  }();
  function genStepSegments(points, t) {
    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var direction = params.direction,
      startPoint = params.startPoint;
    if (points.length < 2 - Number(!!startPoint)) return null;
    var segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? exports.Direction.ROW : exports.Direction.COLUMN);
    return genStepTypeSegments(new Step$1(segContext, t, startPoint), points), segContext;
  }
  function genStepTypeSegments(path, points) {
    return genCurveSegments(path, points);
  }

  var LinearClosed = /*#__PURE__*/function (_Linear) {
    _inherits(LinearClosed, _Linear);
    var _super = _createSuper(LinearClosed);
    function LinearClosed() {
      _classCallCheck(this, LinearClosed);
      return _super.apply(this, arguments);
    }
    _createClass(LinearClosed, [{
      key: "lineEnd",
      value: function lineEnd() {
        this.context.closePath();
      }
    }]);
    return LinearClosed;
  }(Linear);
  function genLinearClosedSegments(points) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var direction = params.direction,
      startPoint = params.startPoint;
    if (points.length < 2 - Number(!!startPoint)) return null;
    var segContext = genSegContext("linear", direction, points);
    return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), segContext;
  }
  function genLinearClosedTypeSegments(path, points) {
    return genCurveSegments(path, points);
  }

  var CurveContext = /*#__PURE__*/function () {
    function CurveContext(path) {
      _classCallCheck(this, CurveContext);
      this.path = path, this._lastX = this._lastY = this._startX = this._startY = 0;
    }
    _createClass(CurveContext, [{
      key: "moveTo",
      value: function moveTo(x, y) {
        return this._lastX = this._startX = x, this._lastY = this._startY = y, this;
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y) {
        var curve = this.addLinearCurve(x, y);
        this.path.curves.push(curve), this._lastX = x, this._lastY = y;
      }
    }, {
      key: "addLinearCurve",
      value: function addLinearCurve(x, y) {
        return new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
        throw new Error("CurveContext不支持调用quadraticCurveTo");
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        var curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
        this.path.curves.push(curve), this._lastX = x, this._lastY = y;
      }
    }, {
      key: "arcTo",
      value: function arcTo(aX1, aY1, aX2, aY2, aRadius) {
        throw new Error("CurveContext不支持调用arcTo");
      }
    }, {
      key: "ellipse",
      value: function ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
        throw new Error("CurveContext不支持调用ellipse");
      }
    }, {
      key: "rect",
      value: function rect(x, y, w, h) {
        throw new Error("CurveContext不支持调用rect");
      }
    }, {
      key: "arc",
      value: function arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        throw new Error("CurveContext不支持调用arc");
      }
    }, {
      key: "closePath",
      value: function closePath() {
        this.path.curves.length < 2 || this.lineTo(this._startX, this._startY);
      }
    }]);
    return CurveContext;
  }();

  function calcLineCache$1(points, curveType, params) {
    switch (curveType) {
      case "linear":
      default:
        return genLinearSegments(points, params);
      case "basis":
        return genBasisSegments(points, params);
      case "monotoneX":
        return genMonotoneXSegments(points, params);
      case "monotoneY":
        return genMonotoneYSegments(points, params);
      case "step":
        return genStepSegments(points, .5, params);
      case "stepBefore":
        return genStepSegments(points, 0, params);
      case "stepAfter":
        return genStepSegments(points, 1, params);
      case "linearClosed":
        return genLinearClosedSegments(points, params);
    }
  }

  var CustomPath2D = /*#__PURE__*/function (_CurvePath) {
    _inherits(CustomPath2D, _CurvePath);
    var _super = _createSuper(CustomPath2D);
    function CustomPath2D(ctx) {
      var _this;
      _classCallCheck(this, CustomPath2D);
      _this = _super.call(this), _this.commandList = [], ctx && (_this._ctx = ctx), _this._boundsContext = new BoundsContext(_this.bounds);
      return _this;
    }
    _createClass(CustomPath2D, [{
      key: "setCtx",
      value: function setCtx(ctx) {
        this._ctx = ctx;
      }
    }, {
      key: "moveTo",
      value: function moveTo(x, y) {
        return this.commandList.push([enumCommandMap.M, x, y]), this._ctx && this._ctx.moveTo(x, y), this;
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y) {
        return this.commandList.push([enumCommandMap.L, x, y]), this._ctx && this._ctx.lineTo(x, y), this;
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
        return this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]), this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        return this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]), this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
      }
    }, {
      key: "arcTo",
      value: function arcTo(aX1, aY1, aX2, aY2, aRadius) {
        return this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]), this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
      }
    }, {
      key: "ellipse",
      value: function ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
        return this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]), this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), this;
      }
    }, {
      key: "rect",
      value: function rect(x, y, w, h) {
        return this.commandList.push([enumCommandMap.R, x, y, w, h]), this._ctx && this._ctx.rect(x, y, w, h), this;
      }
    }, {
      key: "arc",
      value: function arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        return this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]), this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), this;
      }
    }, {
      key: "closePath",
      value: function closePath() {
        return this.commandList.push([enumCommandMap.Z]), this._ctx && this._ctx.closePath(), this;
      }
    }, {
      key: "addCurve",
      value: function addCurve(curve) {
        this.curves.push(curve);
      }
    }, {
      key: "clear",
      value: function clear() {
        this.transformCbList = null, this.commandList.length = 0, this.curves.length = 0;
      }
    }, {
      key: "beginPath",
      value: function beginPath() {
        this.clear();
      }
    }, {
      key: "toString",
      value: function toString() {
        if (!this.toStringCbList) {
          var _list = [];
          _list[enumCommandMap.M] = function (cmd) {
            return "M".concat(cmd[1], " ").concat(cmd[2]);
          }, _list[enumCommandMap.L] = function (cmd) {
            return "L".concat(cmd[1], " ").concat(cmd[2]);
          }, _list[enumCommandMap.Q] = function (cmd) {
            return "Q".concat(cmd[1], " ").concat(cmd[2], " ").concat(cmd[3], " ").concat(cmd[4]);
          }, _list[enumCommandMap.C] = function (cmd) {
            return "C".concat(cmd[1], " ").concat(cmd[2], " ").concat(cmd[3], " ").concat(cmd[4], " ").concat(cmd[5], " ").concat(cmd[6]);
          }, _list[enumCommandMap.A] = function (cmd) {
            var bezierPathList = [];
            addArcToBezierPath$1(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);
            var path = "";
            for (var i = 0; i < bezierPathList.length; i += 6) path += "C".concat(bezierPathList[i], " ").concat(bezierPathList[i + 1], " ").concat(bezierPathList[i + 2], " ").concat(bezierPathList[i + 3], " ").concat(bezierPathList[i + 4], " ").concat(bezierPathList[i + 5]);
            return path;
          }, _list[enumCommandMap.R] = function (cmd) {
            return "M".concat(cmd[1], " ").concat(cmd[2], " h").concat(cmd[3], " v").concat(cmd[4], " H").concat(cmd[1], "Z");
          }, _list[enumCommandMap.Z] = function (cmd) {
            return "Z";
          }, this.toStringCbList = _list;
        }
        var list = this.toStringCbList;
        var path = "";
        return this.commandList.forEach(function (c) {
          path += list[c[0]](c);
        }), path;
      }
    }, {
      key: "fromString",
      value: function fromString(str, x, y, sX, sY) {
        this.clear();
        var commandStrList = parseSvgPath(str);
        return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), this;
      }
    }, {
      key: "fromLine",
      value: function fromLine(line) {
        var _line$attribute = line.attribute,
          points = _line$attribute.points,
          curveType = _line$attribute.curveType,
          clipRangeByDimension = _line$attribute.clipRangeByDimension;
        if (!points) return;
        var cache = calcLineCache$1(points, curveType);
        "x" === clipRangeByDimension ? this.direction = exports.Direction.ROW : "y" === clipRangeByDimension ? this.direction = exports.Direction.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), this.curves = cache.curves;
      }
    }, {
      key: "fromCustomPath2D",
      value: function fromCustomPath2D(path, x, y, sX, sY) {
        return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), this;
      }
    }, {
      key: "transform",
      value: function transform(x, y, sx, sy) {
        var _this2 = this;
        var commandList = this.commandList;
        if (!this.transformCbList) {
          var list = [];
          list[enumCommandMap.M] = this.moveToTransform, list[enumCommandMap.L] = this.lineToTransform, list[enumCommandMap.Q] = this.quadraticCurveToTransform, list[enumCommandMap.C] = this.bezierCurveToTransform, list[enumCommandMap.AT] = this.arcToTransform, list[enumCommandMap.E] = this.ellipseTransform, list[enumCommandMap.R] = this.rectTransform, list[enumCommandMap.A] = this.arcTransform, list[enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
        }
        commandList.forEach(function (cmd) {
          _this2.transformCbList[cmd[0]](cmd, x, y, sx, sy);
        }), this._updateBounds();
      }
    }, {
      key: "moveToTransform",
      value: function moveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
      }
    }, {
      key: "lineToTransform",
      value: function lineToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
      }
    }, {
      key: "quadraticCurveToTransform",
      value: function quadraticCurveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;
      }
    }, {
      key: "bezierCurveToTransform",
      value: function bezierCurveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;
      }
    }, {
      key: "arcToTransform",
      value: function arcToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * (sx + sy) / 2;
      }
    }, {
      key: "ellipseTransform",
      value: function ellipseTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
      }
    }, {
      key: "rectTransform",
      value: function rectTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
      }
    }, {
      key: "arcTransform",
      value: function arcTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;
      }
    }, {
      key: "closePathTransform",
      value: function closePathTransform() {}
    }, {
      key: "_runCommandStrList",
      value: function _runCommandStrList(commandStrList) {
        var l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var sX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        var sY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
        var current,
          tempX,
          tempY,
          tempControlX,
          tempControlY,
          previous = null,
          x = 0,
          y = 0,
          controlX = 0,
          controlY = 0;
        for (var i = 0, len = commandStrList.length; i < len; ++i) {
          switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale$1(current, sX, sY)), current[0]) {
            case "l":
              x += current[1], y += current[2], this.lineTo(x + l, y + t);
              break;
            case "L":
              x = current[1], y = current[2], this.lineTo(x + l, y + t);
              break;
            case "h":
              x += current[1], this.lineTo(x + l, y + t);
              break;
            case "H":
              x = current[1], this.lineTo(x + l, y + t);
              break;
            case "v":
              y += current[1], this.lineTo(x + l, y + t);
              break;
            case "V":
              y = current[1], this.lineTo(x + l, y + t);
              break;
            case "m":
              x += current[1], y += current[2], this.moveTo(x + l, y + t);
              break;
            case "M":
              x = current[1], y = current[2], this.moveTo(x + l, y + t);
              break;
            case "c":
              tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
              break;
            case "C":
              x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
              break;
            case "s":
              tempX = x + current[3], tempY = y + current[4], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t), controlX = x + current[1], controlY = y + current[2], x = tempX, y = tempY;
              break;
            case "S":
              tempX = current[3], tempY = current[4], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
              break;
            case "q":
              tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
              break;
            case "Q":
              tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
              break;
            case "t":
              tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, controlY = y) : "t" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : "q" === previous[0] && (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = x + current[1], controlY = y + current[2];
              break;
            case "T":
              tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
              break;
            case "a":
              drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]), x += current[6], y += current[7];
              break;
            case "A":
              drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]), x = current[6], y = current[7];
              break;
            case "z":
            case "Z":
              this.closePath();
          }
          previous = current;
        }
      }
    }, {
      key: "_runCommandList",
      value: function _runCommandList(commandList) {
        var l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var sX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        var sY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
        if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY) for (var i = 0, len = commandList.length; i < len; ++i) {
          var current = commandList[i].slice();
          switch (current[0]) {
            case enumCommandMap.L:
              this.lineToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.M:
              this.moveToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.C:
              this.bezierCurveToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.Q:
              this.quadraticCurveToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.A:
              this.arcToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.E:
              this.ellipseTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.R:
              this.rectTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.AT:
              this.arcToTransform(current, l, t, sX, sY);
              break;
            case enumCommandMap.Z:
              this.closePath();
          }
        } else this.commandList = commandList.map(function (entry) {
          return entry.slice();
        });
      }
    }, {
      key: "_updateBounds",
      value: function _updateBounds() {
        this.bounds.clear(), renderCommandList(this.commandList, this._boundsContext);
      }
    }, {
      key: "release",
      value: function release() {
        this.commandList = [], this._boundsContext = null, this._ctx = null;
      }
    }, {
      key: "getLength",
      value: function getLength() {
        if (this.direction === exports.Direction.COLUMN) {
          if (!this.curves.length) return 0;
          var sc = this.curves[0],
            ec = this.curves[this.curves.length - 1];
          return abs(sc.p0.y - ec.p1.y);
        }
        if (this.direction === exports.Direction.ROW) {
          if (!this.curves.length) return 0;
          var _sc = this.curves[0],
            _ec = this.curves[this.curves.length - 1];
          return abs(_sc.p0.x - _ec.p1.x);
        }
        return this.curves.reduce(function (l, c) {
          return l + c.getLength();
        }, 0);
      }
    }, {
      key: "getAttrAt",
      value: function getAttrAt(distance) {
        if (!this.curves) return {
          pos: {
            x: 0,
            y: 0
          },
          angle: 0
        };
        var curve,
          _dis = 0;
        for (var i = 0; i < this.curves.length; i++) {
          curve = this.curves[i];
          var cl = curve.getLength(this.direction);
          if (_dis + cl >= distance) break;
          _dis += cl;
        }
        var t = (distance - _dis) / curve.getLength(this.direction);
        return {
          pos: curve.getPointAt(t),
          angle: curve.getAngleAt(t)
        };
      }
    }]);
    return CustomPath2D;
  }(CurvePath);
  var temp = ["l", 0, 0, 0, 0, 0, 0, 0];
  function scale$1(current, sX, sY) {
    var c = temp[0] = current[0];
    if ("a" === c || "A" === c) temp[1] = sX * current[1], temp[2] = sY * current[2], temp[3] = current[3], temp[4] = current[4], temp[5] = current[5], temp[6] = sX * current[6], temp[7] = sY * current[7];else if ("h" === c || "H" === c) temp[1] = sX * current[1];else if ("v" === c || "V" === c) temp[1] = sY * current[1];else for (var i = 1, n = current.length; i < n; ++i) temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
    return temp;
  }

  var DefaultLayout = {
    alignSelf: "auto"
  };
  var DefaultTransform = {
    x: 0,
    y: 0,
    z: 0,
    dx: 0,
    dy: 0,
    dz: 0,
    scrollX: 0,
    scrollY: 0,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    angle: 0,
    alpha: 0,
    beta: 0,
    scaleCenter: [0, 0],
    anchor: [0, 0],
    anchor3d: [0, 0],
    postMatrix: new Matrix()
  };
  var DefaultFillStyle = {
    fillOpacity: 1,
    fill: !1,
    shadowBlur: 0,
    shadowColor: "black",
    shadowOffsetX: 0,
    shadowOffsetY: 0
  };
  var commonStroke = {
    strokeOpacity: 1,
    lineDash: [],
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: "butt",
    lineJoin: "miter",
    miterLimit: 10,
    strokeBoundsBuffer: 2,
    stroke: !1
  };
  var DefaultStrokeStyle = Object.assign({
    outerBorder: Object.assign(Object.assign({}, commonStroke), {
      distance: 0
    }),
    innerBorder: Object.assign(Object.assign({}, commonStroke), {
      distance: 0
    })
  }, commonStroke);
  var DefaultTextStyle = {
    text: "",
    maxLineWidth: 1 / 0,
    textAlign: "left",
    textBaseline: "alphabetic",
    fontSize: 16,
    fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
    fontWeight: "",
    ellipsis: "…",
    fontVariant: "",
    fontStyle: "",
    lineHeight: void 0,
    underline: 0,
    lineThrough: 0,
    scaleIn3d: !1,
    direction: "horizontal",
    wordBreak: "break-all",
    ignoreBuf: !1,
    verticalMode: 0,
    wrap: !1,
    whiteSpace: "no-wrap",
    heightLimit: 1 / 0,
    lineClamp: 1 / 0,
    suffixPosition: "end",
    underlineDash: [],
    underlineOffset: 0,
    disableAutoClipedPoptip: void 0
  };
  var DefaultPickStyle = {
    pickStrokeBuffer: 0
  };
  var DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({
    opacity: 1,
    background: null,
    backgroundOpacity: 1,
    backgroundCornerRadius: 0,
    texture: null,
    textureColor: "black",
    textureSize: 10,
    texturePadding: 2,
    backgroundMode: "no-repeat",
    backgroundFit: !0,
    blur: 0,
    cursor: null,
    html: null,
    react: null
  }, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
  var DefaultConnectAttribute = {
    connectedType: "none",
    connectedStyle: {},
    connectedX: NaN,
    connectedY: NaN
  };
  var DefaultDebugAttribute = {
    _debug_bounds: !1
  };
  var DefaultAttribute = Object.assign(Object.assign(Object.assign({
    strokeSeg: null,
    pickable: !0,
    childrenPickable: !0,
    fillPickable: !0,
    strokePickable: !0,
    visible: !0,
    zIndex: 0,
    layout: null,
    boundsPadding: 0,
    renderStyle: "default",
    pickMode: "accurate",
    customPickShape: null,
    boundsMode: "accurate",
    keepDirIn3d: !0,
    shadowRootIdx: 1,
    globalZIndex: 1,
    globalCompositeOperation: "",
    overflow: "hidden"
  }, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
  function addAttributeToPrototype(obj, c, keys) {
    keys.forEach(function (key) {
      c.prototype[key] = obj[key];
    });
  }
  function rewriteProto(obj, c) {
    Object.setPrototypeOf(obj, c);
  }
  var DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    startAngle: 0,
    endAngle: pi2,
    innerRadius: 0,
    outerRadius: 1,
    innerPadding: 0,
    outerPadding: 0,
    cornerRadius: 0,
    padRadius: 0,
    padAngle: 0,
    cap: !1,
    forceShowCap: !1
  });
  var DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
    points: [],
    segments: [],
    curveType: "linear",
    clipRange: 1,
    closePath: !1
  });
  var DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    radius: 1,
    startAngle: 0,
    endAngle: pi2
  });
  var DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    width: 0,
    height: 0,
    cornerRadius: 0,
    path: [],
    clip: !1,
    visibleAll: !0,
    display: "relative",
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "flex-start",
    alignItems: "flex-start",
    alignContent: "flex-start"
  });
  var DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    path: "",
    width: 0,
    height: 0,
    cornerRadius: 0,
    clip: !1
  });
  var DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
    points: [],
    segments: [],
    curveType: "linear",
    clipRange: 1,
    clipRangeByDimension: "default",
    closePath: !1
  });
  var DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    path: new CustomPath2D(),
    customPath: function customPath() {
      Logger.getInstance().warn("空函数");
    }
  });
  var DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    points: [],
    cornerRadius: 0,
    closePath: !0
  });
  var DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    width: 0,
    height: 0,
    x1: 0,
    y1: 0,
    strokeBoundsBuffer: 0,
    cornerRadius: 0
  });
  var DefaultRect3dAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    width: 0,
    height: 0,
    x1: 0,
    y1: 0,
    cornerRadius: 0,
    length: 0
  });
  var DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
    symbolType: "circle",
    size: 10,
    keepDirIn3d: !0
  });
  var DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
    strokeBoundsBuffer: 0,
    keepDirIn3d: !0
  });
  var DefaultRichTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
    width: 300,
    height: 300,
    ellipsis: !0,
    wordBreak: "break-word",
    verticalDirection: "top",
    textAlign: "left",
    textBaseline: "top",
    layoutDirection: "horizontal",
    textConfig: [],
    maxHeight: void 0,
    maxWidth: void 0,
    singleLine: !1
  });
  var DefaultImageAttribute = Object.assign(Object.assign({
    repeatX: "no-repeat",
    repeatY: "no-repeat",
    image: "",
    width: 0,
    height: 0
  }, DefaultAttribute), {
    fill: !0,
    cornerRadius: 0
  });
  var DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), {
    backgroundShowMode: "never",
    backgroundWidth: 0,
    backgroundHeight: 0,
    textAlign: "left",
    textBaseline: "middle",
    direction: "horizontal",
    margin: 0,
    id: "",
    width: 20,
    height: 20,
    backgroundFill: "rgba(101, 117, 168, 0.1)",
    backgroundFillOpacity: 1,
    backgroundStroke: !1,
    backgroundStrokeOpacity: 1,
    backgroundRadius: 4,
    opacity: 1
  });

  var Application = /*#__PURE__*/_createClass(function Application() {
    _classCallCheck(this, Application);
  });
  var application = new Application();

  var DIRECTION_KEY = {
    horizontal: {
      width: "width",
      height: "height",
      left: "left",
      top: "top",
      x: "x",
      y: "y",
      bottom: "bottom"
    },
    vertical: {
      width: "height",
      height: "width",
      left: "top",
      top: "left",
      x: "y",
      y: "x",
      bottom: "right"
    }
  };
  var defaultFormatting = {
      fontSize: 16,
      fontFamily: "sans-serif",
      fill: !0,
      stroke: !1,
      fontWeight: "normal",
      lineHeight: "normal",
      fontStyle: "normal",
      textDecoration: "none",
      textAlign: "left",
      script: "normal"
    };
  var regLetter = /\w|\(|\)|-/;
  var regPunctuation = /[.?!,;:/，。？！、；：]/;
  var regFirstSpace = /\S/;
  function applyFillStyle(ctx, character) {
    var fillStyle = character && character.fill || defaultFormatting.fill;
    if (!fillStyle) return void (ctx.globalAlpha = 0);
    ctx.globalAlpha = 1, ctx.fillStyle = fillStyle;
    var fontSize = character.fontSize || 16;
    switch (character.script) {
      case "super":
      case "sub":
        fontSize *= .8;
    }
    ctx.setTextStyle({
      textAlign: "left",
      textBaseline: character.textBaseline || "alphabetic",
      fontStyle: character.fontStyle || "",
      fontWeight: character.fontWeight || "",
      fontSize: fontSize,
      fontFamily: character.fontFamily || "sans-serif"
    });
  }
  function applyStrokeStyle(ctx, character) {
    var strokeStyle = character && character.stroke || defaultFormatting.stroke;
    if (!strokeStyle) return void (ctx.globalAlpha = 0);
    ctx.globalAlpha = 1, ctx.lineWidth = character && "number" == typeof character.lineWidth ? character.lineWidth : 1, ctx.strokeStyle = strokeStyle;
    var fontSize = character.fontSize || 16;
    switch (character.script) {
      case "super":
      case "sub":
        fontSize *= .8;
    }
    ctx.setTextStyle({
      textAlign: "left",
      textBaseline: character.textBaseline || "alphabetic",
      fontStyle: character.fontStyle || "",
      fontWeight: character.fontWeight || "",
      fontSize: fontSize,
      fontFamily: character.fontFamily || "sans-serif"
    });
  }
  function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
    if (!width || width <= 0) return 0;
    var textMeasure = application.graphicUtil.textMeasure;
    var index = guessIndex,
      temp = desc.slice(0, index),
      tempWidth = Math.floor(textMeasure.measureText(temp, character).width),
      tempNext = desc.slice(0, index + 1),
      tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
    for (; tempWidth > width || tempWidthNext <= width;) {
      if (tempWidth > width ? index-- : index++, index > desc.length) {
        index = desc.length;
        break;
      }
      if (index < 0) {
        index = 0;
        break;
      }
      temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
    }
    return needTestLetter && (index = testLetter(desc, index)), index;
  }
  function testLetter(string, index) {
    var i = index;
    for (; regLetter.test(string[i - 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]);) if (i--, i <= 0) return index;
    return i;
  }
  function measureTextCanvas(text, character) {
    var measurement = application.graphicUtil.textMeasure.measureText(text, character),
      result = {
        ascent: 0,
        height: 0,
        descent: 0,
        width: 0
      };
    return "number" != typeof measurement.actualBoundingBoxAscent || "number" != typeof measurement.actualBoundingBoxDescent ? (result.width = Math.floor(measurement.width), result.height = character.fontSize || 0, result.ascent = result.height, result.descent = 0) : (result.width = Math.floor(measurement.width), result.height = Math.floor(measurement.actualBoundingBoxAscent + measurement.actualBoundingBoxDescent), result.ascent = Math.floor(measurement.actualBoundingBoxAscent), result.descent = result.height - result.ascent), result;
  }

  var __decorate$1G = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var ATextMeasure = /*#__PURE__*/function () {
    function ATextMeasure() {
      _classCallCheck(this, ATextMeasure);
    }
    _createClass(ATextMeasure, [{
      key: "configure",
      value: function configure(service, env) {
        this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);
      }
    }, {
      key: "measureTextWidth",
      value: function measureTextWidth(text, options) {
        if (!this.context) return this.estimate(text, options).width;
        this.context.setTextStyleWithoutAlignBaseline(options);
        return this.context.measureText(text).width;
      }
    }, {
      key: "estimate",
      value: function estimate(text, _ref) {
        var _ref$fontSize = _ref.fontSize,
          fontSize = _ref$fontSize === void 0 ? DefaultTextAttribute.fontSize : _ref$fontSize;
        var eCharLen = 0,
          cCharLen = 0;
        for (var i = 0; i < text.length; i++) text.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
        return {
          width: ~~(.8 * eCharLen * fontSize + cCharLen * fontSize),
          height: fontSize
        };
      }
    }, {
      key: "measureTextPixelHeight",
      value: function measureTextPixelHeight(text, options) {
        var _a;
        if (!this.context) return null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
        this.context.setTextStyleWithoutAlignBaseline(options);
        var textMeasure = this.context.measureText(text);
        return Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent);
      }
    }, {
      key: "measureTextBoundHieght",
      value: function measureTextBoundHieght(text, options) {
        var _a;
        if (!this.context) return null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
        this.context.setTextStyleWithoutAlignBaseline(options);
        var textMeasure = this.context.measureText(text);
        return Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent);
      }
    }, {
      key: "measureText",
      value: function measureText(text, options) {
        return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text)) : this.estimate(text, options);
      }
    }, {
      key: "clipTextVertical",
      value: function clipTextVertical(verticalList, options, width, wordBreak) {
        var _this = this;
        if (0 === verticalList.length) return {
          verticalList: verticalList,
          width: 0
        };
        var _options$fontSize = options.fontSize,
          fontSize = _options$fontSize === void 0 ? 12 : _options$fontSize;
        verticalList.forEach(function (item) {
          item.width = 0 === item.direction ? fontSize : _this.measureTextWidth(item.text, options);
        });
        var out = [];
        var length = 0,
          i = 0;
        for (; i < verticalList.length && length + verticalList[i].width < width; i++) length += verticalList[i].width, out.push(verticalList[i]);
        if (verticalList[i] && verticalList[i].text.length > 1) {
          var clipedData = this._clipText(verticalList[i].text, options, width - length, 0, verticalList[i].text.length - 1, "end", !1);
          if (wordBreak && clipedData.str !== verticalList[i].text) {
            var text = "",
              _length = 0;
            for (var j = 0; j < i; j++) {
              var item = verticalList[j];
              text += item.text, _length += item.text.length;
            }
            text += verticalList[i].text;
            var totalLength = _length + clipedData.str.length;
            var index = testLetter(text, totalLength);
            index -= _length, index !== clipedData.str.length - 1 && (clipedData.str = clipedData.str.substring(0, index), clipedData.width = this.measureTextWidth(clipedData.str, options));
          }
          out.push(Object.assign(Object.assign({}, verticalList[i]), {
            text: clipedData.str,
            width: clipedData.width
          })), length += clipedData.width;
        }
        return {
          verticalList: out,
          width: length
        };
      }
    }, {
      key: "clipText",
      value: function clipText(text, options, width, wordBreak) {
        if (0 === text.length) return {
          str: "",
          width: 0
        };
        var length = this.measureTextWidth(text, options);
        if (length <= width) return {
          str: text,
          width: length
        };
        if (length = this.measureTextWidth(text[0], options), length > width) return {
          str: "",
          width: 0
        };
        var data = this._clipText(text, options, width, 0, text.length - 1, "end", !1);
        if (wordBreak && data.str !== text) {
          var index = testLetter(text, data.str.length);
          index !== data.str.length && (data.str = text.substring(0, index), data.width = this.measureTextWidth(data.str, options));
        }
        return data;
      }
    }, {
      key: "_clipText",
      value: function _clipText(text, options, width, leftIdx, rightIdx, position, suffix) {
        var data;
        if ("start" === position) data = this._clipTextStart(text, options, width, leftIdx, rightIdx), suffix && (data.result = suffix + data.str);else if ("middle" === position) {
          var d = this._clipTextMiddle(text, options, width, "", "", 0, 0, 1);
          data = {
            str: "none",
            width: d.width,
            result: d.left + suffix + d.right
          };
        } else data = this._clipTextEnd(text, options, width, leftIdx, rightIdx), suffix && (data.result = data.str + suffix);
        return data;
      }
    }, {
      key: "_clipTextEnd",
      value: function _clipTextEnd(text, options, width, leftIdx, rightIdx) {
        var middleIdx = Math.floor((leftIdx + rightIdx) / 2),
          subText = text.substring(0, middleIdx + 1),
          strWidth = this.measureTextWidth(subText, options);
        var length;
        if (strWidth > width) {
          if (subText.length <= 1) return {
            str: "",
            width: 0
          };
          var str = text.substring(0, middleIdx);
          return length = this.measureTextWidth(str, options), length <= width ? {
            str: str,
            width: length
          } : this._clipTextEnd(text, options, width, leftIdx, middleIdx);
        }
        if (strWidth < width) {
          if (middleIdx >= text.length - 1) return {
            str: text,
            width: this.measureTextWidth(text, options)
          };
          var _str = text.substring(0, middleIdx + 2);
          return length = this.measureTextWidth(_str, options), length >= width ? {
            str: subText,
            width: strWidth
          } : this._clipTextEnd(text, options, width, middleIdx, rightIdx);
        }
        return {
          str: subText,
          width: strWidth
        };
      }
    }, {
      key: "_clipTextStart",
      value: function _clipTextStart(text, options, width, leftIdx, rightIdx) {
        var middleIdx = Math.ceil((leftIdx + rightIdx) / 2),
          subText = text.substring(middleIdx - 1, text.length - 1),
          strWidth = this.measureTextWidth(subText, options);
        var length;
        if (strWidth > width) {
          if (subText.length <= 1) return {
            str: "",
            width: 0
          };
          var str = text.substring(middleIdx, text.length - 1);
          return length = this.measureTextWidth(str, options), length <= width ? {
            str: str,
            width: length
          } : this._clipTextStart(text, options, width, middleIdx, text.length - 1);
        }
        if (strWidth < width) {
          if (middleIdx <= 0) return {
            str: text,
            width: this.measureTextWidth(text, options)
          };
          var _str2 = text.substring(middleIdx - 2, text.length - 1);
          return length = this.measureTextWidth(_str2, options), length >= width ? {
            str: subText,
            width: strWidth
          } : this._clipTextStart(text, options, width, leftIdx, middleIdx);
        }
        return {
          str: subText,
          width: strWidth
        };
      }
    }, {
      key: "_clipTextMiddle",
      value: function _clipTextMiddle(text, options, width, left, right, leftW, rightW, buffer) {
        var subLeftText = text.substring(0, buffer),
          strLeftWidth = this.measureTextWidth(subLeftText, options);
        if (strLeftWidth + rightW > width) return {
          left: left,
          right: right,
          width: leftW + rightW
        };
        var subRightText = text.substring(text.length - buffer, text.length),
          strRightWidth = this.measureTextWidth(subRightText, options);
        return strLeftWidth + strRightWidth > width ? {
          left: subLeftText,
          right: right,
          width: strLeftWidth + rightW
        } : this._clipTextMiddle(text, options, width, subLeftText, subRightText, strLeftWidth, strRightWidth, buffer + 1);
      }
    }, {
      key: "clipTextWithSuffixVertical",
      value: function clipTextWithSuffixVertical(verticalList, options, width, suffix, wordBreak, suffixPosition) {
        if ("" === suffix) return this.clipTextVertical(verticalList, options, width, wordBreak);
        if (0 === verticalList.length) return {
          verticalList: verticalList,
          width: 0
        };
        var output = this.clipTextVertical(verticalList, options, width, wordBreak);
        if (output.verticalList.length === verticalList.length && output.verticalList[output.verticalList.length - 1].width === verticalList[verticalList.length - 1].width) return output;
        var suffixWidth = this.measureTextWidth(suffix, options);
        if (suffixWidth > width) return output;
        var out;
        if (width -= suffixWidth, "start" === suffixPosition) {
          var nextVerticalList = this.revertVerticalList(verticalList);
          out = this.clipTextVertical(nextVerticalList, options, width, wordBreak);
          var v = this.revertVerticalList(out.verticalList);
          v.unshift({
            text: suffix,
            direction: 1,
            width: suffixWidth
          }), out.verticalList = v;
        } else if ("middle" === suffixPosition) {
          var leftOut = this.clipTextVertical(verticalList, options, width / 2, wordBreak),
            _nextVerticalList = this.revertVerticalList(verticalList),
            rightOut = this.clipTextVertical(_nextVerticalList, options, width / 2, wordBreak);
          leftOut.verticalList.push({
            text: suffix,
            direction: 1,
            width: suffixWidth
          }), this.revertVerticalList(rightOut.verticalList).forEach(function (v) {
            return leftOut.verticalList.push(v);
          }), out = {
            verticalList: leftOut.verticalList,
            width: leftOut.width + rightOut.width
          };
        } else out = this.clipTextVertical(verticalList, options, width, wordBreak), out.verticalList.push({
          text: suffix,
          direction: 1,
          width: suffixWidth
        });
        return out.width += suffixWidth, out;
      }
    }, {
      key: "revertVerticalList",
      value: function revertVerticalList(verticalList) {
        return verticalList.reverse().map(function (l) {
          var t = l.text.split("").reverse().join("");
          return Object.assign(Object.assign({}, l), {
            text: t
          });
        });
      }
    }, {
      key: "clipTextWithSuffix",
      value: function clipTextWithSuffix(text, options, width, suffix, wordBreak, position) {
        if ("" === suffix) return this.clipText(text, options, width, wordBreak);
        if (0 === text.length) return {
          str: "",
          width: 0
        };
        var length = this.measureTextWidth(text, options);
        if (length <= width) return {
          str: text,
          width: length
        };
        var suffixWidth = this.measureTextWidth(suffix, options);
        if (suffixWidth > width) return {
          str: "",
          width: 0
        };
        width -= suffixWidth;
        var data = this._clipText(text, options, width, 0, text.length - 1, position, suffix);
        if (wordBreak && data.str !== text) {
          var index = testLetter(text, data.str.length);
          index !== data.str.length && (data.str = text.substring(0, index), data.width = this.measureTextWidth(data.str, options));
        }
        return data.str = data.result, data.width += suffixWidth, data;
      }
    }]);
    return ATextMeasure;
  }();
  ATextMeasure = __decorate$1G([injectable()], ATextMeasure);

  var __decorate$1F = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var TextMeasureContribution = Symbol["for"]("TextMeasureContribution");
  exports.DefaultTextMeasureContribution = /*#__PURE__*/function (_ATextMeasure) {
    _inherits(DefaultTextMeasureContribution, _ATextMeasure);
    var _super = _createSuper(DefaultTextMeasureContribution);
    function DefaultTextMeasureContribution() {
      _classCallCheck(this, DefaultTextMeasureContribution);
      return _super.apply(this, arguments);
    }
    return _createClass(DefaultTextMeasureContribution);
  }(ATextMeasure);
  exports.DefaultTextMeasureContribution = __decorate$1F([injectable()], exports.DefaultTextMeasureContribution);

  var container = new Container();

  var CanvasFactory = Symbol["for"]("CanvasFactory");
  var Context2dFactory = Symbol["for"]("Context2dFactory");

  function wrapCanvas(params) {
    return container.getNamed(CanvasFactory, application.global.env)(params);
  }
  function wrapContext(canvas, dpr) {
    return container.getNamed(Context2dFactory, application.global.env)(canvas, dpr);
  }
  var EPSILON_NUMERIC = 1e-4,
    THREE_SQRT = Math.sqrt(3),
    ONE_THIRD = 1 / 3;
  function isAroundZero(val) {
    return val > -EPSILON && val < EPSILON;
  }
  function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
  }
  var _v0 = [0, 0],
    _v1 = [0, 0],
    _v2 = [0, 0];
  function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
  }
  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
  }
  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
  }
  function quadraticRootAt(p0, p1, p2, val, roots) {
    var a = p0 - 2 * p1 + p2,
      b = 2 * (p1 - p0),
      c = p0 - val;
    var n = 0;
    if (isAroundZero(a)) {
      if (isNotAroundZero(b)) {
        var t1 = -c / b;
        t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isAroundZero(disc)) {
        var _t2 = -b / (2 * a);
        _t2 >= 0 && _t2 <= 1 && (roots[n++] = _t2);
      } else if (disc > 0) {
        var discSqrt = Math.sqrt(disc),
          _t3 = (-b + discSqrt) / (2 * a),
          t2 = (-b - discSqrt) / (2 * a);
        _t3 >= 0 && _t3 <= 1 && (roots[n++] = _t3), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
      }
    }
    return n;
  }
  function quadraticExtremum(p0, p1, p2) {
    var divider = p0 + p2 - 2 * p1;
    return 0 === divider ? .5 : (p0 - p1) / divider;
  }
  function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
    var t = 0,
      interval = .005,
      d = 1 / 0;
    _v0[0] = x, _v0[1] = y;
    for (var _t = 0; _t < 1; _t += .05) {
      _v1[0] = quadraticAt(x0, x1, x2, _t), _v1[1] = quadraticAt(y0, y1, y2, _t);
      var d1 = distanceSquare(_v0, _v1);
      d1 < d && (t = _t, d = d1);
    }
    d = 1 / 0;
    for (var i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {
      var prev = t - interval,
        next = t + interval;
      _v1[0] = quadraticAt(x0, x1, x2, prev), _v1[1] = quadraticAt(y0, y1, y2, prev);
      var _d = distanceSquare(_v1, _v0);
      if (prev >= 0 && _d < d) t = prev, d = _d;else {
        _v2[0] = quadraticAt(x0, x1, x2, next), _v2[1] = quadraticAt(y0, y1, y2, next);
        var d2 = distanceSquare(_v2, _v0);
        next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5;
      }
    }
    return out && (out[0] = quadraticAt(x0, x1, x2, t), out[1] = quadraticAt(y0, y1, y2, t)), Math.sqrt(d);
  }
  function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
    var prev,
      next,
      d1,
      d2,
      t = 0,
      interval = .005,
      d = 1 / 0;
    _v0[0] = x, _v0[1] = y;
    for (var _t = 0; _t < 1; _t += .05) _v1[0] = cubicAt(x0, x1, x2, x3, _t), _v1[1] = cubicAt(y0, y1, y2, y3, _t), d1 = distanceSquare(_v0, _v1), d1 < d && (t = _t, d = d1);
    d = 1 / 0;
    for (var i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) prev = t - interval, next = t + interval, _v1[0] = cubicAt(x0, x1, x2, x3, prev), _v1[1] = cubicAt(y0, y1, y2, y3, prev), d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x0, x1, x2, x3, next), _v2[1] = cubicAt(y0, y1, y2, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5);
    return out && (out[0] = cubicAt(x0, x1, x2, x3, t), out[1] = cubicAt(y0, y1, y2, y3, t)), Math.sqrt(d);
  }
  function normalizeRadian(angle) {
    return (angle %= pi2) < 0 && (angle += pi2), angle;
  }
  function windingLine(x0, y0, x1, y1, x, y) {
    if (y > y0 && y > y1 || y < y0 && y < y1) return 0;
    if (y1 === y0) return 0;
    var t = (y - y0) / (y1 - y0);
    var dir = y1 < y0 ? 1 : -1;
    1 !== t && 0 !== t || (dir = y1 < y0 ? .5 : -.5);
    var x_ = t * (x1 - x0) + x0;
    return x_ === x ? 1 / 0 : x_ > x ? dir : 0;
  }
  function containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (0 === lineWidth) return !1;
    var _l = lineWidth;
    if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) return !1;
    return quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;
  }
  function containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (0 === lineWidth) return !1;
    var _l = lineWidth;
    if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) return !1;
    return cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;
  }
  function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
    if (0 === lineWidth) return !1;
    var _l = lineWidth;
    x -= cx, y -= cy;
    var d = Math.sqrt(x * x + y * y);
    if (d - _l > r || d + _l < r) return !1;
    if (Math.abs(startAngle - endAngle) % pi2 < 1e-4) return !0;
    if (anticlockwise) {
      var tmp = startAngle;
      startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
    } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
    startAngle > endAngle && (endAngle += pi2);
    var angle = Math.atan2(y, x);
    return angle < 0 && (angle += pi2), angle >= startAngle && angle <= endAngle || angle + pi2 >= startAngle && angle + pi2 <= endAngle;
  }
  function containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {
    if (0 === lineWidth) return !1;
    var _l = lineWidth,
      _halfL = lineWidth / 2;
    var _a = 0,
      _b = x0;
    if (y > y0 + _halfL && y > y1 + _halfL || y < y0 - _halfL && y < y1 - _halfL || x > x0 + _halfL && x > x1 + _halfL || x < x0 - _halfL && x < x1 - _halfL) return !1;
    if (x0 === x1) return Math.abs(x - x0) <= _l / 2;
    _a = (y0 - y1) / (x0 - x1), _b = (x0 * y1 - x1 * y0) / (x0 - x1);
    var tmp = _a * x - y + _b;
    return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
  }
  var EPSILON = 1e-4;
  function cubicRootAt(p0, p1, p2, p3, val, roots) {
    var a = p3 + 3 * (p1 - p2) - p0,
      b = 3 * (p2 - 2 * p1 + p0),
      c = 3 * (p1 - p0),
      d = p0 - val,
      A = b * b - 3 * a * c,
      B = b * c - 9 * a * d,
      C = c * c - 3 * b * d;
    var n = 0;
    if (isAroundZero(A) && isAroundZero(B)) {
      if (isAroundZero(b)) roots[0] = 0;else {
        var t1 = -c / b;
        t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
      }
    } else {
      var disc = B * B - 4 * A * C;
      if (isAroundZero(disc)) {
        var K = B / A,
          _t4 = -b / a + K,
          t2 = -K / 2;
        _t4 >= 0 && _t4 <= 1 && (roots[n++] = _t4), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
      } else if (disc > 0) {
        var discSqrt = Math.sqrt(disc);
        var Y1 = A * b + 1.5 * a * (-B + discSqrt),
          Y2 = A * b + 1.5 * a * (-B - discSqrt);
        Y1 = Y1 < 0 ? -Math.pow(-Y1, ONE_THIRD) : Math.pow(Y1, ONE_THIRD), Y2 = Y2 < 0 ? -Math.pow(-Y2, ONE_THIRD) : Math.pow(Y2, ONE_THIRD);
        var _t5 = (-b - (Y1 + Y2)) / (3 * a);
        _t5 >= 0 && _t5 <= 1 && (roots[n++] = _t5);
      } else {
        var T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A)),
          theta = Math.acos(T) / 3,
          ASqrt = Math.sqrt(A),
          tmp = Math.cos(theta),
          _t6 = (-b - 2 * ASqrt * tmp) / (3 * a),
          _t7 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a),
          t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
        _t6 >= 0 && _t6 <= 1 && (roots[n++] = _t6), _t7 >= 0 && _t7 <= 1 && (roots[n++] = _t7), t3 >= 0 && t3 <= 1 && (roots[n++] = t3);
      }
    }
    return n;
  }
  function cubicExtrema(p0, p1, p2, p3, extrema) {
    var b = 6 * p2 - 12 * p1 + 6 * p0,
      a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2,
      c = 3 * p1 - 3 * p0;
    var n = 0;
    if (isAroundZero(a)) {
      if (isNotAroundZero(b)) {
        var t1 = -c / b;
        t1 >= 0 && t1 <= 1 && (extrema[n++] = t1);
      }
    } else {
      var disc = b * b - 4 * a * c;
      if (isAroundZero(disc)) extrema[0] = -b / (2 * a);else if (disc > 0) {
        var discSqrt = Math.sqrt(disc),
          _t8 = (-b + discSqrt) / (2 * a),
          t2 = (-b - discSqrt) / (2 * a);
        _t8 >= 0 && _t8 <= 1 && (extrema[n++] = _t8), t2 >= 0 && t2 <= 1 && (extrema[n++] = t2);
      }
    }
    return n;
  }
  function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
  }
  var roots = [-1, -1, -1],
    extrema = [-1, -1];
  function swapExtrema() {
    var tmp = extrema[0];
    extrema[0] = extrema[1], extrema[1] = tmp;
  }
  function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;
    var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
    if (0 === nRoots) return 0;
    var w = 0,
      nExtrema = -1,
      y0_ = 0,
      y1_ = 0;
    for (var i = 0; i < nRoots; i++) {
      var t = roots[i],
        unit = 0 === t || 1 === t ? .5 : 1;
      cubicAt(x0, x1, x2, x3, t) < x || (nExtrema < 0 && (nExtrema = cubicExtrema(y0, y1, y2, y3, extrema), extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y0, y1, y2, y3, extrema[0]), nExtrema > 1 && (y1_ = cubicAt(y0, y1, y2, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y0 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y0 ? unit : -unit : w += y3 < y0_ ? unit : -unit);
    }
    return w;
  }
  function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;
    var nRoots = quadraticRootAt(y0, y1, y2, y, roots);
    if (0 === nRoots) return 0;
    var t = quadraticExtremum(y0, y1, y2);
    if (t >= 0 && t <= 1) {
      var w = 0;
      var y_ = quadraticAt(y0, y1, y2, t);
      for (var i = 0; i < nRoots; i++) {
        var _unit = 0 === roots[i] || 1 === roots[i] ? .5 : 1;
        quadraticAt(x0, x1, x2, roots[i]) < x || (roots[i] < t ? w += y_ < y0 ? _unit : -_unit : w += y2 < y_ ? _unit : -_unit);
      }
      return w;
    }
    var unit = 0 === roots[0] || 1 === roots[0] ? .5 : 1;
    return quadraticAt(x0, x1, x2, roots[0]) < x ? 0 : y2 < y0 ? unit : -unit;
  }
  function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    if ((y -= cy) > r || y < -r) return 0;
    var tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp, roots[1] = tmp;
    var dTheta = Math.abs(startAngle - endAngle);
    if (dTheta < 1e-4) return 0;
    if (dTheta >= pi2 - 1e-4) {
      startAngle = 0, endAngle = pi2;
      var dir = anticlockwise ? 1 : -1;
      return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;
    }
    if (startAngle > endAngle) {
      var _tmp = startAngle;
      startAngle = endAngle, endAngle = _tmp;
    }
    startAngle < 0 && (startAngle += pi2, endAngle += pi2);
    var w = 0;
    for (var i = 0; i < 2; i++) {
      var x_ = roots[i];
      if (x_ + cx > x) {
        var angle = Math.atan2(y, x_),
          _dir = anticlockwise ? 1 : -1;
        angle < 0 && (angle = pi2 + angle), (angle >= startAngle && angle <= endAngle || angle + pi2 >= startAngle && angle + pi2 <= endAngle) && (angle > pi / 2 && angle < 1.5 * pi && (_dir = -_dir), w += _dir);
      }
    }
    return w;
  }
  function modpi2(radian) {
    return Math.round(radian / pi * 1e8) / 1e8 % 2 * pi;
  }
  function normalizeArcAngles(angles, anticlockwise) {
    var newStartAngle = modpi2(angles[0]);
    newStartAngle < 0 && (newStartAngle += pi2);
    var delta = newStartAngle - angles[0];
    var newEndAngle = angles[1];
    newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= pi2 ? newEndAngle = newStartAngle + pi2 : anticlockwise && newStartAngle - newEndAngle >= pi2 ? newEndAngle = newStartAngle - pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle))), angles[0] = newStartAngle, angles[1] = newEndAngle;
  }
  var tmpAngles = [0, 0];
  function containPath(commands, lineWidth, isStroke, x, y) {
    var data = commands,
      len = commands.length;
    var x1,
      y1,
      w = 0,
      xi = 0,
      yi = 0,
      x0 = 0,
      y0 = 0;
    for (var i = 0; i < len; i++) {
      var command = data[i],
        isFirst = 0 === i;
      command[0] === enumCommandMap.M && i > 1 && (isStroke || (w += windingLine(xi, yi, x0, y0, x, y))), isFirst && (xi = command[1], yi = command[2], x0 = xi, y0 = yi);
      var c0 = command[0],
        c1 = command[1],
        c2 = command[2],
        c3 = command[3],
        c4 = command[4],
        c5 = command[5],
        c6 = command[6];
      var startAngle = c4,
        endAngle = c5;
      tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), startAngle = tmpAngles[0], endAngle = tmpAngles[1];
      var theta = startAngle,
        dTheta = endAngle - startAngle,
        anticlockwise = !!(1 - (command[6] ? 0 : 1)),
        _x = (x - c1) * c3 / c3 + c1;
      switch (c0) {
        case enumCommandMap.M:
          x0 = c1, y0 = c2, xi = x0, yi = y0;
          break;
        case enumCommandMap.L:
          if (isStroke) {
            if (containLineStroke(xi, yi, c1, c2, lineWidth, x, y)) return !0;
          } else w += windingLine(xi, yi, c1, c2, x, y) || 0;
          xi = c1, yi = c2;
          break;
        case enumCommandMap.C:
          if (isStroke) {
            if (containCubicStroke(xi, yi, c1, c2, c3, c4, c5, c6, lineWidth, x, y)) return !0;
          } else w += windingCubic(xi, yi, c1, c2, c3, c4, c5, c6, x, y) || 0;
          xi = c5, yi = c6;
          break;
        case enumCommandMap.Q:
          if (isStroke) {
            if (containQuadStroke(xi, yi, c1, c2, c3, c4, lineWidth, x, y)) return !0;
          } else w += windingQuadratic(xi, yi, c1, c2, c3, c4, x, y) || 0;
          xi = c3, yi = c4;
          break;
        case enumCommandMap.A:
          if (x1 = Math.cos(theta) * c3 + c1, y1 = Math.sin(theta) * c3 + c2, isFirst ? (x0 = x1, y0 = y1) : w += windingLine(xi, yi, x1, y1, x, y), isStroke) {
            if (containArcStroke(c1, c2, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return !0;
          } else w += windingArc(c1, c2, c3, theta, theta + dTheta, anticlockwise, _x, y);
          xi = Math.cos(theta + dTheta) * c3 + c1, yi = Math.sin(theta + dTheta) * c3 + c2;
          break;
        case enumCommandMap.R:
          if (x0 = xi = c1, y0 = yi = c2, x1 = x0 + c3, y1 = y0 + c4, isStroke) {
            if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) || containLineStroke(x1, y0, x1, y1, lineWidth, x, y) || containLineStroke(x1, y1, x0, y1, lineWidth, x, y) || containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) return !0;
          } else w += windingLine(x1, y0, x1, y1, x, y), w += windingLine(x0, y1, x0, y0, x, y);
          break;
        case enumCommandMap.Z:
          if (isStroke) {
            if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) return !0;
          } else w += windingLine(xi, yi, x0, y0, x, y);
          xi = x0, yi = y0;
      }
    }
    return isStroke || isAroundEqual(yi, y0) || (w += windingLine(xi, yi, x0, y0, x, y) || 0), 0 !== w;
  }
  function contain(commands, x, y) {
    return containPath(commands, 0, !1, x, y);
  }
  function containStroke(commands, lineWidth, x, y) {
    return containPath(commands, lineWidth, !0, x, y);
  }

  var DefaultCanvasAllocate = /*#__PURE__*/function () {
    function DefaultCanvasAllocate() {
      _classCallCheck(this, DefaultCanvasAllocate);
      this.pools = [], this.allocatedCanvas = [];
    }
    _createClass(DefaultCanvasAllocate, [{
      key: "shareCanvas",
      value: function shareCanvas() {
        return this.allocatedCanvas.length ? this.allocatedCanvas[0] : this.getCommonCanvas();
      }
    }, {
      key: "getCommonCanvas",
      value: function getCommonCanvas() {
        return this._commonCanvas || (this._commonCanvas = this.allocate({
          width: 100,
          height: 100,
          dpr: 2
        })), this._commonCanvas;
      }
    }, {
      key: "allocate",
      value: function allocate(data) {
        if (!this.pools.length) {
          var c = wrapCanvas(Object.assign({
            nativeCanvas: application.global.createCanvas(data)
          }, data));
          return this.allocatedCanvas.push(c), c;
        }
        var m = this.pools.pop();
        return m.resize(data.width, data.height), m.dpr = data.dpr, m;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(canvas) {
        if (!this.pools.length) {
          var data = {
              width: canvas.width / canvas.dpr,
              height: canvas.height / canvas.dpr,
              dpr: canvas.dpr
            },
            c = wrapCanvas(Object.assign({
              nativeCanvas: application.global.createCanvas(data)
            }, data));
          return this.allocatedCanvas.push(c), c;
        }
        var m = this.pools.pop();
        return m.width = canvas.width, m.height = canvas.height, m;
      }
    }, {
      key: "free",
      value: function free(d) {
        this.pools.push(d);
      }
    }, {
      key: "length",
      get: function get() {
        return this.pools.length;
      }
    }, {
      key: "release",
      value: function release() {
        this.pools = [];
      }
    }]);
    return DefaultCanvasAllocate;
  }();
  var canvasAllocate = new DefaultCanvasAllocate();

  var __decorate$1E = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$1g = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var VWindow = Symbol["for"]("VWindow");
  var WindowHandlerContribution = Symbol["for"]("WindowHandlerContribution");
  exports.DefaultWindow = /*#__PURE__*/function () {
    function DefaultWindow() {
      var _this = this;
      _classCallCheck(this, DefaultWindow);
      this.hooks = {
        onChange: new SyncHook(["x", "y", "width", "height"])
      }, this.active = function () {
        var global = _this.global;
        if (!global.env || _this.actived) return;
        container.getNamed(WindowHandlerContribution, global.env).configure(_this, global), _this.actived = !0;
      }, this._uid = Generator.GenAutoIncrementId(), this.global = application.global, this.postInit();
    }
    _createClass(DefaultWindow, [{
      key: "width",
      get: function get() {
        if (this._handler) {
          var wh = this._handler.getWH();
          return this._width = wh.width;
        }
        return this._width;
      }
    }, {
      key: "height",
      get: function get() {
        if (this._handler) {
          var wh = this._handler.getWH();
          return this._height = wh.height;
        }
        return this._height;
      }
    }, {
      key: "dpr",
      get: function get() {
        return this._handler.getDpr();
      }
    }, {
      key: "postInit",
      value: function postInit() {
        this.global.hooks.onSetEnv.tap("window", this.active), this.active();
      }
    }, {
      key: "style",
      get: function get() {
        var _a;
        return null !== (_a = this._handler.getStyle()) && void 0 !== _a ? _a : {};
      },
      set: function set(style) {
        this._handler.setStyle(style);
      }
    }, {
      key: "create",
      value: function create(params) {
        var _a, _b;
        this._handler.createWindow(params);
        var windowWH = this._handler.getWH();
        this._width = windowWH.width, this._height = windowWH.height, params.viewBox ? this.setViewBox(params.viewBox) : !1 !== params.canvasControled ? this.setViewBox({
          x1: 0,
          y1: 0,
          x2: this._width,
          y2: this._height
        }) : this.setViewBox({
          x1: 0,
          y1: 0,
          x2: null !== (_a = params.width) && void 0 !== _a ? _a : this._width,
          y2: null !== (_b = params.height) && void 0 !== _b ? _b : this._height
        }), this.title = this._handler.getTitle(), this.resizable = !0;
      }
    }, {
      key: "setWindowHandler",
      value: function setWindowHandler(handler) {
        this._handler = handler;
      }
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        return this._handler.setDpr(dpr);
      }
    }, {
      key: "resize",
      value: function resize(w, h) {
        return this._handler.resizeWindow(w, h);
      }
    }, {
      key: "configure",
      value: function configure() {
        throw new Error("暂不支持");
      }
    }, {
      key: "release",
      value: function release() {
        return this.global.hooks.onSetEnv.unTap("window", this.active), this._handler.releaseWindow();
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this._handler.getContext();
      }
    }, {
      key: "getNativeHandler",
      value: function getNativeHandler() {
        return this._handler.getNativeHandler();
      }
    }, {
      key: "getImageBuffer",
      value: function getImageBuffer(type) {
        return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        return this._handler.addEventListener(type, listener, options);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        return this._handler.removeEventListener(type, listener, options);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return this._handler.dispatchEvent(event);
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        return this._handler.getBoundingClientRect();
      }
    }, {
      key: "getContainer",
      value: function getContainer() {
        return this._handler.container;
      }
    }, {
      key: "clearViewBox",
      value: function clearViewBox(color) {
        this._handler.clearViewBox(color);
      }
    }, {
      key: "setViewBox",
      value: function setViewBox(viewBox) {
        this._handler.setViewBox(viewBox);
      }
    }, {
      key: "setViewBoxTransform",
      value: function setViewBoxTransform(a, b, c, d, e, f) {
        this._handler.setViewBoxTransform(a, b, c, d, e, f);
      }
    }, {
      key: "getViewBox",
      value: function getViewBox() {
        return this._handler.getViewBox();
      }
    }, {
      key: "getViewBoxTransform",
      value: function getViewBoxTransform() {
        return this._handler.getViewBoxTransform();
      }
    }, {
      key: "pointTransform",
      value: function pointTransform(x, y) {
        var vb = this._handler.getViewBox(),
          nextP = {
            x: x,
            y: y
          };
        return this._handler.getViewBoxTransform().transformPoint({
          x: x,
          y: y
        }, nextP), nextP.x -= vb.x1, nextP.y -= vb.y1, nextP;
      }
    }, {
      key: "hasSubView",
      value: function hasSubView() {
        var viewBox = this._handler.getViewBox();
        return !(0 === viewBox.x1 && 0 === viewBox.y1 && this.width === viewBox.width() && this.height === viewBox.height());
      }
    }, {
      key: "isVisible",
      value: function isVisible(bbox) {
        return this._handler.isVisible(bbox);
      }
    }, {
      key: "onVisibleChange",
      value: function onVisibleChange(cb) {
        return this._handler.onVisibleChange(cb);
      }
    }, {
      key: "getTopLeft",
      value: function getTopLeft(baseWindow) {
        return this._handler.getTopLeft(baseWindow);
      }
    }]);
    return DefaultWindow;
  }();
  exports.DefaultWindow = __decorate$1E([injectable(), __metadata$1g("design:paramtypes", [])], exports.DefaultWindow);

  var __decorate$1D = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$1f = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$R = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultGraphicUtil = /*#__PURE__*/function () {
    function DefaultGraphicUtil(contributions) {
      var _this = this;
      _classCallCheck(this, DefaultGraphicUtil);
      this.contributions = contributions, this.configured = !1, this.global = application.global, this.global.hooks.onSetEnv.tap("graphic-util", function (lastEnv, env, global) {
        _this.configured = !1, _this.configure(global, env);
      });
    }
    _createClass(DefaultGraphicUtil, [{
      key: "canvas",
      get: function get() {
        return this.tryInitCanvas(), this._canvas;
      }
    }, {
      key: "context",
      get: function get() {
        return this.tryInitCanvas(), this._context;
      }
    }, {
      key: "textMeasure",
      get: function get() {
        return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
      }
    }, {
      key: "configure",
      value: function configure(global, env) {
        var _this2 = this;
        this.configured || (this.contributions.getContributions().forEach(function (contribution) {
          contribution.configure(_this2, env);
        }), this.configured = !0);
      }
    }, {
      key: "tryInitCanvas",
      value: function tryInitCanvas() {
        if (!this._canvas) {
          var canvas = canvasAllocate.shareCanvas();
          this._canvas = canvas, this._context = canvas.getContext("2d");
        }
      }
    }, {
      key: "bindTextMeasure",
      value: function bindTextMeasure(tm) {
        this._textMeasure = tm;
      }
    }, {
      key: "measureText",
      value: function measureText(text, tc) {
        var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "native";
        var _a;
        this.configure(this.global, this.global.env);
        var m = this.global.measureTextMethod;
        this.global.measureTextMethod = method;
        var data = {
          width: this._textMeasure.measureTextWidth(text, tc),
          height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize
        };
        return this.global.measureTextMethod = m, data;
      }
    }, {
      key: "createTextMeasureInstance",
      value: function createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
        var _this3 = this;
        return this.configure(this.global, this.global.env), new TextMeasure(Object.assign({
          defaultFontParams: {
            fontFamily: DefaultTextStyle.fontFamily,
            fontSize: DefaultTextStyle.fontSize
          },
          getCanvasForMeasure: getCanvasForMeasure || function () {
            return _this3.canvas;
          },
          getTextBounds: void 0,
          specialCharSet: "-/: .,@%'\"~" + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
        }, null != option ? option : {}), textSpec);
      }
    }, {
      key: "drawGraphicToCanvas",
      value: function drawGraphicToCanvas(graphic, stage, canvas) {
        if (!stage.defaultLayer) return null;
        var window = container.get(VWindow),
          bounds = graphic.AABBBounds,
          width = bounds.width(),
          height = bounds.height(),
          x1 = -bounds.x1,
          y1 = -bounds.y1;
        window.create({
          viewBox: {
            x1: x1,
            y1: y1,
            x2: bounds.x2,
            y2: bounds.y2
          },
          width: width,
          height: height,
          canvas: canvas,
          dpr: stage.window.dpr,
          canvasControled: !0,
          offscreen: !0,
          title: ""
        });
        var disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
        stage.params.optimize.disableCheckGraphicWidthOutRange = !0, stage.defaultLayer.getNativeHandler().drawTo(window, [graphic], {
          transMatrix: window.getViewBoxTransform(),
          viewBox: window.getViewBox(),
          stage: stage,
          layer: stage.defaultLayer,
          renderService: stage.renderService,
          background: "transparent",
          clear: !0,
          updateBounds: !1
        }), stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
        var c = window.getNativeHandler();
        return c.nativeCanvas ? c.nativeCanvas : null;
      }
    }]);
    return DefaultGraphicUtil;
  }();
  exports.DefaultGraphicUtil = __decorate$1D([injectable(), __param$R(0, inject(ContributionProvider)), __param$R(0, named(TextMeasureContribution)), __metadata$1f("design:paramtypes", [Object])], exports.DefaultGraphicUtil);
  var TransformMode;
  !function (TransformMode) {
    TransformMode[TransformMode.transform = 0] = "transform", TransformMode[TransformMode.matrix = 1] = "matrix";
  }(TransformMode || (TransformMode = {}));
  var _matrix = new Matrix();
  exports.DefaultTransformUtil = /*#__PURE__*/function () {
    function DefaultTransformUtil() {
      _classCallCheck(this, DefaultTransformUtil);
      this.matrix = new Matrix();
    }
    _createClass(DefaultTransformUtil, [{
      key: "init",
      value: function init(origin) {
        return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), this;
      }
    }, {
      key: "fromMatrix",
      value: function fromMatrix(source, target) {
        return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, this;
      }
    }, {
      key: "scaleMatrix",
      value: function scaleMatrix(sx, sy, center) {
        var sMatrix = this.outSourceMatrix;
        if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
          var x = center.x,
            y = center.y;
          this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);
        } else this.outTargetMatrix.scale(sx, sy);
        return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
      }
    }, {
      key: "rotateMatrix",
      value: function rotateMatrix(angle, center) {
        var sMatrix = this.outSourceMatrix;
        if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
          var x = center.x,
            y = center.y;
          this.outTargetMatrix.translate(x, y), this.outTargetMatrix.rotate(angle), this.outTargetMatrix.translate(-x, -y);
        } else this.outTargetMatrix.rotate(angle);
        return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
      }
    }, {
      key: "scale",
      value: function scale(sx, sy, center) {
        return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center) : this;
      }
    }, {
      key: "rotate",
      value: function rotate(angle, center) {
        return this.mode === TransformMode.matrix ? this.rotateMatrix(angle, center) : this;
      }
    }, {
      key: "translateMatrix",
      value: function translateMatrix(dx, dy) {
        var sMatrix = this.outSourceMatrix;
        return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
      }
    }, {
      key: "translate",
      value: function translate(dx, dy) {
        return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
      }
    }, {
      key: "simplify",
      value: function simplify(target) {
        return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
      }
    }, {
      key: "simplifyMatrix",
      value: function simplifyMatrix(target) {
        return this;
      }
    }]);
    return DefaultTransformUtil;
  }();
  exports.DefaultTransformUtil = __decorate$1D([injectable(), __metadata$1f("design:paramtypes", [])], exports.DefaultTransformUtil);

  var defaultThemeObj = {
      arc: DefaultArcAttribute,
      area: DefaultAreaAttribute,
      circle: DefaultCircleAttribute,
      line: DefaultLineAttribute,
      path: DefaultPathAttribute,
      symbol: DefaultSymbolAttribute,
      text: DefaultTextAttribute,
      rect: DefaultRectAttribute,
      rect3d: DefaultRect3dAttribute,
      polygon: DefaultPolygonAttribute,
      richtext: DefaultRichTextAttribute,
      richtextIcon: DefaultRichTextIconAttribute,
      image: DefaultImageAttribute,
      group: DefaultGroupAttribute,
      glyph: DefaultGlyphAttribute
    },
    themeKeys = Object.keys(defaultThemeObj);
  function newThemeObj() {
    return {
      arc: Object.assign({}, defaultThemeObj.arc),
      area: Object.assign({}, defaultThemeObj.area),
      circle: Object.assign({}, defaultThemeObj.circle),
      line: Object.assign({}, defaultThemeObj.line),
      path: Object.assign({}, defaultThemeObj.path),
      symbol: Object.assign({}, defaultThemeObj.symbol),
      text: Object.assign({}, defaultThemeObj.text),
      rect: Object.assign({}, defaultThemeObj.rect),
      rect3d: Object.assign({}, defaultThemeObj.rect3d),
      polygon: Object.assign({}, defaultThemeObj.polygon),
      richtext: Object.assign({}, defaultThemeObj.richtext),
      richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
      image: Object.assign({}, defaultThemeObj.image),
      group: Object.assign({}, defaultThemeObj.group),
      glyph: Object.assign({}, defaultThemeObj.glyph)
    };
  }
  function combine(out, t) {
    Object.keys(t).forEach(function (k) {
      out[k] = t[k];
    });
  }
  var globalThemeObj = newThemeObj();
  var Theme = /*#__PURE__*/function () {
    function Theme() {
      _classCallCheck(this, Theme);
      this.initTheme(), this.dirty = !1;
    }
    _createClass(Theme, [{
      key: "initTheme",
      value: function initTheme() {
        var _this = this;
        this._defaultTheme = {}, themeKeys.forEach(function (key) {
          _this._defaultTheme[key] = Object.create(globalThemeObj[key]);
        }), this.combinedTheme = this._defaultTheme;
      }
    }, {
      key: "getTheme",
      value: function getTheme(group) {
        if (!group) return this.combinedTheme;
        if (!this.dirty) return this.combinedTheme;
        var parentTheme = {};
        var parentGroup = this.getParentWithTheme(group);
        return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), this.combinedTheme;
      }
    }, {
      key: "getParentWithTheme",
      value: function getParentWithTheme(group) {
        for (; group.parent;) if ((group = group.parent).theme) return group;
        return null;
      }
    }, {
      key: "applyTheme",
      value: function applyTheme(group, pt) {
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
        if (this.dirty) {
          var parentGroup = this.getParentWithTheme(group);
          if (parentGroup) {
            var parentTheme = parentGroup.theme;
            (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, !0);
          }
          this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, Logger.getInstance().warn("未知错误，走到不应该走的区域里")), this.dirty = !1);
        }
        return this.combinedTheme;
      }
    }, {
      key: "doCombine",
      value: function doCombine(parentCombinedTheme) {
        var _this2 = this;
        var userTheme = this.userTheme,
          combinedTheme = this.combinedTheme;
        themeKeys.forEach(function (k) {
          var obj = Object.create(globalThemeObj[k]);
          parentCombinedTheme && parentCombinedTheme[k] && combine(obj, parentCombinedTheme[k]), combinedTheme[k] && combine(obj, combinedTheme[k]), userTheme[k] && combine(obj, userTheme[k]), _this2.combinedTheme[k] = obj;
        }), userTheme.common && themeKeys.forEach(function (k) {
          combine(_this2.combinedTheme[k], userTheme.common);
        }), this.dirty = !1;
      }
    }, {
      key: "setTheme",
      value: function setTheme(t, g) {
        var userTheme = this.userTheme;
        userTheme ? Object.keys(t).forEach(function (k) {
          userTheme[k] ? Object.assign(userTheme[k], t[k]) : userTheme[k] = Object.assign({}, t[k]);
        }) : userTheme = t, this.userTheme = userTheme, this.dirty = !0, this.dirtyChildren(g);
      }
    }, {
      key: "resetTheme",
      value: function resetTheme(t, g) {
        this.userTheme = t, this.dirty = !0, this.dirtyChildren(g);
      }
    }, {
      key: "dirtyChildren",
      value: function dirtyChildren(g) {
        var _this3 = this;
        g.forEachChildren(function (item) {
          item.isContainer && (item.theme && (item.theme.dirty = !0), _this3.dirtyChildren(item));
        });
      }
    }]);
    return Theme;
  }();
  var globalTheme = new Theme();
  function getTheme(graphic, theme) {
    return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme ? (graphic.isContainer, theme) : getThemeFromGroup(graphic) || graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic) || globalTheme.getTheme();
  }
  function getThemeFromGroup(graphic) {
    var g;
    if (g = graphic.isContainer ? graphic : graphic.parent, g) {
      for (; g && !g.theme;) g = g.parent;
      return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : globalTheme.getTheme();
    }
    return null;
  }

  var __awaiter$5 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Node = /*#__PURE__*/function (_EventEmitter) {
    _inherits(Node, _EventEmitter);
    var _super = _createSuper(Node);
    function Node() {
      var _this;
      _classCallCheck(this, Node);
      _this = _super.call(this), _this._uid = Generator.GenAutoIncrementId(), _this._firstChild = null, _this._lastChild = null, _this.parent = null, _this._count = 1;
      return _this;
    }
    _createClass(Node, [{
      key: "previousSibling",
      get: function get() {
        return this._prev;
      }
    }, {
      key: "nextSibling",
      get: function get() {
        return this._next;
      }
    }, {
      key: "children",
      get: function get() {
        return this.getChildren();
      }
    }, {
      key: "firstChild",
      get: function get() {
        return this._firstChild;
      }
    }, {
      key: "lastChild",
      get: function get() {
        return this._lastChild;
      }
    }, {
      key: "count",
      get: function get() {
        return this._count;
      }
    }, {
      key: "childrenCount",
      get: function get() {
        return this._idMap ? this._idMap.size : 0;
      }
    }, {
      key: "forEachChildren",
      value: function forEachChildren(cb) {
        var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        if (reverse) {
          var child = this._lastChild,
            i = 0;
          for (; child;) {
            if (cb(child, i++)) return;
            child = child._prev;
          }
        } else {
          var _child = this._firstChild,
            _i = 0;
          for (; _child;) {
            if (cb(_child, _i++)) return;
            _child = _child._next;
          }
        }
      }
    }, {
      key: "forEachChildrenAsync",
      value: function forEachChildrenAsync(cb) {
        var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return __awaiter$5(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var child, i, breakTag, _child2, _i2, _breakTag;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!reverse) {
                  _context.next = 16;
                  break;
                }
                child = this._lastChild, i = 0;
              case 2:
                if (!child) {
                  _context.next = 14;
                  break;
                }
                breakTag = cb(child, i++);
                _context.t0 = breakTag.then;
                if (!_context.t0) {
                  _context.next = 9;
                  break;
                }
                _context.next = 8;
                return breakTag;
              case 8:
                breakTag = _context.sent;
              case 9:
                if (!breakTag) {
                  _context.next = 11;
                  break;
                }
                return _context.abrupt("return");
              case 11:
                child = child._prev;
              case 12:
                _context.next = 2;
                break;
              case 14:
                _context.next = 29;
                break;
              case 16:
                _child2 = this._firstChild, _i2 = 0;
              case 17:
                if (!_child2) {
                  _context.next = 29;
                  break;
                }
                _breakTag = cb(_child2, _i2++);
                _context.t1 = _breakTag.then;
                if (!_context.t1) {
                  _context.next = 24;
                  break;
                }
                _context.next = 23;
                return _breakTag;
              case 23:
                _breakTag = _context.sent;
              case 24:
                if (!_breakTag) {
                  _context.next = 26;
                  break;
                }
                return _context.abrupt("return");
              case 26:
                _child2 = _child2._next;
              case 27:
                _context.next = 17;
                break;
              case 29:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
      }
    }, {
      key: "forEach",
      value: function forEach(cb) {
        return this.forEachChildren(cb);
      }
    }, {
      key: "appendChild",
      value: function appendChild(node) {
        var highPerformance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        if (this._uid === node._uid) return null;
        if (!highPerformance && node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
        return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, node._prev = node._next = null), this._idMap || (this._idMap = new Map()), this._idMap.set(node._uid, node), this.setCount(node.count), this._structEdit = !0, node;
      }
    }, {
      key: "appendChildArrHighPerformance",
      value: function appendChildArrHighPerformance(nodes) {
        return console.error("暂不支持该函数"), nodes;
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(newNode, referenceNode) {
        if (!referenceNode) return this.appendChild(newNode);
        if (this._uid === newNode._uid) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
      }
    }, {
      key: "insertAfter",
      value: function insertAfter(newNode, referenceNode) {
        if (!referenceNode) return this.appendChild(newNode);
        if (this._uid === newNode._uid) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, newNode._prev = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
      }
    }, {
      key: "insertInto",
      value: function insertInto(newNode, idx) {
        if (!this._ignoreWarn && this._nodeList && Logger.getInstance().warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), idx >= this.childrenCount) return this.appendChild(newNode);
        if (this._uid === newNode._uid) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
        if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), newNode._prev = null, this._firstChild = newNode;else {
          var child = this._firstChild;
          for (var i = 0; i < idx; i++) {
            if (!child) return null;
            i > 0 && (child = child._next);
          }
          if (!child) return null;
          newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
        }
        return this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode;
      }
    }, {
      key: "insertIntoKeepIdx",
      value: function insertIntoKeepIdx(newNode, idx) {
        if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
          var _node = this._nodeList[idx];
          return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, _node);
        }
        var node;
        this._nodeList[idx] = newNode;
        for (var i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--);
        if (node) return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
        this._ignoreWarn = !0;
        var data = this.insertInto(newNode, 0);
        return this._ignoreWarn = !1, data;
      }
    }, {
      key: "removeChild",
      value: function removeChild(child) {
        if (!this._idMap) return null;
        if (!this._idMap.has(child._uid)) return null;
        if (this._idMap["delete"](child._uid), this._nodeList) {
          var idx = this._nodeList.findIndex(function (n) {
            return n === child;
          });
          idx > 0 && this._nodeList.splice(idx, 1);
        }
        return child._prev ? child._prev._next = child._next : this._firstChild = child._next, child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, child._prev = null, child._next = null, this._structEdit = !0, this.setCount(-child.count), child;
      }
    }, {
      key: "delete",
      value: function _delete() {
        this.parent && this.parent.removeChild(this);
      }
    }, {
      key: "removeAllChild",
      value: function removeAllChild(deep) {
        if (!this._idMap) return;
        var child = this._firstChild;
        for (; child;) {
          var next = child._next;
          child.parent = null, child._prev = null, child._next = null, child = child._next, child = next;
        }
        this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = !0, this.setCount(1 - this._count);
      }
    }, {
      key: "replaceChild",
      value: function replaceChild(newChild, oldChild) {
        throw new Error("暂不支持");
      }
    }, {
      key: "find",
      value: function find(callback) {
        var _this2 = this;
        var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        var target = null;
        return this.forEachChildren(function (node, index) {
          return !(node === _this2 || !callback(node, index)) && (target = node, !0);
        }), deep && this.forEachChildren(function (child) {
          if (child.isContainer) {
            var node = child.find(callback, !0);
            if (node) return target = node, !0;
          }
          return !1;
        }), target;
      }
    }, {
      key: "findAll",
      value: function findAll(callback) {
        var _this3 = this;
        var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        var nodes = [];
        return this.forEachChildren(function (node, index) {
          node !== _this3 && callback(node, index) && nodes.push(node);
        }), deep && this.forEachChildren(function (child) {
          if (child.isContainer) {
            var targets = child.findAll(callback, !0);
            targets.length && (nodes = nodes.concat(targets));
          }
        }), nodes;
      }
    }, {
      key: "getElementById",
      value: function getElementById(id) {
        return this.find(function (node) {
          return node.id === id;
        }, !0);
      }
    }, {
      key: "findChildById",
      value: function findChildById(id) {
        return this.getElementById(id);
      }
    }, {
      key: "findChildByUid",
      value: function findChildByUid(uid) {
        return this._idMap && this._idMap.get(uid) || null;
      }
    }, {
      key: "getElementsByName",
      value: function getElementsByName(name) {
        return this.findAll(function (node) {
          return node.name === name;
        }, !0);
      }
    }, {
      key: "findChildrenByName",
      value: function findChildrenByName(name) {
        return this.getElementsByName(name);
      }
    }, {
      key: "getElementsByType",
      value: function getElementsByType(type) {
        return this.findAll(function (node) {
          return node.type === type;
        }, !0);
      }
    }, {
      key: "getChildByName",
      value: function getChildByName(name) {
        var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        return this.find(function (node) {
          return node.name === name;
        }, deep);
      }
    }, {
      key: "getChildAt",
      value: function getChildAt(idx) {
        var c = this._firstChild;
        if (!c) return null;
        for (var i = 0; i < idx; i++) {
          if (!c._next) return null;
          c = c._next;
        }
        return c;
      }
    }, {
      key: "at",
      value: function at(idx) {
        return this.getChildAt(idx);
      }
    }, {
      key: "containNode",
      value: function containNode(node) {
        if (!this._idMap) return !1;
        if (this._idMap.has(node._uid)) return !0;
        var child = this._firstChild;
        for (; child;) {
          if (child.containNode(node)) return !0;
          child = child._next;
        }
        return !1;
      }
    }, {
      key: "getRootNode",
      value: function getRootNode() {
        var parent = this.parent;
        for (; null == parent ? void 0 : parent.parent;) parent = parent.parent;
        return parent || this;
      }
    }, {
      key: "hasChildNodes",
      value: function hasChildNodes() {
        return null !== this._firstChild;
      }
    }, {
      key: "addChild",
      value: function addChild(node) {
        return this.appendChild(node);
      }
    }, {
      key: "add",
      value: function add(node) {
        return this.appendChild(node);
      }
    }, {
      key: "getChildren",
      value: function getChildren() {
        var nodes = [];
        var child = this._firstChild;
        for (; child;) nodes.push(child), child = child._next;
        return nodes;
      }
    }, {
      key: "isChildOf",
      value: function isChildOf(node) {
        return !!this.parent && this.parent._uid === node._uid;
      }
    }, {
      key: "isParentOf",
      value: function isParentOf(node) {
        return node.isChildOf(this);
      }
    }, {
      key: "isDescendantsOf",
      value: function isDescendantsOf(node) {
        var parent = this.parent;
        if (!parent) return !1;
        do {
          if (parent._uid === node._uid) return !0;
          parent = parent.parent;
        } while (null !== parent);
        return !1;
      }
    }, {
      key: "isAncestorsOf",
      value: function isAncestorsOf(node) {
        return node.isDescendantsOf(this);
      }
    }, {
      key: "getAncestor",
      value: function getAncestor(idx) {
        throw new Error("暂不支持");
      }
    }, {
      key: "setAllDescendantsProps",
      value: function setAllDescendantsProps(propsName, propsValue) {
        var child = this._firstChild;
        for (; child;) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), child = child._next;
      }
    }, {
      key: "setCount",
      value: function setCount(deltaCount) {
        this._count += deltaCount;
        var parent = this.parent;
        if (parent) do {
          parent._count += deltaCount, parent = parent.parent;
        } while (null !== parent);
      }
    }, {
      key: "clone",
      value: function clone() {
        throw new Error("暂不支持");
      }
    }, {
      key: "cloneTo",
      value: function cloneTo(node) {
        throw new Error("暂不支持");
      }
    }, {
      key: "getParent",
      value: function getParent() {
        return this.parent;
      }
    }, {
      key: "del",
      value: function del(child) {
        return this.removeChild(child);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        var capture = isBoolean$1(options, !0) && options || isObject$1(options) && options.capture,
          once = isObject$1(options) && options.once,
          context = isFunction$1(listener) ? void 0 : listener;
        return type = capture ? "".concat(type, "capture") : type, listener = isFunction$1(listener) ? listener : listener.handleEvent, once ? _get(_getPrototypeOf(Node.prototype), "once", this).call(this, type, listener, context) : _get(_getPrototypeOf(Node.prototype), "on", this).call(this, type, listener, context), this;
      }
    }, {
      key: "on",
      value: function on(type, listener, options) {
        return this.addEventListener(type, listener, options);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        var capture = isBoolean$1(options, !0) && options || isObject$1(options) && options.capture,
          context = isFunction$1(listener) ? void 0 : listener;
        type = capture ? "".concat(type, "capture") : type, listener = isFunction$1(listener) ? listener : listener.handleEvent;
        var once = isObject$1(options) && options.once;
        return _get(_getPrototypeOf(Node.prototype), "off", this).call(this, type, listener, context, once), this;
      }
    }, {
      key: "off",
      value: function off(type, listener, options) {
        return this.removeEventListener(type, listener, options);
      }
    }, {
      key: "once",
      value: function once(type, listener, options) {
        return isObject$1(options) ? (options.once = !0, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
          once: !0
        });
      }
    }, {
      key: "removeAllEventListeners",
      value: function removeAllEventListeners() {
        return _get(_getPrototypeOf(Node.prototype), "removeAllListeners", this).call(this), this;
      }
    }, {
      key: "removeAllListeners",
      value: function removeAllListeners() {
        return this.removeAllEventListeners();
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        var _get2;
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return (_get2 = _get(_getPrototypeOf(Node.prototype), "emit", this)).call.apply(_get2, [this, event.type, event].concat(args)), !event.defaultPrevented;
      }
    }, {
      key: "emit",
      value: function emit(event, data) {
        return this.dispatchEvent(event, data);
      }
    }, {
      key: "release",
      value: function release() {
        this.removeAllListeners();
      }
    }]);
    return Node;
  }(EventEmitter);

  var FederatedEvent = /*#__PURE__*/function () {
    function FederatedEvent(manager) {
      _classCallCheck(this, FederatedEvent);
      this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = {
        x: 0,
        y: 0
      }, this.page = {
        x: 0,
        y: 0
      }, this.canvas = {
        x: 0,
        y: 0
      }, this.viewport = {
        x: 0,
        y: 0
      }, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
    }
    _createClass(FederatedEvent, [{
      key: "layerX",
      get: function get() {
        return this.layer.x;
      }
    }, {
      key: "layerY",
      get: function get() {
        return this.layer.y;
      }
    }, {
      key: "pageX",
      get: function get() {
        return this.page.x;
      }
    }, {
      key: "pageY",
      get: function get() {
        return this.page.y;
      }
    }, {
      key: "x",
      get: function get() {
        return this.canvas.x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.canvas.y;
      }
    }, {
      key: "canvasX",
      get: function get() {
        return this.canvas.x;
      }
    }, {
      key: "canvasY",
      get: function get() {
        return this.canvas.y;
      }
    }, {
      key: "viewX",
      get: function get() {
        return this.viewport.x;
      }
    }, {
      key: "viewY",
      get: function get() {
        return this.viewport.y;
      }
    }, {
      key: "composedPath",
      value: function composedPath() {
        return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path;
      }
    }, {
      key: "preventDefault",
      value: function preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0;
      }
    }, {
      key: "stopImmediatePropagation",
      value: function stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0;
      }
    }, {
      key: "stopPropagation",
      value: function stopPropagation() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.stopPropagation(), this.propagationStopped = !0;
      }
    }, {
      key: "initEvent",
      value: function initEvent() {}
    }, {
      key: "initUIEvent",
      value: function initUIEvent() {}
    }, {
      key: "clone",
      value: function clone() {
        throw new Error("Method not implemented.");
      }
    }]);
    return FederatedEvent;
  }();

  var FederatedMouseEvent = /*#__PURE__*/function (_FederatedEvent) {
    _inherits(FederatedMouseEvent, _FederatedEvent);
    var _super = _createSuper(FederatedMouseEvent);
    function FederatedMouseEvent() {
      var _this;
      _classCallCheck(this, FederatedMouseEvent);
      _this = _super.apply(this, arguments), _this.client = {
        x: 0,
        y: 0
      }, _this.movement = {
        x: 0,
        y: 0
      }, _this.offset = {
        x: 0,
        y: 0
      }, _this.global = {
        x: 0,
        y: 0
      }, _this.screen = {
        x: 0,
        y: 0
      };
      return _this;
    }
    _createClass(FederatedMouseEvent, [{
      key: "clientX",
      get: function get() {
        return this.client.x;
      }
    }, {
      key: "clientY",
      get: function get() {
        return this.client.y;
      }
    }, {
      key: "movementX",
      get: function get() {
        return this.movement.x;
      }
    }, {
      key: "movementY",
      get: function get() {
        return this.movement.y;
      }
    }, {
      key: "offsetX",
      get: function get() {
        return this.offset.x;
      }
    }, {
      key: "offsetY",
      get: function get() {
        return this.offset.y;
      }
    }, {
      key: "globalX",
      get: function get() {
        return this.global.x;
      }
    }, {
      key: "globalY",
      get: function get() {
        return this.global.y;
      }
    }, {
      key: "screenX",
      get: function get() {
        return this.screen.x;
      }
    }, {
      key: "screenY",
      get: function get() {
        return this.screen.y;
      }
    }, {
      key: "getModifierState",
      value: function getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
    }, {
      key: "initMouseEvent",
      value: function initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
      }
    }]);
    return FederatedMouseEvent;
  }(FederatedEvent);

  var FederatedPointerEvent = /*#__PURE__*/function (_FederatedMouseEvent) {
    _inherits(FederatedPointerEvent, _FederatedMouseEvent);
    var _super = _createSuper(FederatedPointerEvent);
    function FederatedPointerEvent() {
      var _this;
      _classCallCheck(this, FederatedPointerEvent);
      _this = _super.apply(this, arguments), _this.width = 0, _this.height = 0, _this.isPrimary = !1;
      return _this;
    }
    _createClass(FederatedPointerEvent, [{
      key: "getCoalescedEvents",
      value: function getCoalescedEvents() {
        return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [];
      }
    }, {
      key: "getPredictedEvents",
      value: function getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
    }, {
      key: "clone",
      value: function clone() {
        var _a, _b, _c;
        var event = new FederatedPointerEvent(this.manager);
        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyPointerData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice(), event.type = this.type, event;
      }
    }]);
    return FederatedPointerEvent;
  }(FederatedMouseEvent);

  var FederatedWheelEvent = /*#__PURE__*/function (_FederatedMouseEvent) {
    _inherits(FederatedWheelEvent, _FederatedMouseEvent);
    var _super = _createSuper(FederatedWheelEvent);
    function FederatedWheelEvent() {
      var _this;
      _classCallCheck(this, FederatedWheelEvent);
      _this = _super.apply(this, arguments), _this.DOM_DELTA_PIXEL = 0, _this.DOM_DELTA_LINE = 1, _this.DOM_DELTA_PAGE = 2;
      return _this;
    }
    _createClass(FederatedWheelEvent, [{
      key: "clone",
      value: function clone() {
        var _a, _b, _c;
        var event = new FederatedWheelEvent(this.manager);
        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyWheelData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice(), event.type = this.type, event;
      }
    }]);
    return FederatedWheelEvent;
  }(FederatedMouseEvent);
  FederatedWheelEvent.DOM_DELTA_PIXEL = 0, FederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;

  var CustomEvent = /*#__PURE__*/function (_FederatedEvent) {
    _inherits(CustomEvent, _FederatedEvent);
    var _super = _createSuper(CustomEvent);
    function CustomEvent(eventName, object) {
      var _this;
      _classCallCheck(this, CustomEvent);
      _this = _super.call(this), _this.type = eventName, _this.detail = object;
      return _this;
    }
    return _createClass(CustomEvent);
  }(FederatedEvent);

  var WILDCARD = "*";

  var clock = "object" == (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && performance.now ? performance : Date;

  function isMouseLike(pointerType) {
    return "mouse" === pointerType || "pen" === pointerType;
  }
  var EventManager = /*#__PURE__*/function () {
    function EventManager(root, config) {
      var _this = this;
      _classCallCheck(this, EventManager);
      this.dispatch = new EventEmitter(), this.cursorTarget = null, this.mappingState = {
        trackingData: {}
      }, this.eventPool = new Map(), this.onPointerDown = function (from, target) {
        if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
        var e = _this.createPointerEvent(from, from.type, target);
        if (_this.dispatchEvent(e, "pointerdown"), "touch" === e.pointerType) _this.dispatchEvent(e, "touchstart");else if (isMouseLike(e.pointerType)) {
          var isRightButton = 2 === e.button;
          _this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
        }
        _this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e.composedPath(), _this.freeEvent(e);
      }, this.onPointerMove = function (from, target) {
        var _a, _b;
        if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
        var e = _this.createPointerEvent(from, from.type, target),
          isMouse = isMouseLike(e.pointerType),
          trackingData = _this.trackingData(from.pointerId),
          outTarget = _this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets && outTarget && outTarget !== _this.rootTarget && outTarget !== e.target) {
          var outType = "mousemove" === from.type ? "mouseout" : "pointerout",
            outEvent = _this.createPointerEvent(from, outType, outTarget || void 0);
          if (_this.dispatchEvent(outEvent, "pointerout"), isMouse && _this.dispatchEvent(outEvent, "mouseout"), !e.composedPath().includes(outTarget)) {
            var leaveEvent = _this.createPointerEvent(from, "pointerleave", outTarget || void 0);
            for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target);) leaveEvent.currentTarget = leaveEvent.target, _this.notifyTarget(leaveEvent), isMouse && _this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
            _this.freeEvent(leaveEvent);
          }
          _this.freeEvent(outEvent);
        }
        if (outTarget !== e.target) {
          var overType = "mousemove" === from.type ? "mouseover" : "pointerover",
            overEvent = _this.clonePointerEvent(e, overType);
          _this.dispatchEvent(overEvent, "pointerover"), isMouse && _this.dispatchEvent(overEvent, "mouseover");
          var overTargetAncestor = null == outTarget ? void 0 : outTarget.parent;
          for (; overTargetAncestor && overTargetAncestor !== _this.rootTarget.parent && overTargetAncestor !== e.target;) overTargetAncestor = overTargetAncestor.parent;
          if (!overTargetAncestor || overTargetAncestor === _this.rootTarget.parent) {
            var enterEvent = _this.clonePointerEvent(e, "pointerenter");
            for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== _this.rootTarget.parent;) enterEvent.currentTarget = enterEvent.target, _this.notifyTarget(enterEvent), isMouse && _this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
            _this.freeEvent(enterEvent);
          }
          _this.freeEvent(overEvent);
        }
        _this.dispatchEvent(e, "pointermove"), "touch" === e.pointerType && _this.dispatchEvent(e, "touchmove"), isMouse && (_this.dispatchEvent(e, "mousemove"), _this.cursorTarget = e.target, _this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || _this.rootTarget.getCursor()), trackingData.overTargets = e.composedPath(), _this.freeEvent(e);
      }, this.onPointerOver = function (from, target) {
        var _a, _b;
        if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
        var trackingData = _this.trackingData(from.pointerId),
          e = _this.createPointerEvent(from, from.type, target),
          isMouse = isMouseLike(e.pointerType);
        _this.dispatchEvent(e, "pointerover"), isMouse && _this.dispatchEvent(e, "mouseover"), "mouse" === e.pointerType && (_this.cursorTarget = e.target, _this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || _this.rootTarget.getCursor());
        var enterEvent = _this.clonePointerEvent(e, "pointerenter");
        for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== _this.rootTarget.parent;) enterEvent.currentTarget = enterEvent.target, _this.notifyTarget(enterEvent), isMouse && _this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
        trackingData.overTargets = e.composedPath(), _this.freeEvent(e), _this.freeEvent(enterEvent);
      }, this.onPointerOut = function (from, target) {
        if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
        var trackingData = _this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          var isMouse = isMouseLike(from.pointerType),
            outTarget = _this.findMountedTarget(trackingData.overTargets),
            outEvent = _this.createPointerEvent(from, "pointerout", outTarget || void 0);
          _this.dispatchEvent(outEvent), isMouse && _this.dispatchEvent(outEvent, "mouseout");
          var leaveEvent = _this.createPointerEvent(from, "pointerleave", outTarget || void 0);
          for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== _this.rootTarget.parent;) leaveEvent.currentTarget = leaveEvent.target, _this.notifyTarget(leaveEvent), isMouse && _this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
          trackingData.overTargets = [], _this.freeEvent(outEvent), _this.freeEvent(leaveEvent);
        }
        _this.cursorTarget = null, _this.cursor = "";
      }, this.onPointerUp = function (from, target) {
        var _a;
        if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
        var now = clock.now(),
          e = _this.createPointerEvent(from, from.type, target);
        if (_this.dispatchEvent(e, "pointerup"), "touch" === e.pointerType) _this.dispatchEvent(e, "touchend");else if (isMouseLike(e.pointerType)) {
          var isRightButton = 2 === e.button;
          _this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
        }
        var trackingData = _this.trackingData(from.pointerId),
          pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        var clickTarget = pressTarget;
        if (pressTarget && !e.composedPath().includes(pressTarget)) {
          var currentTarget = pressTarget;
          for (; currentTarget && !e.composedPath().includes(currentTarget);) {
            if (e.currentTarget = currentTarget, _this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType) _this.notifyTarget(e, "touchendoutside");else if (isMouseLike(e.pointerType)) {
              var _isRightButton = 2 === e.button;
              _this.notifyTarget(e, _isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
        }
        if (clickTarget) {
          var clickEvent = _this.clonePointerEvent(e, "click");
          clickEvent.target = clickTarget, clickEvent.path = [], trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
            clickCount: 0,
            target: clickEvent.target,
            timeStamp: now
          });
          var clickHistory = trackingData.clicksByButton[from.button];
          clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < (null !== (_a = _this._config.clickInterval) && void 0 !== _a ? _a : 200) ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, isMouseLike(clickEvent.pointerType) ? (_this.dispatchEvent(clickEvent, "click"), 2 === clickHistory.clickCount && _this.dispatchEvent(clickEvent, "dblclick")) : "touch" === clickEvent.pointerType && (_this.dispatchEvent(clickEvent, "tap"), 2 === clickHistory.clickCount && _this.dispatchEvent(clickEvent, "dbltap")), _this.dispatchEvent(clickEvent, "pointertap"), _this.freeEvent(clickEvent);
        }
        _this.freeEvent(e);
      }, this.onPointerUpOutside = function (from, target) {
        if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
        var trackingData = _this.trackingData(from.pointerId),
          pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]),
          e = _this.createPointerEvent(from, from.type, target);
        if (pressTarget) {
          var currentTarget = pressTarget;
          for (; currentTarget;) e.currentTarget = currentTarget, _this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType ? _this.notifyTarget(e, "touchendoutside") : isMouseLike(e.pointerType) && _this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
          delete trackingData.pressTargetsByButton[from.button];
        }
        _this.freeEvent(e);
      }, this.onWheel = function (from, target) {
        if (!(from instanceof FederatedWheelEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-wheel event as a wheel event");
        var wheelEvent = _this.createWheelEvent(from, target);
        _this.dispatchEvent(wheelEvent), _this.freeEvent(wheelEvent);
      }, this.rootTarget = root, this.mappingTable = {}, this._config = Object.assign({
        clickInterval: 200
      }, config), this.addEventMapping("pointerdown", this.onPointerDown), this.addEventMapping("pointermove", this.onPointerMove), this.addEventMapping("pointerout", this.onPointerOut), this.addEventMapping("pointerleave", this.onPointerOut), this.addEventMapping("pointerover", this.onPointerOver), this.addEventMapping("pointerup", this.onPointerUp), this.addEventMapping("pointerupoutside", this.onPointerUpOutside), this.addEventMapping("wheel", this.onWheel);
    }
    _createClass(EventManager, [{
      key: "addEventMapping",
      value: function addEventMapping(type, fn) {
        this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
          fn: fn,
          priority: 0
        }), this.mappingTable[type].sort(function (a, b) {
          return a.priority - b.priority;
        });
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(e, type) {
        e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, type), this.dispatch.emit(type || e.type, e);
      }
    }, {
      key: "mapEvent",
      value: function mapEvent(e) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.rootTarget) return;
        var mappers = this.mappingTable[e.type];
        var target;
        var cacheKey = "".concat(e.canvasX, "-").concat(e.canvasY);
        if ((null === (_a = this._prePointTargetCache) || void 0 === _a ? void 0 : _a[cacheKey]) && (null === (_c = null === (_b = this._prePointTargetCache) || void 0 === _b ? void 0 : _b[cacheKey]) || void 0 === _c ? void 0 : _c.stage) && (null === (_e = null === (_d = this._prePointTargetCache) || void 0 === _d ? void 0 : _d[cacheKey]) || void 0 === _e ? void 0 : _e.stage.renderCount) === (null === (_f = this._prePointTargetCache) || void 0 === _f ? void 0 : _f.stageRenderCount) ? target = this._prePointTargetCache[cacheKey] : (target = this.pickTarget(e.viewX, e.viewY, e), e.pickParams || (this._prePointTargetCache = _defineProperty(_defineProperty({}, cacheKey, target), "stageRenderCount", null !== (_g = null == target ? void 0 : target.stage.renderCount) && void 0 !== _g ? _g : -1))), mappers) for (var i = 0, j = mappers.length; i < j; i++) mappers[i].fn(e, target);else Logger.getInstance().warn("[EventManager]: Event mapping not defined for ".concat(e.type));
      }
    }, {
      key: "propagate",
      value: function propagate(e, type) {
        if (!e.target) return;
        var composedPath = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (var i = 0, j = composedPath.length - 1; i < j; i++) if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
        if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !e.propagationStopped && !e.propagationImmediatelyStopped) {
          e.eventPhase = e.BUBBLING_PHASE;
          for (var _i = composedPath.length - 2; _i >= 0; _i--) if (e.currentTarget = composedPath[_i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
        }
      }
    }, {
      key: "propagationPath",
      value: function propagationPath(target) {
        var propagationPath = [target];
        for (var i = 0; i < 2048 && target !== this.rootTarget && target.parent; i++) {
          if (!target.parent) throw new Error("Cannot find propagation path to disconnected target");
          propagationPath.push(target.parent), target = target.parent;
        }
        return propagationPath.reverse(), propagationPath;
      }
    }, {
      key: "notifyTarget",
      value: function notifyTarget(e, type) {
        type = null != type ? type : e.type;
        var key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? "".concat(type, "capture") : type;
        this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);
      }
    }, {
      key: "findMountedTarget",
      value: function findMountedTarget(propagationPath) {
        if (!propagationPath) return null;
        var currentTarget = propagationPath[0];
        for (var i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++) currentTarget = propagationPath[i];
        return currentTarget;
      }
    }, {
      key: "createPointerEvent",
      value: function createPointerEvent(from, type, target) {
        var _a, _b;
        var event = this.allocateEvent(FederatedPointerEvent);
        return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), "string" == typeof type && (event.type = type), event;
      }
    }, {
      key: "createWheelEvent",
      value: function createWheelEvent(from, target) {
        var _a, _b;
        var event = this.allocateEvent(FederatedWheelEvent);
        return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), event;
      }
    }, {
      key: "clonePointerEvent",
      value: function clonePointerEvent(from, type) {
        var event = this.allocateEvent(FederatedPointerEvent);
        return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice(), event.type = null != type ? type : event.type, event;
      }
    }, {
      key: "copyWheelData",
      value: function copyWheelData(from, to) {
        to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;
      }
    }, {
      key: "copyPointerData",
      value: function copyPointerData(from, to) {
        from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
      }
    }, {
      key: "copyMouseData",
      value: function copyMouseData(from, to) {
        from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.ctrlKey = from.ctrlKey, to.shiftKey = from.shiftKey, to.metaKey = from.metaKey, ["client", "movement", "canvas", "screen", "global", "offset", "viewport"].forEach(function (key) {
          to[key].x = from[key].x, to[key].y = from[key].y;
        }));
      }
    }, {
      key: "copyData",
      value: function copyData(from, to) {
        to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = clock.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.x = from.layer.x, to.layer.y = from.layer.y, to.page.x = from.page.x, to.page.y = from.page.y, to.pickParams = from.pickParams;
      }
    }, {
      key: "trackingData",
      value: function trackingData(id) {
        return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null
        }), this.mappingState.trackingData[id];
      }
    }, {
      key: "allocateEvent",
      value: function allocateEvent(constructor) {
        var _a;
        this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
        var event = (null === (_a = this.eventPool.get(constructor)) || void 0 === _a ? void 0 : _a.pop()) || new constructor(this);
        return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.target = null, event;
      }
    }, {
      key: "freeEvent",
      value: function freeEvent(event) {
        var _a;
        if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventManager!");
        var constructor = event.constructor;
        this.eventPool.has(constructor) || this.eventPool.set(constructor, []), null === (_a = this.eventPool.get(constructor)) || void 0 === _a || _a.push(event);
      }
    }, {
      key: "notifyListeners",
      value: function notifyListeners(e, type) {
        var listeners = e.currentTarget._events[type];
        if (listeners) if ("fn" in listeners) listeners.once && e.currentTarget.removeEventListener(type, listeners.fn, {
          once: !0
        }), listeners.fn.call(listeners.context, e);else for (var i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].once && e.currentTarget.removeEventListener(type, listeners[i].fn, {
          once: !0
        }), listeners[i].fn.call(listeners[i].context, e);
        this.emitDelegation(e, type);
      }
    }, {
      key: "emitDelegation",
      value: function emitDelegation(e, type) {
        var listeners = e.currentTarget._events[WILDCARD];
        if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);else for (var i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
      }
    }, {
      key: "pickTarget",
      value: function pickTarget(x, y, e) {
        var target;
        var pickResult = this.rootTarget.pick(x, y);
        return target = pickResult && pickResult.graphic ? pickResult.graphic : pickResult && pickResult.group ? pickResult.group : this.rootTarget.AABBBounds.contains(x, y) ? this.rootTarget : null, e && (e.pickParams = pickResult.params), target;
      }
    }, {
      key: "release",
      value: function release() {
        this.dispatch.removeAllListeners(), this.eventPool.clear(), this.rootTarget = null, this.mappingTable = null, this.mappingState = null, this.cursorTarget = null;
      }
    }]);
    return EventManager;
  }();

  var EventTarget = {
    pickable: !0,
    visible: !0,
    dispatchEvent: function dispatchEvent(e) {
      var _a;
      if (!(e instanceof FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
      return e.defaultPrevented = !1, e.path = [], e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), !e.defaultPrevented;
    },
    emit: function emit(eventName, object) {
      return this.dispatchEvent(new CustomEvent(eventName, object));
    }
  };

  var TOUCH_TO_POINTER = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel"
    };
  var EventSystem = /*#__PURE__*/function () {
    function EventSystem(params) {
      var _this = this;
      _classCallCheck(this, EventSystem);
      this.resolution = 1, this.onPointerDown = function (nativeEvent) {
        if (_this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
        var events = _this.normalizeToPointerData(nativeEvent);
        if (_this.autoPreventDefault && events[0].isNormalized) {
          (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
        }
        for (var i = 0, j = events.length; i < j; i++) {
          var _nativeEvent = events[i],
            federatedEvent = _this.bootstrapEvent(_this.rootPointerEvent, _nativeEvent);
          _this.manager.mapEvent(federatedEvent);
        }
        _this.setCursor(_this.manager.cursor, _this.manager.cursorTarget);
      }, this.onPointerMove = function (nativeEvent) {
        if (_this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
        if (_this.isEventOutsideOfTargetElement(nativeEvent)) return;
        var normalizedEvents = _this.normalizeToPointerData(nativeEvent);
        for (var i = 0, j = normalizedEvents.length; i < j; i++) {
          var event = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvents[i]);
          _this.manager.mapEvent(event);
        }
        _this.setCursor(_this.manager.cursor, _this.manager.cursorTarget);
      }, this.onPointerUp = function (nativeEvent) {
        if (_this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
        var outside = _this.isEventOutsideOfTargetViewPort(nativeEvent) ? "outside" : "",
          normalizedEvents = _this.normalizeToPointerData(nativeEvent);
        for (var i = 0, j = normalizedEvents.length; i < j; i++) {
          var event = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvents[i]);
          event.type += outside, _this.manager.mapEvent(event);
        }
        _this.setCursor(_this.manager.cursor, _this.manager.cursorTarget);
      }, this.onPointerOverOut = function (nativeEvent) {
        if (_this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
        var normalizedEvents = _this.normalizeToPointerData(nativeEvent);
        for (var i = 0, j = normalizedEvents.length; i < j; i++) {
          var event = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvents[i]);
          _this.manager.mapEvent(event);
        }
        _this.setCursor(_this.manager.cursor, _this.manager.cursorTarget);
      }, this.onWheel = function (nativeEvent) {
        var wheelEvent = _this.normalizeWheelEvent(nativeEvent);
        _this.manager.mapEvent(wheelEvent);
      };
      var targetElement = params.targetElement,
        resolution = params.resolution,
        rootNode = params.rootNode,
        global = params.global,
        _params$autoPreventDe = params.autoPreventDefault,
        autoPreventDefault = _params$autoPreventDe === void 0 ? !1 : _params$autoPreventDe,
        clickInterval = params.clickInterval,
        _params$supportsTouch = params.supportsTouchEvents,
        supportsTouchEvents = _params$supportsTouch === void 0 ? global.supportsTouchEvents : _params$supportsTouch,
        _params$supportsPoint = params.supportsPointerEvents,
        supportsPointerEvents = _params$supportsPoint === void 0 ? global.supportsPointerEvents : _params$supportsPoint;
      this.manager = new EventManager(rootNode, {
        clickInterval: clickInterval
      }), this.globalObj = global, this.supportsPointerEvents = supportsPointerEvents, this.supportsTouchEvents = supportsTouchEvents, this.supportsMouseEvents = global.supportsMouseEvents, this.applyStyles = global.applyStyles, this.autoPreventDefault = autoPreventDefault, this.eventsAdded = !1, this.rootPointerEvent = new FederatedPointerEvent(), this.rootWheelEvent = new FederatedWheelEvent(), this.cursorStyles = {
        "default": "inherit",
        pointer: "pointer"
      }, this.resolution = resolution, this.setTargetElement(targetElement);
    }
    _createClass(EventSystem, [{
      key: "release",
      value: function release() {
        this.removeEvents(), this.manager && this.manager.release(), this.domElement = null, this.manager = null, this.globalObj = null;
      }
    }, {
      key: "setCursor",
      value: function setCursor(mode, target) {
        if (!target && !this.manager.rootTarget.window._handler.canvas.controled) return;
        mode || (mode = "default");
        var applyStyles = this.applyStyles,
          domElement = this.domElement;
        if (this.currentCursor === mode) return;
        this.currentCursor = mode;
        var style = this.cursorStyles[mode];
        style ? "string" == typeof style && applyStyles ? domElement.style.cursor = style : "function" == typeof style ? style(mode) : "object" == _typeof(style) && applyStyles && Object.assign(domElement.style, style) : applyStyles && isString$1(mode) && !has$1(this.cursorStyles, mode) && (domElement.style.cursor = mode);
      }
    }, {
      key: "setTargetElement",
      value: function setTargetElement(element) {
        this.removeEvents(), this.domElement = element, this.addEvents();
      }
    }, {
      key: "addEvents",
      value: function addEvents() {
        if (this.eventsAdded || !this.domElement) return;
        var globalObj = this.globalObj,
          domElement = this.domElement;
        this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("pointermove", this.onPointerMove, !0), globalObj.getDocument().addEventListener("pointerup", this.onPointerUp, !0)) : (domElement.addEventListener("pointermove", this.onPointerMove, !0), domElement.addEventListener("pointerup", this.onPointerUp, !0)), domElement.addEventListener("pointerdown", this.onPointerDown, !0), domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), domElement.addEventListener("pointerover", this.onPointerOverOut, !0)) : (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("mousemove", this.onPointerMove, !0), globalObj.getDocument().addEventListener("mouseup", this.onPointerUp, !0)) : (domElement.addEventListener("mousemove", this.onPointerMove, !0), domElement.addEventListener("mouseup", this.onPointerUp, !0)), domElement.addEventListener("mousedown", this.onPointerDown, !0), domElement.addEventListener("mouseout", this.onPointerOverOut, !0), domElement.addEventListener("mouseover", this.onPointerOverOut, !0)), this.supportsTouchEvents && (domElement.addEventListener("touchstart", this.onPointerDown, !0), domElement.addEventListener("touchend", this.onPointerUp, !0), domElement.addEventListener("touchmove", this.onPointerMove, !0)), domElement.addEventListener("wheel", this.onWheel, {
          capture: !0
        }), this.eventsAdded = !0;
      }
    }, {
      key: "removeEvents",
      value: function removeEvents() {
        if (!this.eventsAdded || !this.domElement) return;
        var globalObj = this.globalObj,
          domElement = this.domElement;
        this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener("pointermove", this.onPointerMove, !0), globalObj.getDocument().removeEventListener("pointerup", this.onPointerUp, !0)) : (domElement.removeEventListener("pointermove", this.onPointerMove, !0), domElement.removeEventListener("pointerup", this.onPointerUp, !0)), domElement.removeEventListener("pointerdown", this.onPointerDown, !0), domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), domElement.removeEventListener("pointerover", this.onPointerOverOut, !0)) : (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener("mousemove", this.onPointerMove, !0), globalObj.getDocument().removeEventListener("mouseup", this.onPointerUp, !0)) : (domElement.removeEventListener("mousemove", this.onPointerMove, !0), domElement.removeEventListener("mouseup", this.onPointerUp, !0)), domElement.removeEventListener("mousedown", this.onPointerDown, !0), domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), domElement.removeEventListener("mouseover", this.onPointerOverOut, !0)), this.supportsTouchEvents && (domElement.removeEventListener("touchstart", this.onPointerDown, !0), domElement.removeEventListener("touchend", this.onPointerUp, !0), domElement.removeEventListener("touchmove", this.onPointerMove, !0)), domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1;
      }
    }, {
      key: "mapToViewportPoint",
      value: function mapToViewportPoint(event) {
        return this.domElement.pointTransform ? this.domElement.pointTransform(event.x, event.y) : event;
      }
    }, {
      key: "mapToCanvasPoint",
      value: function mapToCanvasPoint(nativeEvent) {
        var _a, _b;
        var point = null === (_a = this.globalObj) || void 0 === _a ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);
        if (point) return point;
        var x = 0,
          y = 0;
        if (nativeEvent.changedTouches) {
          var data = null !== (_b = nativeEvent.changedTouches[0]) && void 0 !== _b ? _b : {};
          x = data.clientX || 0, y = data.clientY || 0;
        } else x = nativeEvent.clientX || 0, y = nativeEvent.clientY || 0;
        var rect = this.domElement.getBoundingClientRect();
        return {
          x: x - rect.left,
          y: y - rect.top
        };
      }
    }, {
      key: "normalizeToPointerData",
      value: function normalizeToPointerData(event) {
        var normalizedEvents = [];
        if (this.supportsTouchEvents && event.changedTouches && event.changedTouches.length) for (var i = 0, li = event.changedTouches.length; i < li; i++) {
          var touch = event.changedTouches[i];
          isUndefined$1(touch.button) && (touch.button = 0), isUndefined$1(touch.buttons) && (touch.buttons = 1), isUndefined$1(touch.isPrimary) && (touch.isPrimary = 1 === event.touches.length && "touchstart" === event.type), isUndefined$1(touch.width) && (touch.width = touch.radiusX || 1), isUndefined$1(touch.height) && (touch.height = touch.radiusY || 1), isUndefined$1(touch.tiltX) && (touch.tiltX = 0), isUndefined$1(touch.tiltY) && (touch.tiltY = 0), isUndefined$1(touch.pointerType) && (touch.pointerType = "touch"), isUndefined$1(touch.pointerId) && (touch.pointerId = touch.identifier || 0), isUndefined$1(touch.pressure) && (touch.pressure = touch.force || .5), isUndefined$1(touch.twist) && (touch.twist = 0), isUndefined$1(touch.tangentialPressure) && (touch.tangentialPressure = 0), isUndefined$1(touch.layerX) && (touch.layerX = touch.offsetX = touch.clientX), isUndefined$1(touch.layerY) && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = !0, touch.type = event.type, normalizedEvents.push(touch);
        } else if (this.globalObj.supportsMouseEvents && (!(event instanceof MouseEvent) || this.supportsPointerEvents && event instanceof PointerEvent)) normalizedEvents.push(event);else {
          var tempEvent = event;
          isUndefined$1(tempEvent.isPrimary) && (tempEvent.isPrimary = !0), isUndefined$1(tempEvent.width) && (tempEvent.width = 1), isUndefined$1(tempEvent.height) && (tempEvent.height = 1), isUndefined$1(tempEvent.tiltX) && (tempEvent.tiltX = 0), isUndefined$1(tempEvent.tiltY) && (tempEvent.tiltY = 0), isUndefined$1(tempEvent.pointerType) && (tempEvent.pointerType = "mouse"), isUndefined$1(tempEvent.pointerId) && (tempEvent.pointerId = 1), isUndefined$1(tempEvent.pressure) && (tempEvent.pressure = .5), isUndefined$1(tempEvent.twist) && (tempEvent.twist = 0), isUndefined$1(tempEvent.tangentialPressure) && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = !0, normalizedEvents.push(tempEvent);
        }
        return normalizedEvents;
      }
    }, {
      key: "normalizeWheelEvent",
      value: function normalizeWheelEvent(nativeEvent) {
        var event = this.rootWheelEvent;
        this.transferMouseData(event, nativeEvent), event.deltaMode = nativeEvent.deltaMode, event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ;
        var _this$mapToCanvasPoin = this.mapToCanvasPoint(nativeEvent),
          canvasX = _this$mapToCanvasPoin.x,
          canvasY = _this$mapToCanvasPoin.y;
        event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
        var _this$mapToViewportPo = this.mapToViewportPoint(event),
          viewX = _this$mapToViewportPo.x,
          viewY = _this$mapToViewportPo.y;
        return event.viewport.x = viewX, event.viewport.y = viewY, event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;
      }
    }, {
      key: "bootstrapEvent",
      value: function bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent);
        var _this$mapToCanvasPoin2 = this.mapToCanvasPoint(nativeEvent),
          canvasX = _this$mapToCanvasPoin2.x,
          canvasY = _this$mapToCanvasPoin2.y;
        event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
        var _this$mapToViewportPo2 = this.mapToViewportPoint(event),
          viewX = _this$mapToViewportPo2.x,
          viewY = _this$mapToViewportPo2.y;
        return event.viewport.x = viewX, event.viewport.y = viewY, event.isTrusted = nativeEvent.isTrusted, "pointerleave" === event.type && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;
      }
    }, {
      key: "transferMouseData",
      value: function transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = clock.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.shiftKey = nativeEvent.shiftKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null;
      }
    }, {
      key: "isEventOutsideOfTargetViewPort",
      value: function isEventOutsideOfTargetViewPort(nativeEvent) {
        if (this.isEventOutsideOfTargetElement(nativeEvent)) return !0;
        if (this.domElement.getViewBox) {
          var p = this.mapToViewportPoint(this.mapToCanvasPoint(nativeEvent)),
            b = this.domElement.getViewBox(),
            w = b.width(),
            h = b.height();
          return !(p.x < w && p.y < h && p.x > 0 && p.y > 0);
        }
        return !1;
      }
    }, {
      key: "isEventOutsideOfTargetElement",
      value: function isEventOutsideOfTargetElement(nativeEvent) {
        var target = nativeEvent.target;
        nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
        return target !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement);
      }
    }]);
    return EventSystem;
  }();

  var ManualTickHandler = /*#__PURE__*/function () {
    function ManualTickHandler() {
      _classCallCheck(this, ManualTickHandler);
      this.time = 0;
    }
    _createClass(ManualTickHandler, [{
      key: "avaliable",
      value: function avaliable() {
        return ManualTickHandler.Avaliable();
      }
    }, {
      key: "tick",
      value: function tick(interval, cb) {
        this.time = Math.max(0, interval + this.time), cb(this, {
          once: !0
        });
      }
    }, {
      key: "tickTo",
      value: function tickTo(t, cb) {
        this.time = Math.max(0, t), cb(this, {
          once: !0
        });
      }
    }, {
      key: "release",
      value: function release() {
        this.timerId > 0 && (this.timerId = -1);
      }
    }, {
      key: "getTime",
      value: function getTime() {
        return this.time;
      }
    }], [{
      key: "Avaliable",
      value: function Avaliable() {
        return !0;
      }
    }]);
    return ManualTickHandler;
  }();
  var TimeOutTickHandler = /*#__PURE__*/function () {
    function TimeOutTickHandler() {
      _classCallCheck(this, TimeOutTickHandler);
    }
    _createClass(TimeOutTickHandler, [{
      key: "avaliable",
      value: function avaliable() {
        return TimeOutTickHandler.Avaliable();
      }
    }, {
      key: "tick",
      value: function tick(interval, cb) {
        var _this = this;
        this.timerId = setTimeout(function () {
          cb(_this);
        }, interval);
      }
    }, {
      key: "release",
      value: function release() {
        this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);
      }
    }, {
      key: "getTime",
      value: function getTime() {
        return Date.now();
      }
    }], [{
      key: "Avaliable",
      value: function Avaliable() {
        return !0;
      }
    }]);
    return TimeOutTickHandler;
  }();
  var RAFTickHandler = /*#__PURE__*/function () {
    function RAFTickHandler() {
      _classCallCheck(this, RAFTickHandler);
    }
    _createClass(RAFTickHandler, [{
      key: "avaliable",
      value: function avaliable() {
        return RAFTickHandler.Avaliable();
      }
    }, {
      key: "tick",
      value: function tick(interval, cb) {
        var _this2 = this;
        application.global.getRequestAnimationFrame()(function () {
          _this2.released || cb(_this2);
        });
      }
    }, {
      key: "release",
      value: function release() {
        this.released = !0;
      }
    }, {
      key: "getTime",
      value: function getTime() {
        return Date.now();
      }
    }], [{
      key: "Avaliable",
      value: function Avaliable() {
        return !!application.global.getRequestAnimationFrame();
      }
    }]);
    return RAFTickHandler;
  }();
  var STATUS$1;
  !function (STATUS) {
    STATUS[STATUS.INITIAL = 0] = "INITIAL", STATUS[STATUS.RUNNING = 1] = "RUNNING", STATUS[STATUS.PAUSE = 2] = "PAUSE";
  }(STATUS$1 || (STATUS$1 = {}));
  var DefaultTicker = /*#__PURE__*/function () {
    function DefaultTicker() {
      var _this3 = this;
      var timelines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      _classCallCheck(this, DefaultTicker);
      this.handleTick = function (handler, params) {
        var _ref = null != params ? params : {},
          _ref$once = _ref.once,
          once = _ref$once === void 0 ? !1 : _ref$once;
        _this3.ifCanStop() ? _this3.stop() : (_this3._handlerTick(handler), once || handler.tick(_this3.interval, _this3.handleTick));
      }, this._handlerTick = function (handler) {
        var time = _this3.tickerHandler.getTime();
        var delta = 0;
        _this3.lastFrameTime >= 0 && (delta = time - _this3.lastFrameTime), _this3.lastFrameTime = time, _this3.status === STATUS$1.RUNNING && (_this3.tickCounts++, _this3.timelines.forEach(function (t) {
          t.tick(delta);
        }));
      }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, this.autoStop = !0;
    }
    _createClass(DefaultTicker, [{
      key: "mode",
      get: function get() {
        return this._mode;
      },
      set: function set(m) {
        this._mode !== m && (this._mode = m, this.setupTickHandler());
      }
    }, {
      key: "init",
      value: function init() {
        var _this4 = this;
        this.interval = NaN, this.status = STATUS$1.INITIAL, application.global.hooks.onSetEnv.tap("default-ticker", function () {
          _this4.initHandler();
        }), application.global.env && this.initHandler();
      }
    }, {
      key: "addTimeline",
      value: function addTimeline(timeline) {
        this.timelines.push(timeline);
      }
    }, {
      key: "remTimeline",
      value: function remTimeline(timeline) {
        this.timelines = this.timelines.filter(function (t) {
          return t !== timeline;
        });
      }
    }, {
      key: "initHandler",
      value: function initHandler() {
        if (this._mode) return null;
        var ticks = [{
          mode: "raf",
          cons: RAFTickHandler
        }, {
          mode: "timeout",
          cons: TimeOutTickHandler
        }, {
          mode: "manual",
          cons: ManualTickHandler
        }];
        for (var i = 0; i < ticks.length; i++) if (ticks[i].cons.Avaliable()) {
          this.mode = ticks[i].mode;
          break;
        }
        return null;
      }
    }, {
      key: "setupTickHandler",
      value: function setupTickHandler() {
        var handler;
        switch (this._mode) {
          case "raf":
            handler = new RAFTickHandler();
            break;
          case "timeout":
            handler = new TimeOutTickHandler();
            break;
          case "manual":
            handler = new ManualTickHandler();
            break;
          default:
            Logger.getInstance().warn("非法的计时器模式"), handler = new RAFTickHandler();
        }
        return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, !0);
      }
    }, {
      key: "setInterval",
      value: function setInterval(interval) {
        this.interval = interval;
      }
    }, {
      key: "getInterval",
      value: function getInterval() {
        return this.interval;
      }
    }, {
      key: "setFPS",
      value: function setFPS(fps) {
        this.setInterval(1e3 / fps);
      }
    }, {
      key: "getFPS",
      value: function getFPS() {
        return 1e3 / this.interval;
      }
    }, {
      key: "tick",
      value: function tick(interval) {
        var _this5 = this;
        this.tickerHandler.tick(interval, function (handler) {
          _this5.handleTick(handler, {
            once: !0
          });
        });
      }
    }, {
      key: "tickTo",
      value: function tickTo(t) {
        var _this6 = this;
        this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, function (handler) {
          _this6.handleTick(handler, {
            once: !0
          });
        });
      }
    }, {
      key: "pause",
      value: function pause() {
        return this.status !== STATUS$1.INITIAL && (this.status = STATUS$1.PAUSE, !0);
      }
    }, {
      key: "resume",
      value: function resume() {
        return this.status !== STATUS$1.INITIAL && (this.status = STATUS$1.RUNNING, !0);
      }
    }, {
      key: "ifCanStop",
      value: function ifCanStop() {
        if (this.autoStop) {
          if (!this.timelines.length) return !0;
          if (0 === this.timelines.reduce(function (a, b) {
            return a + b.animateCount;
          }, 0)) return !0;
        }
        return !1;
      }
    }, {
      key: "start",
      value: function start() {
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        if (this.status === STATUS$1.RUNNING) return !1;
        if (!this.tickerHandler) return !1;
        if (!force) {
          if (this.status === STATUS$1.PAUSE) return !1;
          if (!this.timelines.length) return !1;
          if (0 === this.timelines.reduce(function (a, b) {
            return a + b.animateCount;
          }, 0)) return !1;
        }
        return this.status = STATUS$1.RUNNING, this.tickerHandler.tick(0, this.handleTick), !0;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.status = STATUS$1.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;
      }
    }]);
    return DefaultTicker;
  }();
  var ManualTicker = /*#__PURE__*/function (_DefaultTicker) {
    _inherits(ManualTicker, _DefaultTicker);
    var _super = _createSuper(ManualTicker);
    function ManualTicker() {
      _classCallCheck(this, ManualTicker);
      return _super.apply(this, arguments);
    }
    _createClass(ManualTicker, [{
      key: "mode",
      get: function get() {
        return this._mode;
      },
      set: function set(m) {
        this.setupTickHandler();
      }
    }, {
      key: "initHandler",
      value: function initHandler() {
        return this.mode = "manual", null;
      }
    }, {
      key: "setupTickHandler",
      value: function setupTickHandler() {
        var handler = new ManualTickHandler();
        return this._mode = "manual", this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, !0;
      }
    }, {
      key: "tickAt",
      value: function tickAt(time) {
        var _this7 = this;
        this.tickerHandler.tick(time - this.lastFrameTime, function (handler) {
          _this7.handleTick(handler, {
            once: !0
          });
        });
      }
    }, {
      key: "ifCanStop",
      value: function ifCanStop() {
        return !1;
      }
    }]);
    return ManualTicker;
  }(DefaultTicker);

  var Easing = /*#__PURE__*/function () {
    function Easing() {
      _classCallCheck(this, Easing);
    }
    _createClass(Easing, null, [{
      key: "linear",
      value: function linear(t) {
        return t;
      }
    }, {
      key: "none",
      value: function none() {
        return this.linear;
      }
    }, {
      key: "get",
      value: function get(amount) {
        return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function (t) {
          return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));
        };
      }
    }, {
      key: "getPowIn",
      value: function getPowIn(pow) {
        return function (t) {
          return Math.pow(t, pow);
        };
      }
    }, {
      key: "getPowOut",
      value: function getPowOut(pow) {
        return function (t) {
          return 1 - Math.pow(1 - t, pow);
        };
      }
    }, {
      key: "getPowInOut",
      value: function getPowInOut(pow) {
        return function (t) {
          return (t *= 2) < 1 ? .5 * Math.pow(t, pow) : 1 - .5 * Math.abs(Math.pow(2 - t, pow));
        };
      }
    }, {
      key: "getBackIn",
      value: function getBackIn(amount) {
        return function (t) {
          return t * t * ((amount + 1) * t - amount);
        };
      }
    }, {
      key: "getBackOut",
      value: function getBackOut(amount) {
        return function (t) {
          return --t * t * ((amount + 1) * t + amount) + 1;
        };
      }
    }, {
      key: "getBackInOut",
      value: function getBackInOut(amount) {
        return amount *= 1.525, function (t) {
          return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * .5 : .5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
        };
      }
    }, {
      key: "sineIn",
      value: function sineIn(t) {
        return 1 - Math.cos(t * Math.PI / 2);
      }
    }, {
      key: "sineOut",
      value: function sineOut(t) {
        return Math.sin(t * Math.PI / 2);
      }
    }, {
      key: "sineInOut",
      value: function sineInOut(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
      }
    }, {
      key: "expoIn",
      value: function expoIn(t) {
        return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
      }
    }, {
      key: "expoOut",
      value: function expoOut(t) {
        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
      }
    }, {
      key: "expoInOut",
      value: function expoInOut(t) {
        return 0 === t ? 0 : 1 === t ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
      }
    }, {
      key: "circIn",
      value: function circIn(t) {
        return -(Math.sqrt(1 - t * t) - 1);
      }
    }, {
      key: "circOut",
      value: function circOut(t) {
        return Math.sqrt(1 - --t * t);
      }
    }, {
      key: "circInOut",
      value: function circInOut(t) {
        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      }
    }, {
      key: "bounceOut",
      value: function bounceOut(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
      }
    }, {
      key: "bounceIn",
      value: function bounceIn(t) {
        return 1 - Easing.bounceOut(1 - t);
      }
    }, {
      key: "bounceInOut",
      value: function bounceInOut(t) {
        return t < .5 ? .5 * Easing.bounceIn(2 * t) : .5 * Easing.bounceOut(2 * t - 1) + .5;
      }
    }, {
      key: "getElasticIn",
      value: function getElasticIn(amplitude, period) {
        return function (t) {
          if (0 === t || 1 === t) return t;
          var s = period / pi2 * Math.asin(1 / amplitude);
          return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period);
        };
      }
    }, {
      key: "getElasticOut",
      value: function getElasticOut(amplitude, period) {
        return function (t) {
          if (0 === t || 1 === t) return t;
          var s = period / pi2 * Math.asin(1 / amplitude);
          return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1;
        };
      }
    }, {
      key: "getElasticInOut",
      value: function getElasticInOut(amplitude, period) {
        return function (t) {
          var s = period / pi2 * Math.asin(1 / amplitude);
          return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * -.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * .5 + 1;
        };
      }
    }]);
    return Easing;
  }();
  Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, .3), Easing.elasticOut = Easing.getElasticOut(1, .3), Easing.elasticInOut = Easing.getElasticInOut(1, .3 * 1.5);

  var DefaultTimeline = /*#__PURE__*/function () {
    function DefaultTimeline() {
      _classCallCheck(this, DefaultTimeline);
      this.id = Generator.GenAutoIncrementId(), this.animateHead = null, this.animateTail = null, this.animateCount = 0, this.paused = !1;
    }
    _createClass(DefaultTimeline, [{
      key: "addAnimate",
      value: function addAnimate(animate) {
        this.animateTail ? (this.animateTail.nextAnimate = animate, animate.prevAnimate = this.animateTail, this.animateTail = animate, animate.nextAnimate = null) : (this.animateHead = animate, this.animateTail = animate), this.animateCount++;
      }
    }, {
      key: "pause",
      value: function pause() {
        this.paused = !0;
      }
    }, {
      key: "resume",
      value: function resume() {
        this.paused = !1;
      }
    }, {
      key: "tick",
      value: function tick(delta) {
        if (this.paused) return;
        var animate = this.animateHead;
        for (this.animateCount = 0; animate;) animate.status === exports.AnimateStatus.END ? this.removeAnimate(animate) : animate.status === exports.AnimateStatus.RUNNING || animate.status === exports.AnimateStatus.INITIAL ? (this.animateCount++, animate.advance(delta)) : animate.status === exports.AnimateStatus.PAUSED && this.animateCount++, animate = animate.nextAnimate;
      }
    }, {
      key: "clear",
      value: function clear() {
        var animate = this.animateHead;
        for (; animate;) animate.release(), animate = animate.nextAnimate;
        this.animateHead = null, this.animateTail = null, this.animateCount = 0;
      }
    }, {
      key: "removeAnimate",
      value: function removeAnimate(animate) {
        var release = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        animate._onRemove && animate._onRemove.forEach(function (cb) {
          return cb();
        }), animate === this.animateHead ? (this.animateHead = animate.nextAnimate, animate === this.animateTail ? this.animateTail = null : this.animateHead.prevAnimate = null) : animate === this.animateTail ? (this.animateTail = animate.prevAnimate, this.animateTail.nextAnimate = null) : (animate.prevAnimate.nextAnimate = animate.nextAnimate, animate.nextAnimate.prevAnimate = animate.prevAnimate), release && animate.release();
      }
    }]);
    return DefaultTimeline;
  }();
  var defaultTimeline = new DefaultTimeline();

  var ACustomAnimate = /*#__PURE__*/function () {
    function ACustomAnimate(from, to, duration, easing, params) {
      _classCallCheck(this, ACustomAnimate);
      this.from = from, this.to = to, this.duration = duration, this.easing = easing, this.params = params, this.updateCount = 0;
    }
    _createClass(ACustomAnimate, [{
      key: "bind",
      value: function bind(target, subAni) {
        this.target = target, this.subAnimate = subAni, this.onBind();
      }
    }, {
      key: "onBind",
      value: function onBind() {}
    }, {
      key: "onFirstRun",
      value: function onFirstRun() {}
    }, {
      key: "onStart",
      value: function onStart() {}
    }, {
      key: "onEnd",
      value: function onEnd() {}
    }, {
      key: "getEndProps",
      value: function getEndProps() {}
    }, {
      key: "getFromProps",
      value: function getFromProps() {
        return this.from;
      }
    }, {
      key: "getMergedEndProps",
      value: function getMergedEndProps() {
        var _a;
        var thisEndProps = this.getEndProps();
        return thisEndProps ? this._endProps === thisEndProps ? this._mergedEndProps : (this._endProps = thisEndProps, void (this._mergedEndProps = Object.assign({}, null !== (_a = this.step.prev.getLastProps()) && void 0 !== _a ? _a : {}, thisEndProps))) : this.step.prev ? this.step.prev.getLastProps() : thisEndProps;
      }
    }, {
      key: "update",
      value: function update(end, ratio, out) {
        var _this = this;
        if (0 === this.updateCount) {
          this.onFirstRun();
          var props = this.step.getLastProps();
          Object.keys(props).forEach(function (k) {
            _this.subAnimate.animate.validAttr(k) && (out[k] = props[k]);
          });
        }
        this.updateCount += 1, this.onUpdate(end, ratio, out), end && this.onEnd();
      }
    }]);
    return ACustomAnimate;
  }();
  var CbAnimate = /*#__PURE__*/function (_ACustomAnimate) {
    _inherits(CbAnimate, _ACustomAnimate);
    var _super = _createSuper(CbAnimate);
    function CbAnimate(cb) {
      var _this2;
      _classCallCheck(this, CbAnimate);
      _this2 = _super.call(this, null, null, 0, "linear"), _this2.cb = cb;
      return _this2;
    }
    _createClass(CbAnimate, [{
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {}
    }, {
      key: "onStart",
      value: function onStart() {
        this.cb();
      }
    }]);
    return CbAnimate;
  }(ACustomAnimate);
  var Animate = /*#__PURE__*/function () {
    function Animate() {
      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Generator.GenAutoIncrementId();
      var timeline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultTimeline;
      _classCallCheck(this, Animate);
      this.id = id, this.timeline = timeline, this.status = exports.AnimateStatus.INITIAL, this.tailAnimate = new SubAnimate(this), this.subAnimates = [this.tailAnimate], this.timeScale = 1, this.rawPosition = -1, this._startTime = 0, this._duringTime = 0, this.timeline.addAnimate(this);
    }
    _createClass(Animate, [{
      key: "setTimeline",
      value: function setTimeline(timeline) {
        timeline !== this.timeline && (this.timeline.removeAnimate(this, !1), timeline.addAnimate(this));
      }
    }, {
      key: "getStartTime",
      value: function getStartTime() {
        return this._startTime;
      }
    }, {
      key: "getDuration",
      value: function getDuration() {
        return this.subAnimates.reduce(function (t, subAnimate) {
          return t + subAnimate.totalDuration;
        }, 0);
      }
    }, {
      key: "after",
      value: function after(animate) {
        var t = animate.getDuration();
        return this._startTime = t, this;
      }
    }, {
      key: "afterAll",
      value: function afterAll(list) {
        var maxT = -1 / 0;
        return list.forEach(function (a) {
          maxT = max(a.getDuration(), maxT);
        }), this._startTime = maxT, this;
      }
    }, {
      key: "parallel",
      value: function parallel(animate) {
        return this._startTime = animate.getStartTime(), this;
      }
    }, {
      key: "play",
      value: function play(customAnimate) {
        if (this.tailAnimate.play(customAnimate), this.target) {
          var stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return 1 === this.subAnimates.length && this.tailAnimate.duration === customAnimate.duration && this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode), this;
      }
    }, {
      key: "trySetAttribute",
      value: function trySetAttribute(attr) {
        var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Animate.mode;
        attr && mode & exports.AnimateMode.SET_ATTR_IMMEDIATELY && this.target.setAttributes && this.target.setAttributes(attr, !1, {
          type: exports.AttributeUpdateType.ANIMATE_PLAY
        });
      }
    }, {
      key: "runCb",
      value: function runCb(cb) {
        var _this3 = this;
        var customAnimate = new CbAnimate(function () {
          cb(_this3, customAnimate.step.prev);
        });
        return this.tailAnimate.play(customAnimate), this;
      }
    }, {
      key: "customInterpolate",
      value: function customInterpolate(key, ratio, from, to, target, ret) {
        var func = Animate.interpolateMap.get(key) || Animate.interpolateMap.get("");
        return !!func && func(key, ratio, from, to, target, ret);
      }
    }, {
      key: "pause",
      value: function pause() {
        this.status === exports.AnimateStatus.RUNNING && (this.status = exports.AnimateStatus.PAUSED);
      }
    }, {
      key: "resume",
      value: function resume() {
        this.status === exports.AnimateStatus.PAUSED && (this.status = exports.AnimateStatus.RUNNING);
      }
    }, {
      key: "to",
      value: function to(props, duration, easing, params) {
        if (this.tailAnimate.to(props, duration, easing, params), this.target) {
          var stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
    }, {
      key: "from",
      value: function from(props, duration, easing, params) {
        if (this.tailAnimate.from(props, duration, easing, params), this.target) {
          var stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
    }, {
      key: "wait",
      value: function wait(duration) {
        if (this.tailAnimate.wait(duration), this.target) {
          var stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
    }, {
      key: "startAt",
      value: function startAt(t) {
        if (this.tailAnimate.startAt(t), this.target) {
          var stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
    }, {
      key: "loop",
      value: function loop(l) {
        if (this.tailAnimate.loop = l, this.target) {
          var stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
    }, {
      key: "reversed",
      value: function reversed(r) {
        if (this.tailAnimate.reversed = r, this.target) {
          var stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
    }, {
      key: "bounce",
      value: function bounce(b) {
        if (this.tailAnimate.bounce = b, this.target) {
          var stage = this.target.stage;
          stage && stage.renderNextFrame();
        }
        return this;
      }
    }, {
      key: "subAnimate",
      value: function subAnimate() {
        var sa = new SubAnimate(this, this.tailAnimate);
        return this.tailAnimate = sa, this.subAnimates.push(sa), sa.bind(this.target), this;
      }
    }, {
      key: "getStartProps",
      value: function getStartProps() {
        return this.subAnimates[0].getStartProps();
      }
    }, {
      key: "getEndProps",
      value: function getEndProps() {
        return this.tailAnimate.getEndProps();
      }
    }, {
      key: "depreventAttr",
      value: function depreventAttr(key) {
        this._preventAttrs && this._preventAttrs["delete"](key);
      }
    }, {
      key: "preventAttr",
      value: function preventAttr(key) {
        this._preventAttrs || (this._preventAttrs = new Set()), this._preventAttrs.add(key);
      }
    }, {
      key: "preventAttrs",
      value: function preventAttrs(keys) {
        var _this4 = this;
        keys.forEach(function (key) {
          return _this4.preventAttr(key);
        });
      }
    }, {
      key: "validAttr",
      value: function validAttr(key) {
        return !this._preventAttrs || !this._preventAttrs.has(key);
      }
    }, {
      key: "bind",
      value: function bind(target) {
        return this.target = target, this.target.onAnimateBind && this.target.onAnimateBind(this), this.subAnimates.forEach(function (sa) {
          sa.bind(target);
        }), this;
      }
    }, {
      key: "advance",
      value: function advance(delta) {
        if (this._duringTime < this._startTime) {
          if (this._duringTime + delta * this.timeScale < this._startTime) return void (this._duringTime += delta * this.timeScale);
          delta = this._duringTime + delta * this.timeScale - this._startTime, this._duringTime = this._startTime;
        }
        this.status === exports.AnimateStatus.INITIAL && (this.status = exports.AnimateStatus.RUNNING, this._onStart && this._onStart.forEach(function (cb) {
          return cb();
        }));
        this.setPosition(this.rawPosition + delta * this.timeScale) && this.status === exports.AnimateStatus.RUNNING && (this.status = exports.AnimateStatus.END, this._onEnd && this._onEnd.forEach(function (cb) {
          return cb();
        }));
      }
    }, {
      key: "setPosition",
      value: function setPosition(rawPosition) {
        var sa,
          d = 0;
        var prevRawPos = this.rawPosition,
          maxRawPos = this.subAnimates.reduce(function (a, b) {
            return a + b.totalDuration;
          }, 0);
        rawPosition < 0 && (rawPosition = 0);
        var end = rawPosition >= maxRawPos;
        if (end && (rawPosition = maxRawPos), rawPosition === prevRawPos) return end;
        for (var i = 0; i < this.subAnimates.length && (sa = this.subAnimates[i], !(d + sa.totalDuration >= rawPosition)); i++) d += sa.totalDuration, sa = void 0;
        return this.rawPosition = rawPosition, sa.setPosition(rawPosition - d), end;
      }
    }, {
      key: "onStart",
      value: function onStart(cb) {
        this._onStart || (this._onStart = []), this._onStart.push(cb);
      }
    }, {
      key: "onEnd",
      value: function onEnd(cb) {
        this._onEnd || (this._onEnd = []), this._onEnd.push(cb);
      }
    }, {
      key: "onRemove",
      value: function onRemove(cb) {
        this._onRemove || (this._onRemove = []), this._onRemove.push(cb);
      }
    }, {
      key: "onFrame",
      value: function onFrame(cb) {
        this._onFrame || (this._onFrame = []), this._onFrame.push(cb);
      }
    }, {
      key: "release",
      value: function release() {
        this.status = exports.AnimateStatus.END;
      }
    }, {
      key: "stop",
      value: function stop(nextVal) {
        nextVal || this.target.onStop(), "start" === nextVal ? this.target.onStop(this.getStartProps()) : "end" === nextVal ? this.target.onStop(this.getEndProps()) : this.target.onStop(nextVal), this.release();
      }
    }], [{
      key: "AddInterpolate",
      value: function AddInterpolate(name, cb) {
        Animate.interpolateMap.set(name, cb);
      }
    }]);
    return Animate;
  }();
  Animate.mode = exports.AnimateMode.NORMAL, Animate.interpolateMap = new Map();
  var SubAnimate = /*#__PURE__*/function () {
    function SubAnimate(animate, lastSubAnimate) {
      _classCallCheck(this, SubAnimate);
      this.rawPosition = -1, this.position = 0, this.loop = 0, this.duration = 0, this.animate = animate, this.stepHead = new Step(0, 0, lastSubAnimate ? Object.assign({}, lastSubAnimate.stepTail.props) : {}), this.stepTail = this.stepHead, this.dirty = !0, this._startAt = 0;
    }
    _createClass(SubAnimate, [{
      key: "totalDuration",
      get: function get() {
        return this.calcAttr(), this._totalDuration + this._startAt;
      }
    }, {
      key: "calcAttr",
      value: function calcAttr() {
        this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
      }
    }, {
      key: "bind",
      value: function bind(target) {
        return this.target = target, this;
      }
    }, {
      key: "play",
      value: function play(customAnimate) {
        var duration = customAnimate.duration;
        (null == duration || duration < 0) && (duration = 0);
        var easing = customAnimate.easing,
          easingFunc = "string" == typeof easing ? Easing[easing] : easing,
          step = this._addStep(duration, null, easingFunc);
        return step.type = exports.AnimateStepType.customAnimate, this._appendProps(customAnimate.getEndProps(), step, !1), this._appendCustomAnimate(customAnimate, step), this;
      }
    }, {
      key: "to",
      value: function to(props, duration, easing, params) {
        var _this5 = this;
        (null == duration || duration < 0) && (duration = 0);
        var easingFunc = "string" == typeof easing ? Easing[easing] : easing,
          step = this._addStep(duration, null, easingFunc);
        return step.type = exports.AnimateStepType.to, this._appendProps(props, step, !!params && params.tempProps), step.propKeys || (step.propKeys = Object.keys(step.props)), params && params.noPreventAttrs || this.target.animates.forEach(function (a) {
          a.id !== _this5.animate.id && a.preventAttrs(step.propKeys);
        }), this;
      }
    }, {
      key: "from",
      value: function from(props, duration, easing, params) {
        var _this6 = this;
        this.to(props, 0, easing, params);
        var toProps = {};
        this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)), this.stepTail.propKeys.forEach(function (k) {
          toProps[k] = _this6.getLastPropByName(k, _this6.stepTail);
        }), this.to(toProps, duration, easing, params), this.stepTail.type = exports.AnimateStepType.from;
      }
    }, {
      key: "startAt",
      value: function startAt(t) {
        return t < 0 && (t = 0), this._startAt = t, this;
      }
    }, {
      key: "getStartProps",
      value: function getStartProps() {
        var _a;
        return null === (_a = this.stepHead) || void 0 === _a ? void 0 : _a.props;
      }
    }, {
      key: "getEndProps",
      value: function getEndProps() {
        return this.stepTail.props;
      }
    }, {
      key: "getLastStep",
      value: function getLastStep() {
        return this._lastStep;
      }
    }, {
      key: "wait",
      value: function wait(duration) {
        if (duration > 0) {
          var step = this._addStep(+duration, null);
          step.type = exports.AnimateStepType.wait, step.prev.customAnimate ? step.props = step.prev.customAnimate.getEndProps() : step.props = step.prev.props, this.target.onAddStep && this.target.onAddStep(step);
        }
        return this;
      }
    }, {
      key: "_addStep",
      value: function _addStep(duration, props, easingFunc) {
        var step = new Step(this.duration, duration, props, easingFunc);
        return this.duration += duration, this.stepTail.append(step), this.stepTail = step, step;
      }
    }, {
      key: "_appendProps",
      value: function _appendProps(props, step, tempProps) {
        var _this7 = this;
        step.props = tempProps ? props : Object.assign({}, props);
        var lastStep = step.prev;
        var _props = step.props;
        for (step.propKeys || (step.propKeys = Object.keys(step.props)), step.propKeys.forEach(function (k) {
          void 0 === step.props[k] && (step.props[k] = _this7.target.getDefaultAttribute(k));
        }); lastStep.prev;) lastStep.props && (lastStep.propKeys || (lastStep.propKeys = Object.keys(lastStep.props)), lastStep.propKeys.forEach(function (key) {
          void 0 === _props[key] && (_props[key] = lastStep.props[key]);
        })), step.propKeys = Object.keys(step.props), lastStep = lastStep.prev;
        var initProps = this.stepHead.props;
        step.propKeys || (step.propKeys = Object.keys(_props)), step.propKeys.forEach(function (key) {
          if (void 0 === initProps[key]) {
            var parentAnimateInitProps = _this7.animate.getStartProps();
            initProps[key] = parentAnimateInitProps[key] = _this7.target.getComputedAttribute(key);
          }
        }), this.target.onAddStep && this.target.onAddStep(step);
      }
    }, {
      key: "_appendCustomAnimate",
      value: function _appendCustomAnimate(customAnimate, step) {
        step.customAnimate = customAnimate, customAnimate.step = step, customAnimate.bind(this.target, this);
      }
    }, {
      key: "setPosition",
      value: function setPosition(rawPosition) {
        var _a;
        var d = this.duration,
          loopCount = this.loop,
          prevRawPos = this.rawPosition;
        var loop,
          position,
          end = !1;
        var startAt = null !== (_a = this._startAt) && void 0 !== _a ? _a : 0;
        if (rawPosition < 0 && (rawPosition = 0), rawPosition < startAt) return this.rawPosition = rawPosition, !1;
        if (rawPosition -= startAt, d <= 0) return end = !0, end;
        if (loop = Math.floor(rawPosition / d), position = rawPosition - loop * d, end = rawPosition >= loopCount * d + d, end && (position = d, loop = loopCount, rawPosition = position * loop + d), rawPosition === prevRawPos) return end;
        var rev = !this.reversed != !(this.bounce && loop % 2);
        return rev && (position = d - position), this._deltaPosition = position - this.position, this.position = position, this.rawPosition = rawPosition + startAt, this.updatePosition(end, rev), end;
      }
    }, {
      key: "updatePosition",
      value: function updatePosition(end, rev) {
        if (!this.stepHead) return;
        var step = this.stepHead.next;
        var position = this.position,
          duration = this.duration;
        if (this.target && step) {
          var stepNext = step.next;
          for (; stepNext && stepNext.position <= position;) step = stepNext, stepNext = step.next;
          var ratio = end ? 0 === duration ? 1 : position / duration : (position - step.position) / step.duration;
          step.easing && (ratio = step.easing(ratio)), this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev), this.updateTarget(step, ratio, end), this._lastStep = step, this.animate._onFrame && this.animate._onFrame.forEach(function (cb) {
            return cb(step, ratio);
          });
        }
      }
    }, {
      key: "tryCallCustomAnimateLifeCycle",
      value: function tryCallCustomAnimateLifeCycle(step, lastStep, rev) {
        if (step !== lastStep) if (rev) {
          var _step = lastStep.prev;
          for (; _step && _step !== step;) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = step.prev;
          lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
        } else {
          var _step2 = lastStep.next;
          for (; _step2 && _step2 !== step;) _step2.customAnimate && (_step2.customAnimate.onStart && _step2.customAnimate.onStart(), _step2.customAnimate.onEnd && _step2.customAnimate.onEnd()), _step2 = _step2.next;
          lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
        }
      }
    }, {
      key: "getLastPropByName",
      value: function getLastPropByName(name, step) {
        var lastStep = step.prev;
        for (; lastStep;) {
          if (lastStep.props && void 0 !== lastStep.props[name]) return lastStep.props[name];
          if (lastStep.customAnimate) {
            var val = lastStep.customAnimate.getEndProps()[name];
            if (void 0 !== val) return val;
          }
          lastStep = lastStep.prev;
        }
        return Logger.getInstance().warn("未知错误，step中找不到属性"), step.props[name];
      }
    }, {
      key: "updateTarget",
      value: function updateTarget(step, ratio, end) {
        null == step.props && null == step.customAnimate || this.target.onStep(this, this.animate, step, ratio, end);
      }
    }]);
    return SubAnimate;
  }();
  var Step = /*#__PURE__*/function () {
    function Step(position, duration, props, easing) {
      _classCallCheck(this, Step);
      this.duration = duration, this.position = position, this.props = props, this.easing = easing;
    }
    _createClass(Step, [{
      key: "append",
      value: function append(step) {
        step.prev = this, step.next = this.next, this.next = step;
      }
    }, {
      key: "getLastProps",
      value: function getLastProps() {
        var step = this.prev;
        for (; step;) {
          if (step.props) return step.props;
          if (step.customAnimate) return step.customAnimate.getMergedEndProps();
          step = step.prev;
        }
        return null;
      }
    }]);
    return Step;
  }();

  var DefaultStateAnimateConfig = {
    duration: 200,
    easing: "cubicOut"
  };
  var DefaultMorphingAnimateConfig = {
    duration: 1e3,
    easing: "quadInOut"
  };

  exports.Edge = void 0;
  !function (Edge) {
    Edge[Edge.Top = 1] = "Top", Edge[Edge.Right = 2] = "Right", Edge[Edge.Bottom = 4] = "Bottom", Edge[Edge.Left = 8] = "Left", Edge[Edge.ALL = 15] = "ALL";
  }(exports.Edge || (exports.Edge = {}));
  var _strokeVec4 = [!1, !1, !1, !1];
  var parseStroke = function parseStroke(stroke) {
    var _a;
    var isFullStroke = !0;
    if (isBoolean$1(stroke, !0)) {
      for (var i = 0; i < 4; i++) _strokeVec4[i] = stroke, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
      isFullStroke = stroke;
    } else if (Array.isArray(stroke)) for (var _i = 0; _i < 4; _i++) _strokeVec4[_i] = !!stroke[_i], isFullStroke && (isFullStroke = !!_strokeVec4[_i]);else _strokeVec4[0] = !1, _strokeVec4[1] = !1, _strokeVec4[2] = !1, _strokeVec4[3] = !1;
    return {
      isFullStroke: isFullStroke,
      stroke: _strokeVec4
    };
  };
  var _paddingVec4 = [0, 0, 0, 0];
  var parsePadding = function parsePadding(padding) {
    return padding ? isArray$1(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], _paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], _paddingVec4) : padding : padding : 0;
  };
  var _coords = [{
      x: 0,
      y: 0
    }, {
      x: 0,
      y: 0
    }, {
      x: 0,
      y: 0
    }, {
      x: 0,
      y: 0
    }],
    indexList = [1, 2, 3, 0, 1, 2, 3, 0];
  function circleBounds(startAngle, endAngle, radius, bounds) {
    for (; startAngle >= pi2;) startAngle -= pi2;
    for (; startAngle < 0;) startAngle += pi2;
    for (; startAngle > endAngle;) endAngle += pi2;
    _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
    var startIdx = Math.ceil(startAngle / halfPi$1) % 4,
      endIdx = Math.ceil(endAngle / halfPi$1) % 4;
    if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), startIdx !== endIdx || endAngle - startAngle > pi) {
      var match = !1;
      for (var i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
        if (match && endIdx === indexList[i]) break;
        if (match) {
          var p = _coords[indexList[i]];
          bounds.add(p.x, p.y);
        }
      } else {
        match = !0;
        var _p = _coords[startIdx];
        bounds.add(_p.x, _p.y);
      }
    }
  }
  function pointsEqual(pointsA, pointsB) {
    return !(!pointsA || !pointsB) && (Array.isArray(pointsA) && Array.isArray(pointsB) ? pointsA.length === pointsB.length && pointsA.every(function (point, index) {
      return pointEqual(point, pointsB[index]);
    }) : !Number.isNaN(pointsA.x + pointsA.y) && pointEqual(pointsA, pointsB));
  }
  function pointEqual(pointA, pointB) {
    return pointA.x === pointB.x && pointA.y === pointB.y && pointA.x1 === pointB.x1 && pointA.y1 === pointB.y1 && pointA.defined === pointB.defined;
  }
  function pointInterpolation(pointA, pointB, ratio) {
    var _pointAt = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio),
      x = _pointAt.x,
      y = _pointAt.y,
      _pointAt2 = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio),
      x1 = _pointAt2.x,
      y1 = _pointAt2.y,
      point = new Point(x, y, x1, y1);
    return point.defined = pointB.defined, point;
  }
  function pointInterpolationHighPerformance(pointA, pointB, ratio, point) {
    var _pointAt3 = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio),
      x = _pointAt3.x,
      y = _pointAt3.y,
      _pointAt4 = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio),
      x1 = _pointAt4.x,
      y1 = _pointAt4.y;
    return point.x = x, point.y = y, point.x1 = x1, point.y1 = y1, point.defined = pointB.defined, point;
  }
  function pointsInterpolation(pointsA, pointsB, ratio) {
    if (!pointsA || !pointsB) return [];
    Array.isArray(pointsA) || (pointsA = [pointsA]), Array.isArray(pointsB) || (pointsB = [pointsB]);
    var points = [];
    if (pointsA.length > pointsB.length) {
      points = pointsB.map(function (point) {
        var p = new Point(point.x, point.y, point.x1, point.y1);
        return p.defined = point.defined, p;
      });
      for (var i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
    } else {
      points = pointsB.map(function (point) {
        var p = new Point(point.x, point.y, point.x1, point.y1);
        return p.defined = point.defined, p;
      });
      for (var _i2 = 0; _i2 < pointsA.length; _i2++) points[_i2] = pointInterpolation(pointsA[_i2], pointsB[_i2], ratio);
    }
    return points;
  }
  var transformKeys = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "scrollX", "scrollY"];
  var isTransformKey = function isTransformKey(key) {
    return transformKeys.includes(key);
  };
  function getAttributeFromDefaultAttrList(attr, key) {
    if (isArray$1(attr)) {
      var val;
      for (var i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];
      return val;
    }
    return attr[key];
  }
  var RafBasedSTO = /*#__PURE__*/function () {
    function RafBasedSTO() {
      _classCallCheck(this, RafBasedSTO);
      this.durations = [], this.timeout = RafBasedSTO.TimeOut, this.lastDate = 0, this.durationsListThreshold = 30;
    }
    _createClass(RafBasedSTO, [{
      key: "call",
      value: function call(cb) {
        var _this = this;
        return this.lastDate = Date.now(), setTimeout(function () {
          _this.appendDuration(Date.now() - _this.lastDate), cb(0);
        }, this.timeout, !0);
      }
    }, {
      key: "clear",
      value: function clear(h) {
        clearTimeout(h);
      }
    }, {
      key: "appendDuration",
      value: function appendDuration(d) {
        this.durations.push(d), this.durations.length > this.durationsListThreshold && this.durations.shift(), this.timeout = Math.min(Math.max(this.durations.reduce(function (a, b) {
          return a + b;
        }, 0) / this.durations.length, 1e3 / 60), 1e3 / 30);
      }
    }]);
    return RafBasedSTO;
  }();
  RafBasedSTO.TimeOut = 1e3 / 60;
  var rafBasedSto = new RafBasedSTO();
  var calculateLineHeight = function calculateLineHeight(lineHeight, fontSize) {
    if (isString$1(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
      return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
    }
    return lineHeight;
  };

  var IncreaseCount = /*#__PURE__*/function (_ACustomAnimate) {
    _inherits(IncreaseCount, _ACustomAnimate);
    var _super = _createSuper(IncreaseCount);
    function IncreaseCount(from, to, duration, easing, params) {
      _classCallCheck(this, IncreaseCount);
      return _super.call(this, from, to, duration, easing, params);
    }
    _createClass(IncreaseCount, [{
      key: "getEndProps",
      value: function getEndProps() {
        return !1 === this.valid ? {} : {
          text: this.to
        };
      }
    }, {
      key: "onBind",
      value: function onBind() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.fromNumber = isNumber$1(null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) ? null === (_b = this.from) || void 0 === _b ? void 0 : _b.text : Number.parseFloat(null === (_c = this.from) || void 0 === _c ? void 0 : _c.text), this.toNumber = isNumber$1(null === (_d = this.to) || void 0 === _d ? void 0 : _d.text) ? null === (_e = this.to) || void 0 === _e ? void 0 : _e.text : Number.parseFloat(null === (_f = this.to) || void 0 === _f ? void 0 : _f.text), Number.isFinite(this.toNumber) || (this.fromNumber = 0), Number.isFinite(this.toNumber) || (this.valid = !1), !1 !== this.valid && (this.decimalLength = null !== (_h = null === (_g = this.params) || void 0 === _g ? void 0 : _g.fixed) && void 0 !== _h ? _h : Math.max(getDecimalPlaces(this.fromNumber), getDecimalPlaces(this.toNumber)));
      }
    }, {
      key: "onEnd",
      value: function onEnd() {}
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        !1 !== this.valid && (out.text = end ? this.toNumber : (this.fromNumber + (this.toNumber - this.fromNumber) * ratio).toFixed(this.decimalLength));
      }
    }]);
    return IncreaseCount;
  }(ACustomAnimate);
  var Direction;
  !function (Direction) {
    Direction[Direction.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", Direction[Direction.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT", Direction[Direction.TOP_TO_BOTTOM = 2] = "TOP_TO_BOTTOM", Direction[Direction.BOTTOM_TO_TOP = 3] = "BOTTOM_TO_TOP", Direction[Direction.STROKE = 4] = "STROKE";
  }(Direction || (Direction = {}));
  var FadeInPlus = /*#__PURE__*/function (_ACustomAnimate2) {
    _inherits(FadeInPlus, _ACustomAnimate2);
    var _super2 = _createSuper(FadeInPlus);
    function FadeInPlus(from, to, duration, easing, params) {
      var _this;
      _classCallCheck(this, FadeInPlus);
      _this = _super2.call(this, from, to, duration, easing, params);
      var _ref = params || {},
        _ref$direction = _ref.direction,
        direction = _ref$direction === void 0 ? Direction.LEFT_TO_RIGHT : _ref$direction,
        _ref$fill = _ref.fill,
        fill = _ref$fill === void 0 ? !0 : _ref$fill,
        _ref$stroke = _ref.stroke,
        stroke = _ref$stroke === void 0 ? !0 : _ref$stroke;
      _this.direction = direction, _this.fill = fill, _this.stroke = stroke, _this.fillGradient = {
        gradient: "linear",
        stops: []
      }, _this.strokeGradient = {
        gradient: "linear",
        stops: []
      };
      return _this;
    }
    _createClass(FadeInPlus, [{
      key: "getEndProps",
      value: function getEndProps() {
        return {
          fill: this.toFill,
          stroke: this.toStroke
        };
      }
    }, {
      key: "onBind",
      value: function onBind() {
        this.toFill = this.target.getComputedAttribute("fill"), this.toStroke = this.target.getComputedAttribute("stroke");
      }
    }, {
      key: "onEnd",
      value: function onEnd() {}
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        if (this.toFill && this.toStroke) switch (this.direction) {
          case Direction.RIGHT_TO_LEFT:
            this.rightToLeft(end, ratio, out);
            break;
          case Direction.TOP_TO_BOTTOM:
            this.topToBottom(end, ratio, out);
            break;
          case Direction.BOTTOM_TO_TOP:
            this.bottomToTop(end, ratio, out);
            break;
          case Direction.STROKE:
            this.strokePath(end, ratio, out);
            break;
          default:
            this.leftToRight(end, ratio, out);
        }
      }
    }, {
      key: "leftToRight",
      value: function leftToRight(end, ratio, out) {
        if (this.fill) {
          var toFillColor = this.toFill;
          this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, this.fillGradient.stops = [{
            offset: 0,
            color: toFillColor
          }, {
            offset: ratio,
            color: toFillColor
          }, {
            offset: Math.min(1, 2 * ratio),
            color: "transparent"
          }], out.fill = this.fillGradient;
        }
        if (this.stroke) {
          var toStrokeColor = this.toStroke;
          this.strokeGradient.x0 = 0, this.strokeGradient.y0 = 0, this.strokeGradient.x1 = 1, this.strokeGradient.y1 = 0, this.strokeGradient.stops = [{
            offset: 0,
            color: toStrokeColor
          }, {
            offset: ratio,
            color: toStrokeColor
          }, {
            offset: Math.min(1, 6 * ratio),
            color: "transparent"
          }], out.stroke = this.strokeGradient;
        }
      }
    }, {
      key: "strokePath",
      value: function strokePath(end, ratio, out) {
        if (this.fill) {
          var toFillColor = this.toFill;
          this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, this.fillGradient.stops = [{
            offset: 0,
            color: toFillColor
          }, {
            offset: ratio,
            color: toFillColor
          }, {
            offset: Math.min(1, 2 * ratio),
            color: "transparent"
          }], out.fill = this.fillGradient;
        }
        if (this.stroke) {
          var dashLen = 300,
            offset = ratio * dashLen;
          out.lineDash = [offset, dashLen - offset];
        }
      }
    }, {
      key: "rightToLeft",
      value: function rightToLeft(end, ratio, out) {}
    }, {
      key: "topToBottom",
      value: function topToBottom(end, ratio, out) {}
    }, {
      key: "bottomToTop",
      value: function bottomToTop(end, ratio, out) {}
    }]);
    return FadeInPlus;
  }(ACustomAnimate);
  var InputText = /*#__PURE__*/function (_ACustomAnimate3) {
    _inherits(InputText, _ACustomAnimate3);
    var _super3 = _createSuper(InputText);
    function InputText() {
      var _this2;
      _classCallCheck(this, InputText);
      _this2 = _super3.apply(this, arguments), _this2.fromText = "", _this2.toText = "";
      return _this2;
    }
    _createClass(InputText, [{
      key: "getEndProps",
      value: function getEndProps() {
        return !1 === this.valid ? {} : {
          text: this.to
        };
      }
    }, {
      key: "onBind",
      value: function onBind() {
        var _a, _b, _c, _d;
        if (this.fromText = null !== (_b = null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) && void 0 !== _b ? _b : "", this.toText = null !== (_d = null === (_c = this.to) || void 0 === _c ? void 0 : _c.text) && void 0 !== _d ? _d : "", !this.toText || isArray$1(this.toText)) this.valid = !1;else {
          this.toText = this.toText.toString();
          var root = this.target.attachShadow(),
            line = application.graphicService.creator.line({
              x: 0,
              y: 0,
              points: [{
                x: 0,
                y: 0
              }, {
                x: 0,
                y: this.target.getComputedAttribute("fontSize")
              }],
              stroke: "black",
              lineWidth: 1
            });
          root.add(line);
        }
      }
    }, {
      key: "onEnd",
      value: function onEnd() {
        this.target.detachShadow();
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        var _a;
        if (!1 === this.valid) return;
        var fromCount = this.fromText.length,
          toCount = this.toText.length,
          count = Math.ceil(fromCount + (toCount - fromCount) * ratio);
        out.text = this.toText.substr(0, count);
        var line = null === (_a = this.target.shadowRoot) || void 0 === _a ? void 0 : _a.at(0),
          endX = this.target.clipedWidth + 2;
        line.setAttribute("x", endX);
      }
    }]);
    return InputText;
  }(ACustomAnimate);
  var StreamLight = /*#__PURE__*/function (_ACustomAnimate4) {
    _inherits(StreamLight, _ACustomAnimate4);
    var _super4 = _createSuper(StreamLight);
    function StreamLight(from, to, duration, easing, params) {
      _classCallCheck(this, StreamLight);
      return _super4.call(this, from, to, duration, easing, params);
    }
    _createClass(StreamLight, [{
      key: "getEndProps",
      value: function getEndProps() {
        return {};
      }
    }, {
      key: "onStart",
      value: function onStart() {
        this.target && ("rect" === this.target.type ? this.onStartRect() : "line" === this.target.type ? this.onStartLineOrArea("line") : "area" === this.target.type && this.onStartLineOrArea("area"));
      }
    }, {
      key: "onStartLineOrArea",
      value: function onStartLineOrArea(type) {
        var _a;
        var root = this.target.attachShadow(),
          line = application.graphicService.creator[type](Object.assign({}, null === (_a = this.params) || void 0 === _a ? void 0 : _a.attribute));
        this[type] = line, line.pathProxy = new CustomPath2D(), root.add(line);
      }
    }, {
      key: "onStartRect",
      value: function onStartRect() {
        var _a;
        var root = this.target.attachShadow(),
          height = this.target.AABBBounds.height(),
          rect = application.graphicService.creator.rect(Object.assign(Object.assign({
            height: height,
            fill: "#bcdeff",
            shadowBlur: 30,
            shadowColor: "#bcdeff"
          }, null === (_a = this.params) || void 0 === _a ? void 0 : _a.attribute), {
            x: 0,
            y: 0,
            width: 0
          }));
        this.rect = rect, root.add(rect);
      }
    }, {
      key: "onBind",
      value: function onBind() {}
    }, {
      key: "onEnd",
      value: function onEnd() {
        this.target.detachShadow();
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        return this.rect ? this.onUpdateRect(end, ratio, out) : this.line || this.area ? this.onUpdateLineOrArea(end, ratio, out) : void 0;
      }
    }, {
      key: "onUpdateRect",
      value: function onUpdateRect(end, ratio, out) {
        var _a, _b, _c, _d, _e, _f;
        var parentWidth = null !== (_a = this.target.attribute.width) && void 0 !== _a ? _a : 250,
          streamLength = null !== (_c = null === (_b = this.params) || void 0 === _b ? void 0 : _b.streamLength) && void 0 !== _c ? _c : parentWidth,
          maxLength = null !== (_f = null === (_e = null === (_d = this.params) || void 0 === _d ? void 0 : _d.attribute) || void 0 === _e ? void 0 : _e.width) && void 0 !== _f ? _f : 60,
          startX = -maxLength,
          currentX = startX + (streamLength - startX) * ratio,
          x = Math.max(currentX, 0),
          w = Math.min(Math.min(currentX + maxLength, maxLength), streamLength - currentX),
          width = w + x > parentWidth ? Math.max(parentWidth - x, 0) : w;
        this.rect.setAttributes({
          x: x,
          width: width
        }, !1, {
          type: exports.AttributeUpdateType.ANIMATE_PLAY,
          animationState: {
            ratio: ratio,
            end: end
          }
        });
      }
    }, {
      key: "onUpdateLineOrArea",
      value: function onUpdateLineOrArea(end, ratio, out) {
        var target = this.line || this.area;
        if (!target) return;
        var customPath = target.pathProxy,
          targetLine = this.target;
        targetLine.cache || targetLine.cacheArea ? this._onUpdateLineOrAreaWithCache(customPath, targetLine, end, ratio, out) : this._onUpdateLineWithoutCache(customPath, targetLine, end, ratio, out);
        var targetAttrs = targetLine.attribute;
        target.setAttributes(Object.assign({
          stroke: targetAttrs.stroke
        }, target.attribute)), target.addUpdateBoundTag();
      }
    }, {
      key: "_onUpdateLineOrAreaWithCache",
      value: function _onUpdateLineOrAreaWithCache(customPath, g, end, ratio, out) {
        if (customPath.clear(), "line" === g.type) {
          var cache = g.cache;
          Array.isArray(cache) || (cache = [cache]);
          var totalLen = cache.reduce(function (l, c) {
              return l + c.getLength();
            }, 0),
            curves = [];
          return cache.forEach(function (c) {
            c.curves.forEach(function (ci) {
              return curves.push(ci);
            });
          }), this._updateCurves(customPath, curves, totalLen, ratio);
        }
        if ("area" === g.type) {
          var _cache = g.cacheArea,
            _totalLen = _cache.top.curves.reduce(function (a, b) {
              return a + b.getLength();
            }, 0);
          return this._updateCurves(customPath, _cache.top.curves, _totalLen, ratio);
        }
      }
    }, {
      key: "_updateCurves",
      value: function _updateCurves(customPath, curves, totalLen, ratio) {
        var _a, _b;
        var startLen = totalLen * ratio,
          endLen = Math.min(null !== (_b = startLen + (null === (_a = this.params) || void 0 === _a ? void 0 : _a.streamLength)) && void 0 !== _b ? _b : 10, totalLen);
        var lastLen = 0,
          start = !1;
        for (var i = 0; i < curves.length; i++) {
          var curveItem = curves[i],
            len = curveItem.getLength(),
            startPercent = 1 - (lastLen + len - startLen) / len;
          var curveForStart = void 0,
            endPercent = 1 - (lastLen + len - endLen) / len;
          if (lastLen < startLen && lastLen + len > startLen) if (start = !0, curveItem.p2 && curveItem.p3) {
            var _divideCubic = divideCubic(curveItem, startPercent),
              _divideCubic2 = _slicedToArray(_divideCubic, 2);
              _divideCubic2[0];
              var curve2 = _divideCubic2[1];
            customPath.moveTo(curve2.p0.x, curve2.p0.y), curveForStart = curve2;
          } else {
            var p = curveItem.getPointAt(startPercent);
            customPath.moveTo(p.x, p.y);
          }
          if (lastLen < endLen && lastLen + len > endLen) {
            if (curveItem.p2 && curveItem.p3) {
              curveForStart && (endPercent = (endLen - startLen) / curveForStart.getLength());
              var _divideCubic3 = divideCubic(curveForStart || curveItem, endPercent),
                _divideCubic4 = _slicedToArray(_divideCubic3, 1),
                curve1 = _divideCubic4[0];
              customPath.bezierCurveTo(curve1.p1.x, curve1.p1.y, curve1.p2.x, curve1.p2.y, curve1.p3.x, curve1.p3.y);
            } else {
              var _p = curveItem.getPointAt(endPercent);
              customPath.lineTo(_p.x, _p.y);
            }
            break;
          }
          if (start) if (curveItem.p2 && curveItem.p3) {
            var curve = curveForStart || curveItem;
            customPath.bezierCurveTo(curve.p1.x, curve.p1.y, curve.p2.x, curve.p2.y, curve.p3.x, curve.p3.y);
          } else customPath.lineTo(curveItem.p1.x, curveItem.p1.y);
          lastLen += len;
        }
      }
    }, {
      key: "_onUpdateLineWithoutCache",
      value: function _onUpdateLineWithoutCache(customPath, line, end, ratio, out) {
        var _a, _b;
        var _line$attribute = line.attribute,
          points = _line$attribute.points,
          curveType = _line$attribute.curveType;
        if (!points || points.length < 2 || "linear" !== curveType) return;
        var totalLen = 0;
        for (var i = 1; i < points.length; i++) totalLen += PointService.distancePP(points[i], points[i - 1]);
        var startLen = totalLen * ratio,
          endLen = Math.min(null !== (_b = startLen + (null === (_a = this.params) || void 0 === _a ? void 0 : _a.streamLength)) && void 0 !== _b ? _b : 10, totalLen),
          nextPoints = [];
        var lastLen = 0;
        for (var _i = 1; _i < points.length; _i++) {
          var len = PointService.distancePP(points[_i], points[_i - 1]);
          if (lastLen < startLen && lastLen + len > startLen && nextPoints.push(PointService.pointAtPP(points[_i - 1], points[_i], 1 - (lastLen + len - startLen) / len)), lastLen < endLen && lastLen + len > endLen) {
            nextPoints.push(PointService.pointAtPP(points[_i - 1], points[_i], 1 - (lastLen + len - endLen) / len));
            break;
          }
          nextPoints.length && nextPoints.push(points[_i]), lastLen += len;
        }
        if (nextPoints.length && !(nextPoints.length < 2)) {
          customPath.clear(), customPath.moveTo(nextPoints[0].x, nextPoints[0].y);
          for (var _i2 = 1; _i2 < nextPoints.length; _i2++) customPath.lineTo(nextPoints[_i2].x, nextPoints[_i2].y);
        }
      }
    }]);
    return StreamLight;
  }(ACustomAnimate);
  var Meteor = /*#__PURE__*/function (_ACustomAnimate5) {
    _inherits(Meteor, _ACustomAnimate5);
    var _super5 = _createSuper(Meteor);
    function Meteor(size, duration, easing, params) {
      var _this3;
      _classCallCheck(this, Meteor);
      _this3 = _super5.call(this, null, null, duration, easing, params), _this3.size = size, _this3.posList = [];
      return _this3;
    }
    _createClass(Meteor, [{
      key: "lastPos",
      get: function get() {
        return this.posList[this.posList.length - 1];
      }
    }, {
      key: "onBind",
      value: function onBind() {
        var root = this.target.attachShadow();
        this.root = root;
        for (var i = 0; i < this.size; i++) {
          var g = this.target.clone(),
            scale = Math.min((this.size - i) / this.size * 3, 1),
            opacity = Math.min(.2 + .7 / this.size);
          g.setAttributes({
            x: 0,
            y: 0,
            dx: 0,
            dy: 0,
            scaleX: scale,
            scaleY: scale,
            opacity: opacity
          }, !1, {
            type: exports.AttributeUpdateType.ANIMATE_BIND
          }), root.add(g);
        }
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        var _this4 = this;
        if (end) return this.target.detachShadow(), void (this.posList.length = 0);
        var x = this.target.getComputedAttribute("x"),
          y = this.target.getComputedAttribute("y"),
          nextPos = new Point(x, y);
        this.posList.length ? (this.target.shadowRoot.forEachChildren(function (g, i) {
          var pos = _this4.posList[Math.max(_this4.posList.length - i - 1, 0)];
          g.setAttributes({
            x: pos.x - x,
            y: pos.y - y
          }, !1);
        }), this.posList.push(nextPos)) : this.posList.push(nextPos);
      }
    }]);
    return Meteor;
  }(ACustomAnimate);
  var MotionPath = /*#__PURE__*/function (_ACustomAnimate6) {
    _inherits(MotionPath, _ACustomAnimate6);
    var _super6 = _createSuper(MotionPath);
    function MotionPath(from, to, duration, easing, params) {
      var _this5;
      _classCallCheck(this, MotionPath);
      var _a;
      _this5 = _super6.call(this, from, to, duration, easing, params), params && (_this5.pathLength = params.path.getLength(), _this5.path = params.path, _this5.distance = params.distance, _this5.to = params.distance * _this5.pathLength, _this5.initAngle = null !== (_a = params.initAngle) && void 0 !== _a ? _a : 0, _this5.changeAngle = !!params.changeAngle, _this5.cb = params.cb);
      return _this5;
    }
    _createClass(MotionPath, [{
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        var at = this.to * ratio,
          _this$path$getAttrAt = this.path.getAttrAt(at),
          pos = _this$path$getAttrAt.pos,
          angle = _this$path$getAttrAt.angle;
        out.x = pos.x, out.y = pos.y, this.changeAngle && (out.angle = angle + this.initAngle), this.cb && this.cb(this.from, this.to, ratio, this.target);
      }
    }]);
    return MotionPath;
  }(ACustomAnimate);
  var TagPointsUpdate = /*#__PURE__*/function (_ACustomAnimate7) {
    _inherits(TagPointsUpdate, _ACustomAnimate7);
    var _super7 = _createSuper(TagPointsUpdate);
    function TagPointsUpdate(from, to, duration, easing, params) {
      var _this6;
      _classCallCheck(this, TagPointsUpdate);
      _this6 = _super7.call(this, from, to, duration, easing, params), _this6.newPointAnimateType = "appear" === (null == params ? void 0 : params.newPointAnimateType) ? "appear" : "grow";
      return _this6;
    }
    _createClass(TagPointsUpdate, [{
      key: "onBind",
      value: function onBind() {
        var _this7 = this;
        var _a, _b;
        var originFromPoints = null === (_a = this.from) || void 0 === _a ? void 0 : _a.points,
          originToPoints = null === (_b = this.to) || void 0 === _b ? void 0 : _b.points;
        this.fromPoints = originFromPoints ? Array.isArray(originFromPoints) ? originFromPoints : [originFromPoints] : [], this.toPoints = originToPoints ? Array.isArray(originToPoints) ? originToPoints : [originToPoints] : [];
        var tagMap = new Map();
        this.fromPoints.forEach(function (point) {
          point.context && tagMap.set(point.context, point);
        });
        var firstMatchedPoint,
          lastMatchedPoint,
          firstMatchedIndex = 1 / 0,
          lastMatchedIndex = -1 / 0;
        for (var i = 0; i < this.toPoints.length; i += 1) if (tagMap.has(this.toPoints[i].context)) {
          firstMatchedIndex = i, firstMatchedPoint = tagMap.get(this.toPoints[i].context);
          break;
        }
        for (var _i3 = this.toPoints.length - 1; _i3 >= 0; _i3 -= 1) if (tagMap.has(this.toPoints[_i3].context)) {
          lastMatchedIndex = _i3, lastMatchedPoint = tagMap.get(this.toPoints[_i3].context);
          break;
        }
        var prevMatchedPoint = this.toPoints[0];
        this.interpolatePoints = this.toPoints.map(function (point, index) {
          var matchedPoint = tagMap.get(point.context);
          return matchedPoint ? (prevMatchedPoint = matchedPoint, [matchedPoint, point]) : "appear" === _this7.newPointAnimateType ? [point, point] : index < firstMatchedIndex && firstMatchedPoint ? [firstMatchedPoint, point] : index > lastMatchedIndex && lastMatchedPoint ? [lastMatchedPoint, point] : [prevMatchedPoint, point];
        }), this.points = this.interpolatePoints.map(function (interpolate) {
          var fromPoint = interpolate[0],
            toPoint = interpolate[1],
            newPoint = new Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
          return newPoint.defined = toPoint.defined, newPoint.context = toPoint.context, newPoint;
        });
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        var _this8 = this;
        this.points = this.points.map(function (point, index) {
          var newPoint = pointInterpolation(_this8.interpolatePoints[index][0], _this8.interpolatePoints[index][1], ratio);
          return newPoint.context = point.context, newPoint;
        }), out.points = this.points;
      }
    }]);
    return TagPointsUpdate;
  }(ACustomAnimate);
  var GraphicAnimate = /*#__PURE__*/function (_ACustomAnimate8) {
    _inherits(GraphicAnimate, _ACustomAnimate8);
    var _super8 = _createSuper(GraphicAnimate);
    function GraphicAnimate(from, to, duration, easing, params) {
      var _this9;
      _classCallCheck(this, GraphicAnimate);
      _this9 = _super8.call(this, from, to, duration, easing, params), _this9.graphic = null == params ? void 0 : params.graphic;
      return _this9;
    }
    _createClass(GraphicAnimate, [{
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        var _this10 = this;
        this.graphic && Object.keys(this.from).forEach(function (k) {
          out[k] = _this10.from[k] + (_this10.to[k] - _this10.from[k]) * ratio;
        });
      }
    }]);
    return GraphicAnimate;
  }(ACustomAnimate);
  var ClipGraphicAnimate = /*#__PURE__*/function (_ACustomAnimate9) {
    _inherits(ClipGraphicAnimate, _ACustomAnimate9);
    var _super9 = _createSuper(ClipGraphicAnimate);
    function ClipGraphicAnimate(from, to, duration, easing, params) {
      var _this11;
      _classCallCheck(this, ClipGraphicAnimate);
      _this11 = _super9.call(this, null, null, duration, easing, params), _this11.clipFromAttribute = from, _this11.clipToAttribute = to, _this11._group = null == params ? void 0 : params.group, _this11._clipGraphic = null == params ? void 0 : params.clipGraphic;
      return _this11;
    }
    _createClass(ClipGraphicAnimate, [{
      key: "onBind",
      value: function onBind() {
        this._group && this._clipGraphic && (this._lastClip = this._group.attribute.clip, this._lastPath = this._group.attribute.path, this._group.setAttributes({
          clip: !0,
          path: [this._clipGraphic]
        }, !1, {
          type: exports.AttributeUpdateType.ANIMATE_BIND
        }));
      }
    }, {
      key: "onEnd",
      value: function onEnd() {
        this._group && this._group.setAttributes({
          clip: this._lastClip,
          path: this._lastPath
        }, !1, {
          type: exports.AttributeUpdateType.ANIMATE_END
        });
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        var _this12 = this;
        if (!this._clipGraphic) return;
        var res = {};
        Object.keys(this.clipFromAttribute).forEach(function (k) {
          res[k] = _this12.clipFromAttribute[k] + (_this12.clipToAttribute[k] - _this12.clipFromAttribute[k]) * ratio;
        }), this._clipGraphic.setAttributes(res, !1, {
          type: exports.AttributeUpdateType.ANIMATE_UPDATE,
          animationState: {
            ratio: ratio,
            end: end
          }
        });
      }
    }]);
    return ClipGraphicAnimate;
  }(ACustomAnimate);
  var ClipAngleAnimate = /*#__PURE__*/function (_ClipGraphicAnimate) {
    _inherits(ClipAngleAnimate, _ClipGraphicAnimate);
    var _super10 = _createSuper(ClipAngleAnimate);
    function ClipAngleAnimate(from, to, duration, easing, params) {
      var _this13;
      _classCallCheck(this, ClipAngleAnimate);
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      var groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {},
        width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0,
        height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0,
        animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : "in",
        startAngle = null !== (_f = null == params ? void 0 : params.startAngle) && void 0 !== _f ? _f : 0,
        orient = null !== (_g = null == params ? void 0 : params.orient) && void 0 !== _g ? _g : "clockwise";
      var arcStartAngle = 0,
        arcEndAngle = 0;
      "anticlockwise" === orient ? (arcEndAngle = "in" === animationType ? startAngle + 2 * Math.PI : startAngle, arcEndAngle = startAngle + 2 * Math.PI) : (arcStartAngle = startAngle, arcEndAngle = "out" === animationType ? startAngle + 2 * Math.PI : startAngle);
      var arc = application.graphicService.creator.arc({
        x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
        y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
        outerRadius: null !== (_m = null == params ? void 0 : params.radius) && void 0 !== _m ? _m : (width + height) / 2,
        innerRadius: 0,
        startAngle: arcStartAngle,
        endAngle: arcEndAngle,
        fill: !0
      });
      var fromAttributes, toAttributes;
      "anticlockwise" === orient ? (fromAttributes = {
        startAngle: startAngle + 2 * Math.PI
      }, toAttributes = {
        startAngle: startAngle
      }) : (fromAttributes = {
        endAngle: startAngle
      }, toAttributes = {
        endAngle: startAngle + 2 * Math.PI
      }), _this13 = _super10.call(this, "in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
        group: null == params ? void 0 : params.group,
        clipGraphic: arc
      });
      return _this13;
    }
    return _createClass(ClipAngleAnimate);
  }(ClipGraphicAnimate);
  var ClipRadiusAnimate = /*#__PURE__*/function (_ClipGraphicAnimate2) {
    _inherits(ClipRadiusAnimate, _ClipGraphicAnimate2);
    var _super11 = _createSuper(ClipRadiusAnimate);
    function ClipRadiusAnimate(from, to, duration, easing, params) {
      _classCallCheck(this, ClipRadiusAnimate);
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
      var groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {},
        width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0,
        height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0,
        animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : "in",
        startRadius = null !== (_f = null == params ? void 0 : params.startRadius) && void 0 !== _f ? _f : 0,
        endRadius = null !== (_g = null == params ? void 0 : params.endRadius) && void 0 !== _g ? _g : Math.sqrt(Math.pow(width / 2, 2) + Math.pow(height / 2, 2)),
        arc = application.graphicService.creator.arc({
          x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
          y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
          outerRadius: "out" === animationType ? endRadius : startRadius,
          innerRadius: 0,
          startAngle: 0,
          endAngle: 2 * Math.PI,
          fill: !0
        }),
        fromAttributes = {
          outerRadius: startRadius
        },
        toAttributes = {
          outerRadius: endRadius
        };
      return _super11.call(this, "in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
        group: null == params ? void 0 : params.group,
        clipGraphic: arc
      });
    }
    return _createClass(ClipRadiusAnimate);
  }(ClipGraphicAnimate);
  var ClipDirectionAnimate = /*#__PURE__*/function (_ClipGraphicAnimate3) {
    _inherits(ClipDirectionAnimate, _ClipGraphicAnimate3);
    var _super12 = _createSuper(ClipDirectionAnimate);
    function ClipDirectionAnimate(from, to, duration, easing, params) {
      var _this14;
      _classCallCheck(this, ClipDirectionAnimate);
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      var groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {},
        width = null !== (_d = null !== (_c = null == params ? void 0 : params.width) && void 0 !== _c ? _c : groupAttribute.width) && void 0 !== _d ? _d : 0,
        height = null !== (_f = null !== (_e = null == params ? void 0 : params.height) && void 0 !== _e ? _e : groupAttribute.height) && void 0 !== _f ? _f : 0,
        animationType = null !== (_g = null == params ? void 0 : params.animationType) && void 0 !== _g ? _g : "in",
        direction = null !== (_h = null == params ? void 0 : params.direction) && void 0 !== _h ? _h : "x",
        orient = null !== (_j = null == params ? void 0 : params.orient) && void 0 !== _j ? _j : "positive",
        rect = application.graphicService.creator.rect({
          x: 0,
          y: 0,
          width: "in" === animationType && "x" === direction ? 0 : width,
          height: "in" === animationType && "y" === direction ? 0 : height,
          fill: !0
        });
      var fromAttributes = {},
        toAttributes = {};
      "y" === direction ? "negative" === orient ? (fromAttributes = {
        y: height,
        height: 0
      }, toAttributes = {
        y: 0,
        height: height
      }) : (fromAttributes = {
        height: 0
      }, toAttributes = {
        height: height
      }) : "negative" === orient ? (fromAttributes = {
        x: width,
        width: 0
      }, toAttributes = {
        x: 0,
        width: width
      }) : (fromAttributes = {
        width: 0
      }, toAttributes = {
        width: width
      }), _this14 = _super12.call(this, "in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
        group: null == params ? void 0 : params.group,
        clipGraphic: rect
      });
      return _this14;
    }
    return _createClass(ClipDirectionAnimate);
  }(ClipGraphicAnimate);
  var RotateBySphereAnimate = /*#__PURE__*/function (_ACustomAnimate10) {
    _inherits(RotateBySphereAnimate, _ACustomAnimate10);
    var _super13 = _createSuper(RotateBySphereAnimate);
    function RotateBySphereAnimate() {
      _classCallCheck(this, RotateBySphereAnimate);
      return _super13.apply(this, arguments);
    }
    _createClass(RotateBySphereAnimate, [{
      key: "onStart",
      value: function onStart() {
        var _ref2 = "function" == typeof this.params ? this.params() : this.params,
          center = _ref2.center,
          r = _ref2.r,
          startX = this.target.getComputedAttribute("x"),
          startY = this.target.getComputedAttribute("y"),
          startZ = this.target.getComputedAttribute("z"),
          phi = Math.acos((startY - center.y) / r);
        var theta = Math.acos((startX - center.x) / r / Math.sin(phi));
        startZ - center.z < 0 && (theta = pi2 - theta), this.theta = theta, this.phi = phi;
      }
    }, {
      key: "onBind",
      value: function onBind() {}
    }, {
      key: "onEnd",
      value: function onEnd() {}
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        if (null == this.phi || null == this.theta) return;
        var _ref3 = "function" == typeof this.params ? this.params() : this.params,
          center = _ref3.center,
          r = _ref3.r,
          cb = _ref3.cb,
          deltaAngle = 2 * Math.PI * ratio,
          theta = this.theta + deltaAngle,
          phi = this.phi,
          x = r * Math.sin(phi) * Math.cos(theta) + center.x,
          y = r * Math.cos(phi) + center.y,
          z = r * Math.sin(phi) * Math.sin(theta) + center.z;
        for (out.x = x, out.y = y, out.z = z, out.alpha = theta + pi / 2; out.alpha > pi2;) out.alpha -= pi2;
        out.alpha = pi2 - out.alpha, out.zIndex = -1e4 * out.z, cb && cb(out);
      }
    }]);
    return RotateBySphereAnimate;
  }(ACustomAnimate);
  var GroupFadeIn = /*#__PURE__*/function (_ACustomAnimate11) {
    _inherits(GroupFadeIn, _ACustomAnimate11);
    var _super14 = _createSuper(GroupFadeIn);
    function GroupFadeIn() {
      _classCallCheck(this, GroupFadeIn);
      return _super14.apply(this, arguments);
    }
    _createClass(GroupFadeIn, [{
      key: "getEndProps",
      value: function getEndProps() {
        return {};
      }
    }, {
      key: "onBind",
      value: function onBind() {
        this.target.setTheme({
          common: {
            opacity: 0
          }
        });
      }
    }, {
      key: "onEnd",
      value: function onEnd() {
        this.target.setTheme({
          common: {
            opacity: 1
          }
        });
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        this.target.setTheme({
          common: {
            opacity: ratio
          }
        });
      }
    }]);
    return GroupFadeIn;
  }(ACustomAnimate);
  var GroupFadeOut = /*#__PURE__*/function (_ACustomAnimate12) {
    _inherits(GroupFadeOut, _ACustomAnimate12);
    var _super15 = _createSuper(GroupFadeOut);
    function GroupFadeOut() {
      _classCallCheck(this, GroupFadeOut);
      return _super15.apply(this, arguments);
    }
    _createClass(GroupFadeOut, [{
      key: "getEndProps",
      value: function getEndProps() {
        return {};
      }
    }, {
      key: "onBind",
      value: function onBind() {
        this.target.setTheme({
          common: {
            opacity: 1
          }
        });
      }
    }, {
      key: "onEnd",
      value: function onEnd() {
        this.target.setTheme({
          common: {
            opacity: 0
          }
        });
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        this.target.setTheme({
          common: {
            opacity: 1 - ratio
          }
        });
      }
    }]);
    return GroupFadeOut;
  }(ACustomAnimate);
  var AttributeAnimate = /*#__PURE__*/function (_ACustomAnimate13) {
    _inherits(AttributeAnimate, _ACustomAnimate13);
    var _super16 = _createSuper(AttributeAnimate);
    function AttributeAnimate(to, duration, easing) {
      _classCallCheck(this, AttributeAnimate);
      return _super16.call(this, {}, to, duration, easing);
    }
    _createClass(AttributeAnimate, [{
      key: "getEndProps",
      value: function getEndProps() {
        return this.to;
      }
    }, {
      key: "onBind",
      value: function onBind() {
        var _this15 = this;
        Object.keys(this.to).forEach(function (k) {
          _this15.from[k] = _this15.target.getComputedAttribute(k);
        });
      }
    }, {
      key: "onEnd",
      value: function onEnd() {}
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        this.target.stepInterpolate(this.subAnimate, this.subAnimate.animate, out, this.step, ratio, end, this.to, this.from);
      }
    }]);
    return AttributeAnimate;
  }(ACustomAnimate);
  var AnimateGroup = /*#__PURE__*/function (_ACustomAnimate14) {
    _inherits(AnimateGroup, _ACustomAnimate14);
    var _super17 = _createSuper(AnimateGroup);
    function AnimateGroup(duration, customAnimates) {
      var _this16;
      _classCallCheck(this, AnimateGroup);
      _this16 = _super17.call(this, null, null, duration, "linear"), _this16.customAnimates = customAnimates;
      return _this16;
    }
    _createClass(AnimateGroup, [{
      key: "initAnimates",
      value: function initAnimates() {
        var _this17 = this;
        this.customAnimates.forEach(function (a) {
          a.step = _this17.step, a.subAnimate = _this17.subAnimate, a.target = _this17.target;
        });
      }
    }, {
      key: "getEndProps",
      value: function getEndProps() {
        var props = {};
        return this.customAnimates.forEach(function (a) {
          Object.assign(props, a.getEndProps());
        }), props;
      }
    }, {
      key: "onBind",
      value: function onBind() {
        this.initAnimates(), this.customAnimates.forEach(function (a) {
          a.onBind();
        });
      }
    }, {
      key: "onEnd",
      value: function onEnd() {
        this.customAnimates.forEach(function (a) {
          a.onEnd();
        });
      }
    }, {
      key: "onStart",
      value: function onStart() {
        this.customAnimates.forEach(function (a) {
          a.onStart();
        });
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        this.updating || (this.updating = !0, this.customAnimates.forEach(function (a) {
          var easing = a.easing,
            easingFunc = "string" == typeof easing ? Easing[easing] : easing;
          ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);
        }), this.updating = !1);
      }
    }]);
    return AnimateGroup;
  }(ACustomAnimate);
  var AnimateGroup1 = /*#__PURE__*/function (_ACustomAnimate15) {
    _inherits(AnimateGroup1, _ACustomAnimate15);
    var _super18 = _createSuper(AnimateGroup1);
    function AnimateGroup1(duration, customAnimates) {
      var _this18;
      _classCallCheck(this, AnimateGroup1);
      _this18 = _super18.call(this, null, null, duration, "linear"), _this18.customAnimates = customAnimates;
      return _this18;
    }
    _createClass(AnimateGroup1, [{
      key: "initAnimates",
      value: function initAnimates() {
        var _this19 = this;
        this.customAnimates.forEach(function (a) {
          a.step = _this19.step, a.subAnimate = _this19.subAnimate, a.target = _this19.target;
        });
      }
    }, {
      key: "getEndProps",
      value: function getEndProps() {
        var props = {};
        return this.customAnimates.forEach(function (a) {
          Object.assign(props, a.getEndProps());
        }), props;
      }
    }, {
      key: "onBind",
      value: function onBind() {
        this.initAnimates(), this.customAnimates.forEach(function (a) {
          a.onBind();
        });
      }
    }, {
      key: "onEnd",
      value: function onEnd() {
        this.customAnimates.forEach(function (a) {
          a.onEnd();
        });
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        this.updating || (this.updating = !0, this.customAnimates.forEach(function (a) {
          var easing = a.easing,
            easingFunc = "string" == typeof easing ? Easing[easing] : easing;
          ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);
        }), this.updating = !1);
      }
    }]);
    return AnimateGroup1;
  }(ACustomAnimate);

  function cubicSubdivide(p0, p1, p2, p3, t, out) {
    var p01 = (p1 - p0) * t + p0,
      p12 = (p2 - p1) * t + p1,
      p23 = (p3 - p2) * t + p2,
      p012 = (p12 - p01) * t + p01,
      p123 = (p23 - p12) * t + p12,
      p0123 = (p123 - p012) * t + p012;
    out[0] = p0, out[1] = p01, out[2] = p012, out[3] = p0123, out[4] = p0123, out[5] = p123, out[6] = p23, out[7] = p3;
  }
  function alignSubpath(subpath1, subpath2) {
    var len1 = subpath1.length,
      len2 = subpath2.length;
    if (len1 === len2) return [subpath1, subpath2];
    var tmpSegX = [],
      tmpSegY = [],
      shorterPath = len1 < len2 ? subpath1 : subpath2,
      shorterLen = Math.min(len1, len2),
      diff = Math.abs(len2 - len1) / 6,
      shorterBezierCount = (shorterLen - 2) / 6,
      eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount),
      newSubpath = [shorterPath[0], shorterPath[1]];
    var remained = diff;
    for (var i = 2; i < shorterLen; i += 6) {
      var x0 = shorterPath[i - 2],
        y0 = shorterPath[i - 1],
        x1 = shorterPath[i],
        y1 = shorterPath[i + 1],
        x2 = shorterPath[i + 2],
        y2 = shorterPath[i + 3];
      var x3 = shorterPath[i + 4],
        y3 = shorterPath[i + 5];
      if (remained <= 0) {
        newSubpath.push(x1, y1, x2, y2, x3, y3);
        continue;
      }
      var actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;
      for (var k = 1; k <= actualSubDivCount; k++) {
        var p = k / actualSubDivCount;
        cubicSubdivide(x0, x1, x2, x3, p, tmpSegX), cubicSubdivide(y0, y1, y2, y3, p, tmpSegY), x0 = tmpSegX[3], y0 = tmpSegY[3], newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0), x1 = tmpSegX[5], y1 = tmpSegY[5], x2 = tmpSegX[6], y2 = tmpSegY[6];
      }
      remained -= actualSubDivCount - 1;
    }
    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
  }
  function createSubpath(lastSubpath, otherSubpath) {
    var prevSubPath = lastSubpath || otherSubpath,
      len = prevSubPath.length,
      lastX = prevSubPath[len - 2],
      lastY = prevSubPath[len - 1],
      newSubpath = [];
    for (var i = 0; i < otherSubpath.length; i += 2) newSubpath[i] = lastX, newSubpath[i + 1] = lastY;
    return newSubpath;
  }
  function reverseSubpath(array) {
    var newArr = [],
      len = array.length;
    for (var i = 0; i < len; i += 2) newArr[i] = array[len - i - 2], newArr[i + 1] = array[len - i - 1];
    return newArr;
  }
  function centroidOfSubpath(array) {
    var signedArea = 0,
      cx = 0,
      cy = 0;
    var len = array.length;
    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {
      var x0 = array[j],
        y0 = array[j + 1],
        x1 = array[i],
        y1 = array[i + 1],
        a = x0 * y1 - x1 * y0;
      signedArea += a, cx += (x0 + x1) * a, cy += (y0 + y1) * a;
    }
    return 0 === signedArea ? [array[0] || 0, array[1] || 0, 0] : [cx / signedArea / 3, cy / signedArea / 3, signedArea];
  }
  function findBestRotationOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
    var bezierCount = (fromSubBeziers.length - 2) / 6;
    var bestScore = 1 / 0,
      bestOffset = 0;
    var len = fromSubBeziers.length,
      len2 = len - 2;
    for (var offset = 0; offset < bezierCount; offset++) {
      var cursorOffset = 6 * offset;
      var score = 0;
      for (var k = 0; k < len; k += 2) {
        var idx = 0 === k ? cursorOffset : (cursorOffset + k - 2) % len2 + 2,
          x0 = fromSubBeziers[idx] - fromCp[0],
          y0 = fromSubBeziers[idx + 1] - fromCp[1],
          dx = toSubBeziers[k] - toCp[0] - x0,
          dy = toSubBeziers[k + 1] - toCp[1] - y0;
        score += dx * dx + dy * dy;
      }
      score < bestScore && (bestScore = score, bestOffset = offset);
    }
    return bestOffset;
  }
  function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
    var result = [];
    var fromNeedsReverse;
    for (var i = 0; i < fromArr.length; i++) {
      var fromSubpathBezier = fromArr[i];
      var toSubpathBezier = toArr[i],
        fromCp = centroidOfSubpath(fromSubpathBezier),
        toCp = centroidOfSubpath(toSubpathBezier);
      null == fromNeedsReverse && (fromNeedsReverse = fromCp[2] < 0 != toCp[2] < 0);
      var newFromSubpathBezier = [],
        newToSubpathBezier = [];
      var bestAngle = 0,
        bestScore = 1 / 0;
      var tmpArr = [],
        len = fromSubpathBezier.length;
      fromNeedsReverse && (fromSubpathBezier = reverseSubpath(fromSubpathBezier));
      var offset = 6 * findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp),
        len2 = len - 2;
      for (var k = 0; k < len2; k += 2) {
        var idx = (offset + k) % len2 + 2;
        newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0], newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
      }
      if (newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0], newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1], searchAngleIteration > 0) {
        var step = searchAngleRange / searchAngleIteration;
        for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
          var sa = Math.sin(angle),
            ca = Math.cos(angle);
          var score = 0;
          for (var _k = 0; _k < fromSubpathBezier.length; _k += 2) {
            var x0 = newFromSubpathBezier[_k],
              y0 = newFromSubpathBezier[_k + 1],
              x1 = toSubpathBezier[_k] - toCp[0],
              y1 = toSubpathBezier[_k + 1] - toCp[1],
              newX1 = x1 * ca - y1 * sa,
              newY1 = x1 * sa + y1 * ca;
            tmpArr[_k] = newX1, tmpArr[_k + 1] = newY1;
            var dx = newX1 - x0,
              dy = newY1 - y0;
            score += dx * dx + dy * dy;
          }
          if (score < bestScore) {
            bestScore = score, bestAngle = angle;
            for (var m = 0; m < tmpArr.length; m++) newToSubpathBezier[m] = tmpArr[m];
          }
        }
      } else for (var _i = 0; _i < len; _i += 2) newToSubpathBezier[_i] = toSubpathBezier[_i] - toCp[0], newToSubpathBezier[_i + 1] = toSubpathBezier[_i + 1] - toCp[1];
      result.push({
        from: newFromSubpathBezier,
        to: newToSubpathBezier,
        fromCp: fromCp,
        toCp: toCp,
        rotation: -bestAngle
      });
    }
    return result;
  }
  function alignBezierCurves(array1, array2) {
    var lastSubpath1, lastSubpath2;
    var newArray1 = [],
      newArray2 = [];
    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {
      var _alignSubpath, _alignSubpath2;
      var subpath1 = array1[i],
        subpath2 = array2[i];
      var newSubpath1 = void 0,
        newSubpath2 = void 0;
      subpath1 ? subpath2 ? ((_alignSubpath = alignSubpath(subpath1, subpath2), _alignSubpath2 = _slicedToArray(_alignSubpath, 2), newSubpath1 = _alignSubpath2[0], newSubpath2 = _alignSubpath2[1]), lastSubpath1 = newSubpath1, lastSubpath2 = newSubpath2) : (newSubpath2 = createSubpath(lastSubpath2, subpath1), newSubpath1 = subpath1) : (newSubpath1 = createSubpath(lastSubpath1, subpath2), newSubpath2 = subpath2), newArray1.push(newSubpath1), newArray2.push(newSubpath2);
    }
    return [newArray1, newArray2];
  }
  var addLineToBezierPath = function addLineToBezierPath(bezierPath, x0, y0, x1, y1) {
    isNumberClose(x0, x1) && isNumberClose(y0, y1) || bezierPath.push(x0, y0, x1, y1, x1, y1);
  };
  function pathToBezierCurves(path) {
    var commandList = path.commandList,
      bezierArrayGroups = [];
    var currentSubpath,
      xi = 0,
      yi = 0,
      x0 = 0,
      y0 = 0;
    var createNewSubpath = function createNewSubpath(x, y) {
      currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), currentSubpath = [x, y];
    };
    var x1, y1, x2, y2;
    for (var i = 0, len = commandList.length; i < len; i++) {
      var cmd = commandList[i],
        isFirst = 0 === i;
      switch (isFirst && (x0 = xi = cmd[1], y0 = yi = cmd[2], [enumCommandMap.L, enumCommandMap.C, enumCommandMap.Q].includes(cmd[0]) && (currentSubpath = [x0, y0])), cmd[0]) {
        case enumCommandMap.M:
          xi = x0 = cmd[1], yi = y0 = cmd[2], createNewSubpath(x0, y0);
          break;
        case enumCommandMap.L:
          x1 = cmd[1], y1 = cmd[2], addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xi = x1, yi = y1;
          break;
        case enumCommandMap.C:
          currentSubpath.push(cmd[1], cmd[2], cmd[3], cmd[4], xi = cmd[5], yi = cmd[6]);
          break;
        case enumCommandMap.Q:
          x1 = cmd[1], y1 = cmd[2], x2 = cmd[3], y2 = cmd[4], currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2), xi = x2, yi = y2;
          break;
        case enumCommandMap.A:
          {
            var cx = cmd[1],
              cy = cmd[2],
              rx = cmd[3],
              ry = rx,
              startAngle = cmd[4],
              endAngle = cmd[5],
              counterClockwise = !!cmd[6];
            x1 = Math.cos(startAngle) * rx + cx, y1 = Math.sin(startAngle) * rx + cy, isFirst ? (x0 = x1, y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xi = Math.cos(endAngle) * rx + cx, yi = Math.sin(endAngle) * rx + cy;
            var step = (counterClockwise ? -1 : 1) * Math.PI / 2;
            for (var angle = startAngle; counterClockwise ? angle > endAngle : angle < endAngle; angle += step) {
              var nextAngle = counterClockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
              addArcToBezierPath$1(currentSubpath, angle, nextAngle, cx, cy, rx, ry);
            }
            break;
          }
        case enumCommandMap.E:
          {
            var _cx = cmd[1],
              _cy = cmd[2],
              _rx = cmd[3],
              _ry = cmd[4],
              rotate = cmd[5],
              _startAngle = cmd[6],
              _endAngle = cmd[7] + _startAngle,
              anticlockwise = !!cmd[8],
              hasRotate = !isNumberClose(rotate, 0),
              rc = Math.cos(rotate),
              rs = Math.sin(rotate);
            var xTemp = Math.cos(_startAngle) * _rx,
              yTemp = Math.sin(_startAngle) * _ry;
            hasRotate ? (x1 = xTemp * rc - yTemp * rs + _cx, y1 = xTemp * rs + yTemp * rc + _cy) : (x1 = xTemp + _cx, y1 = yTemp + _cy), isFirst ? (x0 = x1, y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xTemp = Math.cos(_endAngle) * _rx, yTemp = Math.sin(_endAngle) * _ry, hasRotate ? (xi = xTemp * rc - yTemp * rs + _cx, yi = xTemp * rs + yTemp * rc + _cy) : (xi = xTemp + _cx, yi = yTemp + _cy);
            var _step = (anticlockwise ? -1 : 1) * Math.PI / 2;
            for (var _angle = _startAngle; anticlockwise ? _angle > _endAngle : _angle < _endAngle; _angle += _step) {
              var _nextAngle = anticlockwise ? Math.max(_angle + _step, _endAngle) : Math.min(_angle + _step, _endAngle);
              if (addArcToBezierPath$1(currentSubpath, _angle, _nextAngle, _cx, _cy, _rx, _ry), hasRotate) {
                var curLen = currentSubpath.length;
                for (var j = curLen - 6; j <= curLen - 1; j += 2) xTemp = currentSubpath[j], yTemp = currentSubpath[j + 1], currentSubpath[j] = (xTemp - _cx) * rc - (yTemp - _cy) * rs + _cx, currentSubpath[j + 1] = (xTemp - _cx) * rs + (yTemp - _cy) * rc + _cy;
              }
            }
            break;
          }
        case enumCommandMap.R:
          x0 = xi = cmd[1], y0 = yi = cmd[2], x1 = x0 + cmd[3], y1 = y0 + cmd[4], createNewSubpath(x1, y0), addLineToBezierPath(currentSubpath, x1, y0, x1, y1), addLineToBezierPath(currentSubpath, x1, y1, x0, y1), addLineToBezierPath(currentSubpath, x0, y1, x0, y0), addLineToBezierPath(currentSubpath, x0, y0, x1, y0);
          break;
        case enumCommandMap.AT:
          {
            var tx1 = cmd[1],
              ty1 = cmd[2],
              tx2 = cmd[3],
              ty2 = cmd[4],
              r = cmd[5],
              dis1 = PointService.distancePP({
                x: xi,
                y: yi
              }, {
                x: tx1,
                y: ty1
              }),
              dis2 = PointService.distancePP({
                x: tx2,
                y: ty2
              }, {
                x: tx1,
                y: ty1
              }),
              theta = ((xi - tx1) * (tx2 - tx1) + (yi - ty1) * (ty2 - ty1)) / (dis1 * dis2),
              dis = r / Math.sin(theta / 2),
              midX = (xi + tx2 - 2 * tx1) / 2,
              midY = (yi + ty2 - 2 * ty1) / 2,
              midLen = PointService.distancePP({
                x: midX,
                y: midY
              }, {
                x: 0,
                y: 0
              }),
              _cx2 = tx1 + dis * midX / midLen,
              _cy2 = tx2 + dis * midY / midLen,
              disP = Math.sqrt(dis * dis - r * r);
            x0 = tx1 + disP * (xi - tx1) / dis1, y0 = ty1 + disP * (yi - ty1) / dis1, addLineToBezierPath(currentSubpath, xi, yi, x0, y0), xi = tx1 + disP * (tx2 - tx1) / dis2, yi = ty1 + disP * (ty2 - ty1) / dis2;
            var _startAngle2 = getAngleByPoint({
                x: _cx2,
                y: _cy2
              }, {
                x: x0,
                y: y0
              }),
              _endAngle2 = getAngleByPoint({
                x: _cx2,
                y: _cy2
              }, {
                x: xi,
                y: yi
              });
            addArcToBezierPath$1(currentSubpath, _startAngle2, _endAngle2, _cx2, _cy2, r, r);
            break;
          }
        case enumCommandMap.Z:
          currentSubpath && addLineToBezierPath(currentSubpath, xi, yi, x0, y0), xi = x0, yi = y0;
      }
    }
    return currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), bezierArrayGroups;
  }
  function applyTransformOnBezierCurves(bezierCurves, martrix) {
    for (var i = 0; i < bezierCurves.length; i++) {
      var subPath = bezierCurves[i];
      for (var k = 0; k < subPath.length; k += 2) {
        var x = subPath[k],
          y = subPath[k + 1],
          res = {
            x: x,
            y: y
          };
        martrix.transformPoint({
          x: x,
          y: y
        }, res), subPath[k] = res.x, subPath[k + 1] = res.y;
      }
    }
  }
  function bezierCurversToPath(bezierCurves) {
    var path = new CustomPath2D();
    for (var i = 0; i < bezierCurves.length; i++) {
      var subPath = bezierCurves[i];
      if (subPath.length > 2) {
        path.moveTo(subPath[0], subPath[1]);
        for (var k = 2; k < subPath.length; k += 6) path.bezierCurveTo(subPath[k], subPath[k + 1], subPath[k + 2], subPath[k + 3], subPath[k + 4], subPath[k + 5]);
      }
    }
    return path;
  }

  var normalizeRectAttributes = function normalizeRectAttributes(attribute) {
    if (!attribute) return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var width = isNil$1(attribute.width) ? attribute.x1 - attribute.x : attribute.width,
      height = isNil$1(attribute.height) ? attribute.y1 - attribute.y : attribute.height,
      x = 0,
      y = 0;
    return width < 0 ? (x = width, width = -width) : Number.isNaN(width) && (width = 0), height < 0 ? (y = height, height = -height) : Number.isNaN(height) && (height = 0), {
      x: x,
      y: y,
      width: width,
      height: height
    };
  };

  function splitToGrids(width, height, count) {
    var ratio = width / height;
    var rowCount, columnCount;
    width >= height ? (columnCount = Math.ceil(Math.sqrt(count * ratio)), rowCount = Math.floor(count / columnCount), 0 === rowCount && (rowCount = 1, columnCount = count)) : (rowCount = Math.ceil(Math.sqrt(count / ratio)), columnCount = Math.floor(count / rowCount), 0 === columnCount && (columnCount = 1, rowCount = count));
    var grids = [];
    for (var i = 0; i < rowCount; i++) grids.push(columnCount);
    var remained = count - rowCount * columnCount;
    if (remained > 0) for (var _i = 0; _i < remained; _i += columnCount) _i + columnCount < remained ? grids.push(columnCount) : grids.push(remained - _i);
    return grids;
  }
  var splitRect = function splitRect(rect, count) {
    var _normalizeRectAttribu = normalizeRectAttributes(rect.attribute),
      width = _normalizeRectAttribu.width,
      height = _normalizeRectAttribu.height,
      grids = splitToGrids(width, height, count),
      res = [],
      gridHeight = height / grids.length;
    for (var i = 0, rowCount = grids.length; i < rowCount; i++) {
      var columnCount = grids[i],
        gridWidth = width / columnCount;
      for (var j = 0; j < columnCount; j++) res.push({
        x: 0 + j * gridWidth,
        y: 0 + i * gridHeight,
        width: gridWidth,
        height: gridHeight
      });
    }
    return res;
  };
  var splitArc = function splitArc(arc, count) {
    var angles = arc.getParsedAngle(),
      startAngle = angles.startAngle,
      endAngle = angles.endAngle,
      innerRadius = arc.getComputedAttribute("innerRadius"),
      outerRadius = arc.getComputedAttribute("outerRadius"),
      angleDelta = Math.abs(startAngle - endAngle),
      radiusDelta = Math.abs(outerRadius - innerRadius),
      grids = splitToGrids(angleDelta * (innerRadius + outerRadius) / 2, radiusDelta, count),
      res = [],
      gridRadius = radiusDelta / grids.length,
      radiusSign = outerRadius >= innerRadius ? 1 : -1,
      angleSign = endAngle >= startAngle ? 1 : -1;
    for (var i = 0, rowCount = grids.length; i < rowCount; i++) {
      var columnCount = grids[i],
        gridAngle = angleDelta / columnCount;
      for (var j = 0; j < columnCount; j++) res.push({
        innerRadius: outerRadius - gridRadius * i * radiusSign,
        outerRadius: outerRadius - gridRadius * (i + 1) * radiusSign,
        startAngle: startAngle + gridAngle * j * angleSign,
        endAngle: startAngle + gridAngle * (j + 1) * angleSign
      });
    }
    return res;
  };
  var splitCircle = function splitCircle(arc, count) {
    var startAngle = arc.getComputedAttribute("startAngle"),
      endAngle = arc.getComputedAttribute("endAngle"),
      radius = arc.getComputedAttribute("radius"),
      angleDelta = Math.abs(startAngle - endAngle),
      grids = splitToGrids(angleDelta * radius, radius, count),
      res = [],
      gridAngle = angleDelta / grids[0],
      gridRadius = radius / grids.length,
      angleSign = endAngle >= startAngle ? 1 : -1;
    for (var i = 0, rowCount = grids.length; i < rowCount; i++) for (var j = 0, columnCount = grids[i]; j < columnCount; j++) res.push({
      innerRadius: gridRadius * i,
      outerRadius: gridRadius * (i + 1),
      startAngle: startAngle + gridAngle * j * angleSign,
      endAngle: startAngle + gridAngle * (j + 1) * angleSign
    });
    return res;
  };
  var samplingPoints = function samplingPoints(points, count) {
    var validatePoints = points.filter(function (point) {
      return !1 !== point.defined && isNumber$1(point.x) && isNumber$1(point.y);
    });
    if (0 === validatePoints.length) return [];
    if (1 === validatePoints.length) return new Array(count).fill(0).map(function (i) {
      return validatePoints[0];
    });
    var res = [];
    if (count <= validatePoints.length) {
      var step = validatePoints.length / count;
      var i = 0,
        cur = 0;
      for (; i < count;) res.push(validatePoints[Math.floor(cur)]), cur += step, i++;
      return res;
    }
    var insertCount = count - validatePoints.length,
      insetRatio = 1 / (insertCount / (validatePoints.length - 1) + 1);
    var curCount = 0;
    for (var _i2 = 0, len = points.length; _i2 < len; _i2++) if (res.push(points[_i2]), _i2 < len - 1) {
      var _cur = insetRatio;
      var xCur = points[_i2].x,
        yCur = points[_i2].y,
        xNext = points[_i2 + 1].x,
        yNext = points[_i2 + 1].y;
      for (; _cur < 1 && curCount < insertCount;) res.push({
        x: xCur + (xNext - xCur) * _cur,
        y: yCur + (yNext - yCur) * _cur
      }), _cur += insetRatio, curCount += 1;
    }
    return res;
  };
  var splitArea = function splitArea(area, count) {
    var _a, _b;
    var attribute = area.attribute;
    var points = attribute.points;
    var segements = attribute.segments;
    points || (points = segements.reduce(function (res, seg) {
      var _a;
      return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
    }, []));
    var validatePoints = points.filter(function (point) {
      return !1 !== point.defined && isNumber$1(point.x) && isNumber$1(point.y);
    });
    if (!validatePoints.length) return [];
    var allPoints = [];
    validatePoints.forEach(function (point) {
      allPoints.push({
        x: point.x,
        y: point.y
      });
    });
    for (var i = validatePoints.length - 1; i >= 0; i--) {
      var point = validatePoints[i];
      allPoints.push({
        x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
        y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
      });
    }
    var res = [];
    return recursiveCallBinarySplit(points, count, res), res;
  };
  var splitLine = function splitLine(line, count) {
    var attribute = line.attribute,
      points = attribute.points;
    if (points) return samplingPoints(points, count);
    if (attribute.segments) {
      var allPoints = attribute.segments.reduce(function (res, seg) {
        var _a;
        return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
      }, []);
      return samplingPoints(allPoints, count);
    }
    return [];
  };
  function crossProduct(dir1, dir2) {
    return dir1[0] * dir2[1] - dir1[1] * dir2[0];
  }
  var clonePoints = function clonePoints(points) {
      return points.map(function (p) {
        return {
          x: p.x,
          y: p.y
        };
      });
    },
    splitPolygonByLine = function splitPolygonByLine(points, p0, p1) {
      var _ref;
      var len = points.length,
        intersections = [];
      for (var i = 0; i < len; i++) {
        var cur = points[i],
          next = i === len - 1 ? points[0] : points[i + 1],
          res = getIntersectPoint([p0.x, p0.y], [p1.x, p1.y], [cur.x, cur.y], [next.x, next.y]);
        res && "boolean" != typeof res && intersections.push({
          dot: crossProduct([res[0] - p0.x, res[1] - p0.x], [p1.x - p0.x, p1.y - p0.x]),
          point: {
            x: res[0],
            y: res[1]
          },
          edgeIndex: i
        });
      }
      if (intersections.length < 2) return [clonePoints(points), clonePoints(points)];
      intersections.sort(function (a, b) {
        return a.dot - b.dot;
      });
      var is0 = intersections[0],
        is1 = intersections[intersections.length - 1];
      is0.edgeIndex > is1.edgeIndex && (_ref = [is1, is0], is0 = _ref[0], is1 = _ref[1], _ref);
      var newP0 = is0.point,
        newP1 = is1.point,
        newPointsA = [{
          x: newP0.x,
          y: newP0.y
        }];
      for (var _i3 = is0.edgeIndex + 1; _i3 <= is1.edgeIndex; _i3++) newPointsA.push({
        x: points[_i3].x,
        y: points[_i3].y
      });
      newPointsA.push({
        x: newP1.x,
        y: newP1.y
      });
      var newPointsB = [{
        x: newP1.x,
        y: newP1.y
      }];
      for (var _i4 = is1.edgeIndex + 1, maxIndex = is0.edgeIndex + len; _i4 <= maxIndex; _i4++) {
        var p = points[_i4 % len];
        newPointsB.push({
          x: p.x,
          y: p.y
        });
      }
      return newPointsB.push({
        x: newP0.x,
        y: newP0.y
      }), [newPointsA, newPointsB];
    };
  var binarySplitPolygon = function binarySplitPolygon(points) {
    var box = new Bounds();
    points.forEach(function (point) {
      box.add(point.x, point.y);
    });
    var width = box.width(),
      height = box.height();
    if (width >= height) {
      var midX = box.x1 + width / 2;
      return splitPolygonByLine(points, {
        x: midX,
        y: box.y1
      }, {
        x: midX,
        y: box.y2
      });
    }
    var midY = box.y1 + height / 2;
    return splitPolygonByLine(points, {
      x: box.x1,
      y: midY
    }, {
      x: box.x2,
      y: midY
    });
  };
  var recursiveCallBinarySplit = function recursiveCallBinarySplit(points, count, out) {
    if (1 === count) out.push({
      points: points
    });else {
      var half = Math.floor(count / 2),
        res = binarySplitPolygon(points);
      recursiveCallBinarySplit(res[0], half, out), recursiveCallBinarySplit(res[1], count - half, out);
    }
  };
  var splitPolygon = function splitPolygon(polygon, count) {
    var points = polygon.attribute.points;
    if (!points || !points.length) return [];
    if (1 === count) return [{
      points: clonePoints(points)
    }];
    var res = [];
    return recursiveCallBinarySplit(points, count, res), res;
  };
  var splitPath = function splitPath(path, count) {
    var pathShape = path.getParsedPathShape(),
      bezierCurves = pathToBezierCurves(pathShape);
    if (!bezierCurves.length || count < 0) return [];
    var subPathCnt = bezierCurves.length;
    if (bezierCurves.length >= count) {
      var _res = [],
        _stepCount = Math.floor(bezierCurves.length / count);
      for (var i = 0; i < count; i++) {
        var curves = bezierCurves.slice(i * _stepCount, i === count - 1 ? subPathCnt : (i + 1) * _stepCount);
        _res.push({
          path: bezierCurversToPath(curves)
        });
      }
      return _res;
    }
    var res = [],
      stepCount = Math.floor(count / subPathCnt);
    var remain = count;
    for (var c = 0; c < subPathCnt; c++) {
      var points = [];
      for (var _i5 = 2, len = bezierCurves[c].length; _i5 < len; _i5 += 2) points.push({
        x: bezierCurves[0][_i5],
        y: bezierCurves[0][_i5 + 1]
      });
      recursiveCallBinarySplit(points, c === subPathCnt - 1 ? remain : stepCount, res), remain -= stepCount;
    }
    return res;
  };

  function colorEqual(color1, color2) {
    var c1 = Color.parseColorString(color1),
      c2 = Color.parseColorString(color2);
    return !(!c1 || !c2) && c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.opacity === c2.opacity;
  }
  exports.ColorType = void 0;
  !function (ColorType) {
    ColorType[ColorType.Color255 = 0] = "Color255", ColorType[ColorType.Color1 = 1] = "Color1";
  }(exports.ColorType || (exports.ColorType = {}));
  var ColorStore = /*#__PURE__*/function () {
    function ColorStore() {
      _classCallCheck(this, ColorStore);
    }
    _createClass(ColorStore, null, [{
      key: "Get",
      value: function Get(str) {
        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : exports.ColorType.Color1;
        var arr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0, 1];
        if (size === exports.ColorType.Color1) {
          var _color = ColorStore.store1[str];
          if (_color) return arr[0] = _color[0], arr[1] = _color[1], arr[2] = _color[2], arr[3] = _color[3], arr;
          var _c = Color.parseColorString(str);
          if (_c) {
            var data = [_c.r / 255, _c.g / 255, _c.b / 255, _c.opacity];
            ColorStore.store1[str] = data, ColorStore.store255[str] = [_c.r, _c.g, _c.b, _c.opacity], arr[0] = data[0], arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
          }
          return arr;
        }
        var color = ColorStore.store255[str];
        if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
        var c = Color.parseColorString(str);
        return c && (ColorStore.store1[str] = [c.r / 255, c.g / 255, c.b / 255, c.opacity], ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity], arr[0] = c.r, arr[1] = c.g, arr[2] = c.b, arr[3] = c.opacity), arr;
      }
    }, {
      key: "Set",
      value: function Set(str, size, arr) {
        if (size === exports.ColorType.Color1) {
          if (ColorStore.store1[str]) return;
          ColorStore.store1[str] = arr, ColorStore.store255[str] = [Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3])];
        } else {
          if (ColorStore.store255[str]) return;
          ColorStore.store255[str] = arr, ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
        }
      }
    }]);
    return ColorStore;
  }();
  ColorStore.store255 = {}, ColorStore.store1 = {};

  function colorArrayToString(color) {
    var alphaChannel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return Array.isArray(color) ? alphaChannel ? "rgb(".concat(Math.round(color[0]), ",").concat(Math.round(color[1]), ",").concat(Math.round(color[2]), ",").concat(color[3].toFixed(2), ")") : "rgb(".concat(Math.round(color[0]), ",").concat(Math.round(color[1]), ",").concat(Math.round(color[2]), ")") : color;
  }
  function interpolateColor(from, to, ratio, alphaChannel, cb) {
    if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || !1;
    var fromArray,
      toArray,
      fromGradient = !1,
      toGradient = !1;
    if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, exports.ColorType.Color255) : fromGradient = !0, Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, exports.ColorType.Color255) : toGradient = !0, fromGradient !== toGradient) {
      var gradient = fromGradient ? from : to,
        pure = fromGradient ? to : from,
        gradientFromPure = Object.assign(Object.assign({}, gradient), {
          stops: gradient.stops.map(function (v) {
            return Object.assign(Object.assign({}, v), {
              color: colorArrayToString(pure)
            });
          })
        });
      return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
    }
    if (fromGradient) {
      if (from.gradient === to.gradient) {
        var fc = from,
          tc = to,
          fromStops = fc.stops,
          toStops = tc.stops;
        if (fromStops.length !== toStops.length) return !1;
        if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
        if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
        if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
      }
      return !1;
    }
    cb && cb(fromArray, toArray);
    return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
  }
  function interpolateGradientLinearColor(fc, tc, ratio) {
    var fStops = fc.stops,
      tStops = tc.stops;
    return {
      gradient: "linear",
      x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
      x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
      y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
      y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
      stops: new Array(fStops.length).fill(0).map(function (_, i) {
        return {
          color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
          offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        };
      })
    };
  }
  function interpolateGradientRadialColor(fc, tc, ratio) {
    var fStops = fc.stops,
      tStops = tc.stops;
    return {
      gradient: "radial",
      x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
      x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
      y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
      y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
      r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
      r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
      stops: new Array(fStops.length).fill(0).map(function (_, i) {
        return {
          color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
          offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        };
      })
    };
  }
  function interpolateGradientConicalColor(fc, tc, ratio) {
    var fStops = fc.stops,
      tStops = tc.stops;
    return {
      gradient: "conical",
      startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
      endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
      x: fc.x + (tc.x - fc.x) * ratio,
      y: fc.y + (tc.y - fc.y) * ratio,
      stops: new Array(fStops.length).fill(0).map(function (_, i) {
        return {
          color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
          offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        };
      })
    };
  }
  function interpolatePureColorArray(from, to, ratio) {
    return [from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio];
  }
  var _fromColorRGB = [0, 0, 0, 0],
    _toColorRGB = [0, 0, 0, 0];
  function colorStringInterpolationToStr(fromColor, toColor, ratio) {
    return ColorStore.Get(fromColor, exports.ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, exports.ColorType.Color255, _toColorRGB), "rgba(".concat(Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio), ",").concat(Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio), ",").concat(Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio), ",").concat(_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio, ")");
  }

  var interpolateOtherAttrs = function interpolateOtherAttrs(attrs, out, ratio) {
      attrs.forEach(function (entry) {
        if (Number.isFinite(entry.to)) out[entry.key] = entry.from + (entry.to - entry.from) * ratio;else if ("fill" === entry.key || "stroke" === entry.key) {
          var color = interpolateColor(entry.from, entry.to, ratio, !1);
          color && (out[entry.key] = color);
        }
      });
    },
    interpolateMorphingData = function interpolateMorphingData(morphingData, path, ratio) {
      var tmpArr = [],
        newCp = [];
      path.clear();
      for (var i = 0; i < morphingData.length; i++) {
        var item = morphingData[i],
          from = item.from,
          to = item.to,
          angle = item.rotation * ratio,
          fromCp = item.fromCp,
          toCp = item.toCp,
          sa = Math.sin(angle),
          ca = Math.cos(angle);
        newCp[0] = fromCp[0] + (toCp[0] - fromCp[0]) * ratio, newCp[1] = fromCp[1] + (toCp[1] - fromCp[1]) * ratio;
        for (var m = 0; m < from.length; m += 2) {
          var _x = from[m],
            _y = from[m + 1],
            x = _x * (1 - ratio) + to[m] * ratio,
            y = _y * (1 - ratio) + to[m + 1] * ratio;
          tmpArr[m] = x * ca - y * sa + newCp[0], tmpArr[m + 1] = x * sa + y * ca + newCp[1];
        }
        var x0 = tmpArr[0],
          y0 = tmpArr[1];
        path.moveTo(x0, y0);
        for (var _m = 2; _m < from.length; _m += 6) {
          var x1 = tmpArr[_m],
            y1 = tmpArr[_m + 1],
            x2 = tmpArr[_m + 2],
            y2 = tmpArr[_m + 3],
            x3 = tmpArr[_m + 4],
            y3 = tmpArr[_m + 5];
          x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3 ? path.lineTo(x3, y3) : path.bezierCurveTo(x1, y1, x2, y2, x3, y3), x0 = x3, y0 = y3;
        }
      }
    },
    parseMorphingData = function parseMorphingData(fromPath, toPath, config) {
      var fromBezier = fromPath ? pathToBezierCurves(fromPath) : [],
        toBezier = pathToBezierCurves(toPath);
      config && fromBezier && (config.fromTransform && applyTransformOnBezierCurves(fromBezier, config.fromTransform.clone().getInverse()), applyTransformOnBezierCurves(fromBezier, config.toTransfrom));
      var _alignBezierCurves = alignBezierCurves(fromBezier, toBezier),
        _alignBezierCurves2 = _slicedToArray(_alignBezierCurves, 2),
        fromBezierCurves = _alignBezierCurves2[0],
        toBezierCurves = _alignBezierCurves2[1];
      return fromPath ? findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI) : toBezierCurves.map(function (to, index) {
        return {
          from: fromBezierCurves[index],
          to: to,
          fromCp: [0, 0],
          toCp: [0, 0],
          rotation: 0
        };
      });
    },
    validateOtherAttrs = ["fill", "fillOpacity", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "lineDashOffset"],
    parseOtherAnimateAttrs = function parseOtherAnimateAttrs(fromAttrs, toAttrs) {
      if (!fromAttrs || !toAttrs) return null;
      var res = [];
      var hasAttr = !1;
      return Object.keys(fromAttrs).forEach(function (fromKey) {
        if (!validateOtherAttrs.includes(fromKey)) return;
        var toValue = toAttrs[fromKey];
        isNil$1(toValue) || isNil$1(fromAttrs[fromKey]) || toValue === fromAttrs[fromKey] || ("fill" === fromKey || "stroke" === fromKey ? res.push({
          from: "string" == typeof fromAttrs[fromKey] ? ColorStore.Get(fromAttrs[fromKey], exports.ColorType.Color255) : fromAttrs[fromKey],
          to: "string" == typeof toValue ? ColorStore.Get(toValue, exports.ColorType.Color255) : toValue,
          key: fromKey
        }) : res.push({
          from: fromAttrs[fromKey],
          to: toValue,
          key: fromKey
        }), hasAttr = !0);
      }), hasAttr ? res : null;
    };
  var MorphingPath = /*#__PURE__*/function (_ACustomAnimate) {
    _inherits(MorphingPath, _ACustomAnimate);
    var _super = _createSuper(MorphingPath);
    function MorphingPath(config, duration, easing) {
      var _this;
      _classCallCheck(this, MorphingPath);
      _this = _super.call(this, 0, 1, duration, easing), _this.morphingData = config.morphingData, _this.otherAttrs = config.otherAttrs, _this.saveOnEnd = config.saveOnEnd;
      return _this;
    }
    _createClass(MorphingPath, [{
      key: "getEndProps",
      value: function getEndProps() {
        return {};
      }
    }, {
      key: "onBind",
      value: function onBind() {
        this.target.createPathProxy(), this.onUpdate(!1, 0, this.target.attribute);
      }
    }, {
      key: "onEnd",
      value: function onEnd() {}
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        var target = this.target,
          pathProxy = "function" == typeof target.pathProxy ? target.pathProxy(target.attribute) : target.pathProxy;
        interpolateMorphingData(this.morphingData, pathProxy, ratio), this.otherAttrs && this.otherAttrs.length && interpolateOtherAttrs(this.otherAttrs, out, ratio), end && !this.saveOnEnd && (this.target.pathProxy = null);
      }
    }]);
    return MorphingPath;
  }(ACustomAnimate);
  var morphPath = function morphPath(fromGraphic, toGraphic, animationConfig, fromGraphicTransform) {
    var _a, _b, _c;
    if (fromGraphic && (!fromGraphic.valid || !fromGraphic.toCustomPath)) return __DEV__ && console.error(fromGraphic, " is not validate"), null;
    if (!toGraphic.valid || !toGraphic.toCustomPath) return __DEV__ && console.error(toGraphic, " is not validate"), null;
    var fromTransform = null == fromGraphic ? void 0 : fromGraphic.globalTransMatrix;
    fromGraphicTransform && fromTransform && (fromTransform = fromGraphicTransform.clone().multiply(fromTransform.a, fromTransform.b, fromTransform.c, fromTransform.d, fromTransform.e, fromTransform.f));
    var morphingData = parseMorphingData(null === (_a = null == fromGraphic ? void 0 : fromGraphic.toCustomPath) || void 0 === _a ? void 0 : _a.call(fromGraphic), toGraphic.toCustomPath(), {
        fromTransform: fromTransform,
        toTransfrom: toGraphic.globalTransMatrix
      }),
      attrs = parseOtherAnimateAttrs(null == fromGraphic ? void 0 : fromGraphic.attribute, toGraphic.attribute),
      animate = toGraphic.animate(animationConfig);
    return (null == animationConfig ? void 0 : animationConfig.delay) && animate.wait(animationConfig.delay), animate.play(new MorphingPath({
      morphingData: morphingData,
      otherAttrs: attrs
    }, null !== (_b = null == animationConfig ? void 0 : animationConfig.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig ? void 0 : animationConfig.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing)), animate;
  };
  var oneToMultiMorph = function oneToMultiMorph(fromGraphic, toGraphics, animationConfig) {
    var _a;
    var validateToGraphics = toGraphics.filter(function (graphic) {
      return graphic && graphic.toCustomPath && graphic.valid;
    });
    validateToGraphics.length || __DEV__ && console.error(validateToGraphics, " is not validate"), fromGraphic.valid && fromGraphic.toCustomPath || __DEV__ && console.error(fromGraphic, " is not validate");
    var childGraphics = ("clone" === (null == animationConfig ? void 0 : animationConfig.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig ? void 0 : animationConfig.splitPath) && void 0 !== _a ? _a : splitGraphic)(fromGraphic, validateToGraphics.length, !1),
      oldOnEnd = null == animationConfig ? void 0 : animationConfig.onEnd;
    var count = validateToGraphics.length;
    var onEachEnd = function onEachEnd() {
      count--, 0 === count && oldOnEnd && oldOnEnd();
    };
    validateToGraphics.forEach(function (toChild, index) {
      var _a;
      var fromChild = childGraphics[index],
        delay = (null !== (_a = null == animationConfig ? void 0 : animationConfig.delay) && void 0 !== _a ? _a : 0) + ((null == animationConfig ? void 0 : animationConfig.individualDelay) ? animationConfig.individualDelay(index, validateToGraphics.length, fromChild, toChild) : 0);
      morphPath(fromChild, toChild, Object.assign({}, animationConfig, {
        onEnd: onEachEnd,
        delay: delay
      }), fromGraphic.globalTransMatrix);
    });
  };
  var MultiToOneMorphingPath = /*#__PURE__*/function (_ACustomAnimate2) {
    _inherits(MultiToOneMorphingPath, _ACustomAnimate2);
    var _super2 = _createSuper(MultiToOneMorphingPath);
    function MultiToOneMorphingPath(config, duration, easing) {
      var _this2;
      _classCallCheck(this, MultiToOneMorphingPath);
      _this2 = _super2.call(this, 0, 1, duration, easing), _this2.morphingData = config.morphingData, _this2.otherAttrs = config.otherAttrs;
      return _this2;
    }
    _createClass(MultiToOneMorphingPath, [{
      key: "getEndProps",
      value: function getEndProps() {
        return {};
      }
    }, {
      key: "onBind",
      value: function onBind() {
        this.addPathProxy();
      }
    }, {
      key: "addPathProxy",
      value: function addPathProxy() {
        this.target.shadowRoot.forEachChildren(function (child) {
          child.createPathProxy();
        }), this.onUpdate(!1, 0, this.target.attribute);
      }
    }, {
      key: "clearPathProxy",
      value: function clearPathProxy() {
        this.target.shadowRoot.forEachChildren(function (child) {
          child.pathProxy = null;
        });
      }
    }, {
      key: "onEnd",
      value: function onEnd() {}
    }, {
      key: "onUpdate",
      value: function onUpdate(end, ratio, out) {
        var _this3 = this;
        this.target.shadowRoot.forEachChildren(function (child, index) {
          var _a;
          interpolateMorphingData(_this3.morphingData[index], "function" == typeof child.pathProxy ? child.pathProxy(child.attribute) : child.pathProxy, ratio), (null === (_a = _this3.otherAttrs) || void 0 === _a ? void 0 : _a[index]) && _this3.otherAttrs[index].length && interpolateOtherAttrs(_this3.otherAttrs[index], child.attribute, ratio);
        }), end && (this.clearPathProxy(), this.morphingData = null);
      }
    }]);
    return MultiToOneMorphingPath;
  }(ACustomAnimate);
  var parseShadowChildAttrs = function parseShadowChildAttrs(graphicAttrs) {
      var attrs = {};
      return Object.keys(graphicAttrs).forEach(function (key) {
        isTransformKey(key) || (attrs[key] = graphicAttrs[key]);
      }), attrs;
    },
    appendShadowChildrenToGraphic = function appendShadowChildrenToGraphic(graphic, children, count) {
      var childAttrs = parseShadowChildAttrs(graphic.attribute),
        shadowRoot = graphic.attachShadow();
      if (children.length) shadowRoot.setTheme(_defineProperty({}, children[0].type, childAttrs)), children.forEach(function (element) {
        shadowRoot.appendChild(element);
      });else {
        var box = graphic.AABBBounds,
          width = box.width(),
          height = box.height();
        shadowRoot.setTheme({
          rect: childAttrs
        }), new Array(count).fill(0).forEach(function (el) {
          var child = application.graphicService.creator.rect({
            x: 0,
            y: 0,
            width: width,
            height: height
          });
          shadowRoot.appendChild(child), children.push(child);
        });
      }
    };
  var cloneGraphic = function cloneGraphic(graphic, count, needAppend) {
    var children = [],
      childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute),
      path = graphic.toCustomPath();
    for (var i = 0; i < count; i++) {
      var element = {
        path: new CustomPath2D().fromCustomPath2D(path)
      };
      children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
    }
    return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
  };
  var splitGraphic = function splitGraphic(graphic, count, needAppend) {
    var children = [],
      childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
    if ("rect" === graphic.type) {
      splitRect(graphic, count).forEach(function (element) {
        children.push(application.graphicService.creator.rect(needAppend ? element : Object.assign({}, childAttrs, element)));
      });
    } else if ("arc" === graphic.type) {
      splitArc(graphic, count).forEach(function (element) {
        children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
      });
    } else if ("circle" === graphic.type) {
      splitCircle(graphic, count).forEach(function (element) {
        children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
      });
    } else if ("line" === graphic.type) {
      var childrenAttrs = splitLine(graphic, count),
        defaultSymbol = {
          size: 10,
          symbolType: "circle"
        };
      childrenAttrs.forEach(function (element) {
        children.push(application.graphicService.creator.symbol(needAppend ? Object.assign({}, element, defaultSymbol) : Object.assign({}, childAttrs, element, defaultSymbol)));
      });
    } else if ("polygon" === graphic.type) {
      splitPolygon(graphic, count).forEach(function (element) {
        children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
      });
    } else if ("area" === graphic.type) {
      splitArea(graphic, count).forEach(function (element) {
        children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
      });
    } else if ("path" === graphic.type) {
      splitPath(graphic, count).forEach(function (element) {
        "path" in element ? children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element))) : children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
      });
    }
    return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
  };
  var multiToOneMorph = function multiToOneMorph(fromGraphics, toGraphic, animationConfig) {
    var _a, _b, _c;
    var validateFromGraphics = fromGraphics.filter(function (graphic) {
      return graphic.toCustomPath && graphic.valid;
    });
    validateFromGraphics.length || __DEV__ && console.error(fromGraphics, " is not validate"), toGraphic.valid && toGraphic.toCustomPath || __DEV__ && console.error(toGraphic, " is not validate");
    var childGraphics = ("clone" === (null == animationConfig ? void 0 : animationConfig.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig ? void 0 : animationConfig.splitPath) && void 0 !== _a ? _a : splitGraphic)(toGraphic, validateFromGraphics.length, !0),
      toAttrs = toGraphic.attribute;
    toGraphic.setAttribute("visible", !1);
    var morphingData = validateFromGraphics.map(function (graphic, index) {
        return parseMorphingData(graphic.toCustomPath(), childGraphics[index].toCustomPath(), {
          fromTransform: graphic.globalTransMatrix,
          toTransfrom: childGraphics[index].globalTransMatrix
        });
      }),
      otherAttrs = validateFromGraphics.map(function (graphic, index) {
        return parseOtherAnimateAttrs(graphic.attribute, toAttrs);
      });
    if (null == animationConfig ? void 0 : animationConfig.individualDelay) {
      var oldOnEnd = animationConfig.onEnd;
      var count = validateFromGraphics.length;
      var onEachEnd = function onEachEnd() {
        count--, 0 === count && (toGraphic.setAttributes({
          visible: !0,
          ratio: null
        }, !1, {
          type: exports.AttributeUpdateType.ANIMATE_END
        }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd());
      };
      childGraphics.forEach(function (to, index) {
        var _a, _b, _c;
        var delay = (null !== (_a = animationConfig.delay) && void 0 !== _a ? _a : 0) + animationConfig.individualDelay(index, validateFromGraphics.length, fromGraphics[index], to),
          animate = to.animate(Object.assign({}, animationConfig, {
            onEnd: onEachEnd
          }));
        animate.wait(delay), animate.play(new MorphingPath({
          morphingData: morphingData[index],
          saveOnEnd: !0,
          otherAttrs: otherAttrs[index]
        }, null !== (_b = animationConfig.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = animationConfig.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing));
      });
    } else {
      var _oldOnEnd = null == animationConfig ? void 0 : animationConfig.onEnd,
        config = animationConfig ? Object.assign({}, animationConfig) : {};
      config.onEnd = function () {
        toGraphic.setAttribute("visible", !0, !1, {
          type: exports.AttributeUpdateType.ANIMATE_END
        }), toGraphic.detachShadow(), _oldOnEnd && _oldOnEnd();
      };
      var animate = toGraphic.animate(config);
      (null == animationConfig ? void 0 : animationConfig.delay) && animate.wait(animationConfig.delay), animate.play(new MultiToOneMorphingPath({
        morphingData: morphingData,
        otherAttrs: otherAttrs
      }, null !== (_b = null == animationConfig ? void 0 : animationConfig.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig ? void 0 : animationConfig.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing));
    }
  };

  var ResourceLoader = /*#__PURE__*/function () {
    function ResourceLoader() {
      _classCallCheck(this, ResourceLoader);
    }
    _createClass(ResourceLoader, null, [{
      key: "GetImage",
      value: function GetImage(url, mark) {
        var _a;
        var data = ResourceLoader.cache.get(url);
        data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(function () {
          mark.imageLoadFail(url);
        }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(url, data.data) : ResourceLoader.loadImage(url, mark);
      }
    }, {
      key: "GetSvg",
      value: function GetSvg(svgStr, mark) {
        var _a;
        var data = ResourceLoader.cache.get(svgStr);
        data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(function () {
          mark.imageLoadFail(svgStr);
        }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(svgStr, data.data) : (data = {
          type: "image",
          loadState: "init"
        }, ResourceLoader.cache.set(svgStr, data), data.dataPromise = application.global.loadSvg(svgStr), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then(function (res) {
          var _a;
          data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map(function (mark, index) {
            (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark.imageLoadFail(svgStr));
          });
        })) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
      }
    }, {
      key: "GetFile",
      value: function GetFile(url, type) {
        var data = ResourceLoader.cache.get(url);
        return data ? "init" === data.loadState || "fail" === data.loadState ? Promise.reject() : "loading" === data.loadState ? data.dataPromise.then(function (data) {
          return data.data;
        }) : Promise.resolve(data.data) : (data = {
          type: type,
          loadState: "init"
        }, ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application.global.loadBlob(url) : "json" === type && (data.dataPromise = application.global.loadJson(url)), data.dataPromise.then(function (data) {
          return data.data;
        }));
      }
    }, {
      key: "loading",
      value: function loading() {
        var _this = this;
        setTimeout(function () {
          if (!ResourceLoader.isLoading && ResourceLoader.toLoadAueue.length) {
            ResourceLoader.isLoading = !0;
            var tasks = ResourceLoader.toLoadAueue.splice(0, 10),
              promises = [];
            tasks.forEach(function (task) {
              var url = task.url,
                marks = task.marks,
                data = {
                  type: "image",
                  loadState: "init"
                };
              if (ResourceLoader.cache.set(url, data), data.dataPromise = application.global.loadImage(url), data.dataPromise) {
                data.waitingMark = marks;
                var end = data.dataPromise.then(function (res) {
                  var _a;
                  data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map(function (mark, index) {
                    (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark.imageLoadFail(url));
                  });
                });
                promises.push(end);
              } else data.loadState = "fail", marks.forEach(function (mark) {
                return mark.imageLoadFail(url);
              });
            }), Promise.all(promises).then(function () {
              ResourceLoader.isLoading = !1, _this.onLoadSuccessCb.forEach(function (cb) {
                return cb();
              }), ResourceLoader.loading();
            })["catch"](function (error) {
              console.error(error), ResourceLoader.isLoading = !1, _this.onLoadSuccessCb.forEach(function (cb) {
                return cb();
              }), ResourceLoader.loading();
            });
          }
        }, 0);
      }
    }, {
      key: "loadImage",
      value: function loadImage(url, mark) {
        var index = getIndex(url, ResourceLoader.toLoadAueue);
        if (-1 !== index) return ResourceLoader.toLoadAueue[index].marks.push(mark), void ResourceLoader.loading();
        ResourceLoader.toLoadAueue.push({
          url: url,
          marks: [mark]
        }), ResourceLoader.loading();
      }
    }, {
      key: "improveImageLoading",
      value: function improveImageLoading(url) {
        var index = getIndex(url, ResourceLoader.toLoadAueue);
        if (-1 !== index) {
          var elememt = ResourceLoader.toLoadAueue.splice(index, 1);
          ResourceLoader.toLoadAueue.unshift(elememt[0]);
        }
      }
    }, {
      key: "onLoadSuccess",
      value: function onLoadSuccess(cb) {
        this.onLoadSuccessCb.push(cb);
      }
    }]);
    return ResourceLoader;
  }();
  function getIndex(url, arr) {
    for (var i = 0; i < arr.length; i++) if (arr[i].url === url) return i;
    return -1;
  }
  ResourceLoader.cache = new Map(), ResourceLoader.isLoading = !1, ResourceLoader.toLoadAueue = [], ResourceLoader.onLoadSuccessCb = [];

  var tempMatrix = new Matrix(),
    tempBounds$1 = new AABBBounds();
  var PURE_STYLE_KEY = ["stroke", "opacity", "strokeOpacity", "lineDash", "lineDashOffset", "lineCap", "lineJoin", "miterLimit", "fill", "fillOpacity"];
  var GRAPHIC_UPDATE_TAG_KEY = ["lineWidth", "scaleX", "scaleY", "angle", "anchor", "visible"];
  var tempConstantXYKey = ["x", "y"],
    tempConstantScaleXYKey = ["scaleX", "scaleY"],
    tempConstantAngleKey = ["angle"],
    point = new Point();
  var NOWORK_ANIMATE_ATTR = {
    strokeSeg: 1,
    boundsPadding: 2,
    pickMode: 1,
    boundsMode: 1,
    customPickShape: 1,
    pickable: 1,
    childrenPickable: 1,
    visible: 1,
    zIndex: 1,
    layout: 1,
    keepDirIn3d: 1,
    globalZIndex: 1,
    outerBorder: 1,
    innerBorder: 1,
    lineDash: 1,
    lineCap: 1,
    lineJoin: 1,
    miterLimit: 2,
    strokeBoundsBuffer: 2,
    scaleCenter: 1,
    anchor: 1,
    anchor3d: 1,
    postMatrix: 1,
    backgroundMode: 2,
    background: 1,
    texture: 1,
    cursor: 1,
    html: 1
  };
  var Graphic = /*#__PURE__*/function (_Node) {
    _inherits(Graphic, _Node);
    var _super = _createSuper(Graphic);
    function Graphic() {
      var _this;
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Graphic);
      var _a;
      _this = _super.call(this), _this._AABBBounds = new AABBBounds(), _this._updateTag = exports.UpdateTag.INIT, _this.attribute = params, _this.valid = _this.isValid(), params.background && _this.loadImage(null !== (_a = params.background.background) && void 0 !== _a ? _a : params.background, !0);
      return _this;
    }
    _createClass(Graphic, [{
      key: "AABBBounds",
      get: function get() {
        return this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode);
      }
    }, {
      key: "OBBBounds",
      get: function get() {
        return this.tryUpdateOBBBounds();
      }
    }, {
      key: "globalAABBBounds",
      get: function get() {
        return this.tryUpdateGlobalAABBBounds();
      }
    }, {
      key: "transMatrix",
      get: function get() {
        return this.tryUpdateLocalTransMatrix(!0);
      }
    }, {
      key: "globalTransMatrix",
      get: function get() {
        return this.tryUpdateGlobalTransMatrix(!0);
      }
    }, {
      key: "setMode",
      value: function setMode(mode) {
        "3d" === mode ? this.set3dMode() : this.set2dMode();
      }
    }, {
      key: "set3dMode",
      value: function set3dMode() {
        this.in3dMode = !0;
      }
    }, {
      key: "set2dMode",
      value: function set2dMode() {
        this.in3dMode = !1;
      }
    }, {
      key: "getOffsetXY",
      value: function getOffsetXY(attr) {
        var includeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        var _a, _b;
        var _this$attribute = this.attribute,
          _this$attribute$dx = _this$attribute.dx,
          dx = _this$attribute$dx === void 0 ? attr.dx : _this$attribute$dx,
          _this$attribute$dy = _this$attribute.dy,
          dy = _this$attribute$dy === void 0 ? attr.dy : _this$attribute$dy;
        if (includeScroll && this.parent) {
          var attribute = this.parent.attribute;
          point.x = dx + (null !== (_a = attribute.scrollX) && void 0 !== _a ? _a : 0), point.y = dy + (null !== (_b = attribute.scrollY) && void 0 !== _b ? _b : 0);
        } else point.x = dx, point.y = dy;
        return point;
      }
    }, {
      key: "onAnimateBind",
      value: function onAnimateBind(animate) {
        this._emitCustomEvent("animate-bind", animate);
      }
    }, {
      key: "tryUpdateAABBBounds",
      value: function tryUpdateAABBBounds(full) {
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
        application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
        var bounds = this.doUpdateAABBBounds(full);
        return application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, !0), bounds;
      }
    }, {
      key: "combindShadowAABBBounds",
      value: function combindShadowAABBBounds(bounds) {
        if (this.shadowRoot) {
          var b = this.shadowRoot.AABBBounds.clone();
          bounds.union(b);
        }
      }
    }, {
      key: "tryUpdateGlobalAABBBounds",
      value: function tryUpdateGlobalAABBBounds() {
        var b = this.AABBBounds;
        return this._globalAABBBounds ? this._globalAABBBounds.setValue(b.x1, b.y1, b.x2, b.y2) : this._globalAABBBounds = b.clone(), this._globalAABBBounds.empty() || this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), this._globalAABBBounds;
      }
    }, {
      key: "tryUpdateGlobalTransMatrix",
      value: function tryUpdateGlobalTransMatrix() {
        if (this._globalTransMatrix) {
          if (this.parent) {
            var m = this.parent.globalTransMatrix;
            this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
          }
        } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
        return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
      }
    }, {
      key: "shouldUpdateGlobalMatrix",
      value: function shouldUpdateGlobalMatrix() {
        return !0;
      }
    }, {
      key: "tryUpdateLocalTransMatrix",
      value: function tryUpdateLocalTransMatrix() {
        var clearTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        return this._transMatrix || (this._transMatrix = new Matrix()), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
      }
    }, {
      key: "shouldUpdateAABBBounds",
      value: function shouldUpdateAABBBounds() {
        return this.shadowRoot ? !!(this._updateTag & exports.UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & exports.UpdateTag.UPDATE_BOUNDS);
      }
    }, {
      key: "shouldSelfChangeUpdateAABBBounds",
      value: function shouldSelfChangeUpdateAABBBounds() {
        return this.shadowRoot ? !!(this._updateTag & exports.UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & exports.UpdateTag.UPDATE_BOUNDS);
      }
    }, {
      key: "shouldUpdateLocalMatrix",
      value: function shouldUpdateLocalMatrix() {
        return !!(this._updateTag & exports.UpdateTag.UPDATE_LOCAL_MATRIX);
      }
    }, {
      key: "isValid",
      value: function isValid() {
        var _a, _b;
        var attribute = this.attribute;
        return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
      }
    }, {
      key: "_validNumber",
      value: function _validNumber(num) {
        return null == num || Number.isFinite(num);
      }
    }, {
      key: "shouldUpdateShape",
      value: function shouldUpdateShape() {
        return !!(this._updateTag & exports.UpdateTag.UPDATE_SHAPE);
      }
    }, {
      key: "clearUpdateShapeTag",
      value: function clearUpdateShapeTag() {
        this._updateTag &= exports.UpdateTag.CLEAR_SHAPE;
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(x, y, mode, picker) {
        if (!picker) return !1;
        if (mode === exports.IContainPointMode.GLOBAL) {
          var _point = new Point(x, y);
          this.parent && this.parent.globalTransMatrix.transformPoint(_point, _point), x = _point.x, y = _point.y;
        }
        return picker.containsPoint(this, {
          x: x,
          y: y
        });
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(params) {
        var forceUpdateTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        var context = arguments.length > 2 ? arguments[2] : undefined;
        (params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params).background && this.loadImage(params.background, !0), this._setAttributes(params, forceUpdateTag, context);
      }
    }, {
      key: "_setAttributes",
      value: function _setAttributes(params) {
        var forceUpdateTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        var context = arguments.length > 2 ? arguments[2] : undefined;
        var keys = Object.keys(params);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          this.attribute[key] = params[key];
        }
        this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context);
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(key, value, forceUpdateTag, context) {
        var _a;
        var params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(_defineProperty({}, key, value), this.attribute, key, context);
        params ? this._setAttributes(params, forceUpdateTag, context) : isNil$1(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, "background" === key && this.loadImage(value, !0);
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GRAPHIC_UPDATE_TAG_KEY;
        for (var i = 0; i < k.length; i++) {
          var attrKey = k[i];
          if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return !1;
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GRAPHIC_UPDATE_TAG_KEY;
        for (var i = 0; i < k.length; i++) {
          if (key === k[i]) return !0;
        }
        return !1;
      }
    }, {
      key: "initAttributes",
      value: function initAttributes(params) {
        var context = {
          type: exports.AttributeUpdateType.INIT
        };
        params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params, this.attribute = params, params.background && this.loadImage(params.background, !0), this._updateTag = exports.UpdateTag.INIT, this.valid = this.isValid(), this.onAttributeUpdate(context);
      }
    }, {
      key: "translate",
      value: function translate(x, y) {
        var _a, _b;
        if (0 === x && 0 === y) return this;
        var context = {
            type: exports.AttributeUpdateType.TRANSLATE
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            x: x,
            y: y
          }, this.attribute, tempConstantXYKey, context);
        params && (x = params.x, y = params.y, delete params.x, delete params.y, this._setAttributes(params));
        var attribute = this.attribute,
          postMatrix = attribute.postMatrix;
        return postMatrix ? application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : DefaultTransform.x) + x, attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : DefaultTransform.y) + y), this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
      }
    }, {
      key: "translateTo",
      value: function translateTo(x, y) {
        var attribute = this.attribute;
        if (attribute.x === x && attribute.y === y) return this;
        var context = {
            type: exports.AttributeUpdateType.TRANSLATE_TO
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            x: x,
            y: y
          }, this.attribute, tempConstantXYKey, context);
        return params ? (this._setAttributes(params, !1, context), this) : (attribute.x = x, attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
      }
    }, {
      key: "scale",
      value: function scale(scaleX, scaleY, scaleCenter) {
        var _a, _b;
        if (1 === scaleX && 1 === scaleY) return this;
        var context = {
            type: exports.AttributeUpdateType.SCALE
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            scaleX: scaleX,
            scaleY: scaleY,
            scaleCenter: scaleCenter
          }, this.attribute, tempConstantScaleXYKey, context);
        params && (scaleX = params.scaleX, scaleY = params.scaleY, delete params.scaleX, delete params.scaleY, this._setAttributes(params));
        var attribute = this.attribute;
        if (scaleCenter) {
          var postMatrix = this.attribute.postMatrix;
          postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
        } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : DefaultTransform.scaleX) * scaleX, attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : DefaultTransform.scaleY) * scaleY;
        return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
      }
    }, {
      key: "scaleTo",
      value: function scaleTo(scaleX, scaleY) {
        var attribute = this.attribute;
        if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;
        var context = {
            type: exports.AttributeUpdateType.SCALE_TO
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            scaleX: scaleX,
            scaleY: scaleY
          }, this.attribute, tempConstantScaleXYKey, context);
        return params ? (this._setAttributes(params, !1, context), this) : (attribute.scaleX = scaleX, attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
      }
    }, {
      key: "rotate",
      value: function rotate(angle, rotateCenter) {
        var _a;
        if (0 === angle) return this;
        var context = {
            type: exports.AttributeUpdateType.ROTATE
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
            angle: angle,
            rotateCenter: rotateCenter
          }, this.attribute, tempConstantAngleKey, context);
        params && (delete params.angle, this._setAttributes(params, !1, context));
        var attribute = this.attribute;
        if (rotateCenter) {
          var postMatrix = this.attribute.postMatrix;
          postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle, rotateCenter);
        } else attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : DefaultTransform.angle) + angle;
        return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
      }
    }, {
      key: "rotateTo",
      value: function rotateTo(angle) {
        var attribute = this.attribute;
        if (attribute.angle === angle) return this;
        var context = {
            type: exports.AttributeUpdateType.ROTATE_TO
          },
          params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
        return params ? (this._setAttributes(params, !1, context), this) : (attribute.angle = angle, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
      }
    }, {
      key: "skewTo",
      value: function skewTo(b, c) {
        return this;
      }
    }, {
      key: "animate",
      value: function animate(params) {
        var _this2 = this;
        this.animates || (this.animates = new Map());
        var animate = new Animate(null == params ? void 0 : params.id, this.stage && this.stage.getTimeline()).bind(this);
        if (params) {
          var onStart = params.onStart,
            onFrame = params.onFrame,
            onEnd = params.onEnd,
            onRemove = params.onRemove;
          null != onStart && animate.onStart(onStart), null != onFrame && animate.onFrame(onFrame), null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove), animate.interpolateFunc = params.interpolate;
        }
        return this.animates.set(animate.id, animate), animate.onRemove(function () {
          _this2.animates["delete"](animate.id);
        }), animate;
      }
    }, {
      key: "onAttributeUpdate",
      value: function onAttributeUpdate(context) {
        context && context.skipUpdateCallback || (application.graphicService.onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context));
      }
    }, {
      key: "update",
      value: function update(d) {
        d ? (d.bounds && this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode), d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode), this.tryUpdateLocalTransMatrix());
      }
    }, {
      key: "hasState",
      value: function hasState(stateName) {
        return !(!this.currentStates || !this.currentStates.length) && (!!isNil$1(stateName) || this.currentStates.includes(stateName));
      }
    }, {
      key: "getState",
      value: function getState(stateName) {
        var _a;
        return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
      }
    }, {
      key: "applyStateAttrs",
      value: function applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
        var _this3 = this;
        var _a, _b, _c, _d;
        if (hasAnimation) {
          var keys = Object.keys(attrs),
            noWorkAAttr = this.getNoWorkAnimateAttr(),
            animateAttrs = {};
          var noAnimateAttrs;
          isClear ? keys.forEach(function (key) {
            noWorkAAttr[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = void 0 === attrs[key] ? _this3.getDefaultAttribute(key) : attrs[key];
          }) : keys.forEach(function (key) {
            noWorkAAttr[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = attrs[key];
          });
          var animate = this.animate();
          animate.stateNames = stateNames, animate.to(animateAttrs, null !== (_b = null === (_a = this.stateAnimateConfig) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : DefaultStateAnimateConfig.duration, null !== (_d = null === (_c = this.stateAnimateConfig) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : DefaultStateAnimateConfig.easing), noAnimateAttrs && this.setAttributes(noAnimateAttrs, !1, {
            type: exports.AttributeUpdateType.STATE
          });
        } else this.setAttributes(attrs, !1, {
          type: exports.AttributeUpdateType.STATE
        });
      }
    }, {
      key: "updateNormalAttrs",
      value: function updateNormalAttrs(stateAttrs) {
        var _this4 = this;
        var newNormalAttrs = {};
        this.normalAttrs ? (Object.keys(stateAttrs).forEach(function (key) {
          key in _this4.normalAttrs ? (newNormalAttrs[key] = _this4.normalAttrs[key], delete _this4.normalAttrs[key]) : newNormalAttrs[key] = _this4.getNormalAttribute(key);
        }), Object.keys(this.normalAttrs).forEach(function (key) {
          stateAttrs[key] = _this4.normalAttrs[key];
        })) : Object.keys(stateAttrs).forEach(function (key) {
          newNormalAttrs[key] = _this4.getNormalAttribute(key);
        }), this.normalAttrs = newNormalAttrs;
      }
    }, {
      key: "getNormalAttribute",
      value: function getNormalAttribute(key) {
        var value = this.attribute[key];
        return this.animates && this.animates.forEach(function (animate) {
          if (animate.stateNames) {
            var endProps = animate.getEndProps();
            has$1(endProps, key) && (value = endProps[key]);
          }
        }), value;
      }
    }, {
      key: "clearStates",
      value: function clearStates(hasAnimation) {
        this.hasState() && this.normalAttrs ? (this.currentStates = [], this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0)) : this.currentStates = [], this.normalAttrs = null;
      }
    }, {
      key: "removeState",
      value: function removeState(stateName, hasAnimation) {
        if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) >= 0) {
          var currentStates = this.currentStates.filter(function (state) {
            return state !== stateName;
          });
          this.useStates(currentStates, hasAnimation);
        }
      }
    }, {
      key: "toggleState",
      value: function toggleState(stateName, hasAnimation) {
        if (this.hasState(stateName)) this.removeState(stateName, hasAnimation);else {
          if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
            var nextStates = this.currentStates ? this.currentStates.slice() : [];
            nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
          }
        }
      }
    }, {
      key: "addState",
      value: function addState(stateName, keepCurrentStates, hasAnimation) {
        var _a;
        if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;
        var newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
        this.useStates(newStates, hasAnimation);
      }
    }, {
      key: "useStates",
      value: function useStates(states, hasAnimation) {
        var _this5 = this;
        var _a;
        if (!states.length) return void this.clearStates(hasAnimation);
        if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some(function (stateName, index) {
          return _this5.currentStates[index] !== stateName;
        }))) return;
        var stateAttrs = {};
        states.forEach(function (stateName) {
          var _a;
          var attrs = _this5.stateProxy ? _this5.stateProxy(stateName, states) : null === (_a = _this5.states) || void 0 === _a ? void 0 : _a[stateName];
          attrs && Object.assign(stateAttrs, attrs);
        }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
      }
    }, {
      key: "addUpdateBoundTag",
      value: function addUpdateBoundTag() {
        this._updateTag |= exports.UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
      }
    }, {
      key: "addUpdateShapeTag",
      value: function addUpdateShapeTag() {
        this._updateTag |= exports.UpdateTag.UPDATE_SHAPE;
      }
    }, {
      key: "addUpdateShapeAndBoundsTag",
      value: function addUpdateShapeAndBoundsTag() {
        this._updateTag |= exports.UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
      }
    }, {
      key: "updateShapeAndBoundsTagSetted",
      value: function updateShapeAndBoundsTagSetted() {
        return (this._updateTag & exports.UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === exports.UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
      }
    }, {
      key: "clearUpdateBoundTag",
      value: function clearUpdateBoundTag() {
        this._updateTag &= exports.UpdateTag.CLEAR_BOUNDS;
      }
    }, {
      key: "addUpdatePositionTag",
      value: function addUpdatePositionTag() {
        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= exports.UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
      }
    }, {
      key: "addUpdateGlobalPositionTag",
      value: function addUpdateGlobalPositionTag() {
        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= exports.UpdateTag.UPDATE_GLOBAL_MATRIX;
      }
    }, {
      key: "clearUpdateLocalPositionTag",
      value: function clearUpdateLocalPositionTag() {
        this._updateTag &= exports.UpdateTag.CLEAR_LOCAL_MATRIX;
      }
    }, {
      key: "clearUpdateGlobalPositionTag",
      value: function clearUpdateGlobalPositionTag() {
        this._updateTag &= exports.UpdateTag.CLEAR_GLOBAL_MATRIX;
      }
    }, {
      key: "addUpdateLayoutTag",
      value: function addUpdateLayoutTag() {
        this._updateTag |= exports.UpdateTag.UPDATE_LAYOUT;
      }
    }, {
      key: "clearUpdateLayoutTag",
      value: function clearUpdateLayoutTag() {
        this._updateTag &= exports.UpdateTag.CLEAR_LAYOUT;
      }
    }, {
      key: "needUpdateLayout",
      value: function needUpdateLayout() {
        return !!(this._updateTag & exports.UpdateTag.UPDATE_LAYOUT);
      }
    }, {
      key: "getAnchor",
      value: function getAnchor(anchor, params) {
        var _this6 = this;
        var _anchor = [0, 0],
          getBounds = function getBounds() {
            if (params.b) return params.b;
            var _this6$attribute = _this6.attribute,
              scaleX = _this6$attribute.scaleX,
              scaleY = _this6$attribute.scaleY,
              angle = _this6$attribute.angle;
            return tempBounds$1.copy(_this6._AABBBounds), _this6.setAttributes({
              scaleX: 1,
              scaleY: 1,
              angle: 0
            }), params.b = _this6.AABBBounds.clone(), _this6._AABBBounds.copy(tempBounds$1), _this6.setAttributes({
              scaleX: scaleX,
              scaleY: scaleY,
              angle: angle
            }), params.b;
          };
        if ("string" == typeof anchor[0]) {
          var ratio = parseFloat(anchor[0]) / 100,
            bounds = getBounds();
          _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        } else _anchor[0] = anchor[0];
        if ("string" == typeof anchor[1]) {
          var _ratio = parseFloat(anchor[1]) / 100,
            _bounds = getBounds();
          _anchor[1] = _bounds.y1 + (_bounds.y2 - _bounds.y1) * _ratio;
        } else _anchor[1] = anchor[1];
        return _anchor;
      }
    }, {
      key: "doUpdateLocalMatrix",
      value: function doUpdateLocalMatrix() {
        var _this$attribute2 = this.attribute,
          _this$attribute2$x = _this$attribute2.x,
          x = _this$attribute2$x === void 0 ? DefaultTransform.x : _this$attribute2$x,
          _this$attribute2$y = _this$attribute2.y,
          y = _this$attribute2$y === void 0 ? DefaultTransform.y : _this$attribute2$y,
          _this$attribute2$scal = _this$attribute2.scaleX,
          scaleX = _this$attribute2$scal === void 0 ? DefaultTransform.scaleX : _this$attribute2$scal,
          _this$attribute2$scal2 = _this$attribute2.scaleY,
          scaleY = _this$attribute2$scal2 === void 0 ? DefaultTransform.scaleY : _this$attribute2$scal2,
          _this$attribute2$angl = _this$attribute2.angle,
          angle = _this$attribute2$angl === void 0 ? DefaultTransform.angle : _this$attribute2$angl,
          scaleCenter = _this$attribute2.scaleCenter,
          anchor = _this$attribute2.anchor,
          postMatrix = _this$attribute2.postMatrix;
        var _anchor = [0, 0];
        var params = {};
        if (anchor && (_anchor = this.getAnchor(anchor, params)), !scaleCenter || 1 === scaleX && 1 === scaleY) normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle, anchor && _anchor);else {
          var m = this._transMatrix;
          m.reset(), m.translate(_anchor[0], _anchor[1]), m.rotate(angle), m.translate(-_anchor[0], -_anchor[1]), m.translate(x, y), _anchor = this.getAnchor(scaleCenter, params), application.transformUtil.fromMatrix(m, m).scale(scaleX, scaleY, {
            x: _anchor[0],
            y: _anchor[1]
          });
        }
        var p = this.getOffsetXY(DefaultTransform);
        if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {
          var m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f),
            m2 = this._transMatrix;
          m1.multiply(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f), m2.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
        }
      }
    }, {
      key: "doUpdateGlobalMatrix",
      value: function doUpdateGlobalMatrix() {
        if (this.parent) {
          this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
          var _this$parent$attribut = this.parent.attribute,
            _this$parent$attribut2 = _this$parent$attribut.scrollX,
            scrollX = _this$parent$attribut2 === void 0 ? 0 : _this$parent$attribut2,
            _this$parent$attribut3 = _this$parent$attribut.scrollY,
            scrollY = _this$parent$attribut3 === void 0 ? 0 : _this$parent$attribut3;
          this._globalTransMatrix.translate(scrollX, scrollY);
        }
      }
    }, {
      key: "setStage",
      value: function setStage(stage, layer) {
        if (this.stage !== stage) {
          if (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this.animates && this.animates.size) {
            var timeline = stage.getTimeline();
            this.animates.forEach(function (a) {
              a.setTimeline(timeline);
            });
          }
          this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage);
        }
      }
    }, {
      key: "setStageToShadowRoot",
      value: function setStageToShadowRoot(stage, layer) {
        this.shadowRoot && this.shadowRoot.setStage(stage, layer);
      }
    }, {
      key: "onAddStep",
      value: function onAddStep(step) {}
    }, {
      key: "onStop",
      value: function onStop(props) {
        props && this.setAttributes(props, !1, {
          type: exports.AttributeUpdateType.ANIMATE_END
        });
      }
    }, {
      key: "onStep",
      value: function onStep(subAnimate, animate, step, ratio, end) {
        var nextAttributes = {};
        if (step.customAnimate) step.customAnimate.update(end, ratio, nextAttributes);else {
          var nextProps = step.props,
            nextParsedProps = step.parsedProps,
            propKeys = step.propKeys;
          this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, void 0, nextParsedProps, propKeys);
        }
        this.setAttributes(nextAttributes, !1, {
          type: exports.AttributeUpdateType.ANIMATE_UPDATE,
          animationState: {
            ratio: ratio,
            end: end,
            step: step,
            isFirstFrameOfStep: subAnimate.getLastStep() !== step
          }
        }), this.stage && this.stage.renderNextFrame();
      }
    }, {
      key: "stepInterpolate",
      value: function stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {
        var _this7 = this;
        propKeys || (propKeys = Object.keys(nextProps), step.propKeys = propKeys), end ? step.propKeys.forEach(function (key) {
          animate.validAttr(key) && (nextAttributes[key] = nextProps[key]);
        }) : propKeys.forEach(function (key) {
          var _a;
          if (!animate.validAttr(key)) return;
          var nextStepVal = nextProps[key],
            lastStepVal = null !== (_a = lastProps && lastProps[key]) && void 0 !== _a ? _a : subAnimate.getLastPropByName(key, step);
          if (null == nextStepVal || null == lastStepVal) return void (nextAttributes[key] = nextStepVal);
          var match;
          match = animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes), match || (match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, _this7, nextAttributes), match || _this7.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) || _this7._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes));
        }), step.parsedProps = nextParsedProps;
      }
    }, {
      key: "defaultInterpolate",
      value: function defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {
        if (Number.isFinite(nextStepVal)) return nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio, !0;
        if ("fill" === key) {
          nextParsedProps || (nextParsedProps = {});
          var fillColorArray = nextParsedProps.fillColorArray,
            color = interpolateColor(lastStepVal, null != fillColorArray ? fillColorArray : nextStepVal, ratio, !1, function (fArray, tArray) {
              nextParsedProps.fillColorArray = tArray;
            });
          return color && (nextAttributes[key] = color), !0;
        }
        if ("stroke" === key) {
          nextParsedProps || (nextParsedProps = {});
          var strokeColorArray = nextParsedProps.strokeColorArray,
            _color = interpolateColor(lastStepVal, null != strokeColorArray ? strokeColorArray : nextStepVal, ratio, !1, function (fArray, tArray) {
              nextParsedProps.strokeColorArray = tArray;
            });
          return _color && (nextAttributes[key] = _color), !0;
        }
        if ("shadowColor" === key) {
          nextParsedProps || (nextParsedProps = {});
          var shadowColorArray = nextParsedProps.shadowColorArray,
            _color2 = interpolateColor(lastStepVal, null != shadowColorArray ? shadowColorArray : nextStepVal, ratio, !0, function (fArray, tArray) {
              nextParsedProps.shadowColorArray = tArray;
            });
          return _color2 && (nextAttributes[key] = _color2), !0;
        }
        return !1;
      }
    }, {
      key: "_interpolate",
      value: function _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {}
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this)[this.type][name];
      }
    }, {
      key: "getComputedAttribute",
      value: function getComputedAttribute(name) {
        var _a;
        return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
      }
    }, {
      key: "onSetStage",
      value: function onSetStage(cb) {
        var immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
      }
    }, {
      key: "attachShadow",
      value: function attachShadow(shadowRoot) {
        return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application.graphicService.creator.shadowRoot(this), this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
      }
    }, {
      key: "detachShadow",
      value: function detachShadow() {
        this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot = null);
      }
    }, {
      key: "toJson",
      value: function toJson() {
        return {
          attribute: this.attribute,
          _uid: this._uid,
          type: this.type,
          name: this.name,
          children: this.children.map(function (item) {
            return item.toJson();
          })
        };
      }
    }, {
      key: "createPathProxy",
      value: function createPathProxy(path) {
        return isString$1(path, !0) ? this.pathProxy = new CustomPath2D().fromString(path) : this.pathProxy = new CustomPath2D(), this.pathProxy;
      }
    }, {
      key: "loadImage",
      value: function loadImage(image) {
        var background = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        if (!image || background && backgroundNotImage(image)) return;
        var url = image;
        this.resources || (this.resources = new Map());
        var cache = {
          data: "init",
          state: null
        };
        this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", image.startsWith("<svg") ? (ResourceLoader.GetSvg(image, this), this.backgroundImg = this.backgroundImg || background) : (isValidUrl$1(image) || image.includes("/") || isBase64$1(image)) && (ResourceLoader.GetImage(image, this), this.backgroundImg = this.backgroundImg || background)) : isObject$1(image) ? (cache.state = "success", cache.data = image, this.backgroundImg = this.backgroundImg || background) : cache.state = "fail";
      }
    }, {
      key: "imageLoadSuccess",
      value: function imageLoadSuccess(url, image, cb) {
        if (!this.resources) return;
        var res = this.resources.get(url);
        res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), this.stage && this.stage.renderNextFrame());
      }
    }, {
      key: "imageLoadFail",
      value: function imageLoadFail(url, cb) {
        if (!this.resources) return;
        var res = this.resources.get(url);
        res && (res.state = "fail", cb && cb());
      }
    }, {
      key: "_stopAnimates",
      value: function _stopAnimates(animates) {
        animates && animates.forEach(function (animate) {
          animate.stop();
        });
      }
    }, {
      key: "stopAnimates",
      value: function stopAnimates() {
        var stopChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        this._stopAnimates(this.animates), this.shadowRoot && this.shadowRoot.stopAnimates(!0), this.isContainer && stopChildren && this.forEachChildren(function (c) {
          c.stopAnimates(stopChildren);
        });
      }
    }, {
      key: "release",
      value: function release() {
        this.releaseStatus = "released", application.graphicService.onRelease(this);
      }
    }, {
      key: "_emitCustomEvent",
      value: function _emitCustomEvent(type, context) {
        var _a, _b;
        if (this._events && type in this._events) {
          var changeEvent = new CustomEvent(type, context);
          changeEvent.bubbles = !1, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, this.dispatchEvent(changeEvent);
        }
      }
    }], [{
      key: "mixin",
      value: function mixin(source) {
        var keys = Object.keys(source);
        for (var i = 0; i < keys.length; ++i) {
          var propertyName = keys[i];
          Object.defineProperty(Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
      }
    }]);
    return Graphic;
  }(Node);
  function backgroundNotImage(image) {
    return !(!image.fill && !image.stroke);
  }
  Graphic.mixin(EventTarget);

  function getAllMatches(string, regex) {
    var matches = [];
    var match = regex.exec(string);
    for (; match;) {
      var allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      var len = match.length;
      for (var index = 0; index < len; index++) allmatches.push(match[index]);
      matches.push(allmatches), match = regex.exec(string);
    }
    return matches;
  }

  var XmlNode = /*#__PURE__*/function () {
    function XmlNode(tagname) {
      _classCallCheck(this, XmlNode);
      this.tagname = tagname, this.child = [], this[":@"] = {};
    }
    _createClass(XmlNode, [{
      key: "add",
      value: function add(key, val) {
        "__proto__" === key && (key = "#__proto__"), this.child.push(_defineProperty({}, key, val));
      }
    }, {
      key: "addChild",
      value: function addChild(node) {
        "__proto__" === node.tagname && (node.tagname = "#__proto__"), node[":@"] && Object.keys(node[":@"]).length > 0 ? this.child.push(_defineProperty(_defineProperty({}, node.tagname, node.child), ":@", node[":@"])) : this.child.push(_defineProperty({}, node.tagname, node.child));
      }
    }]);
    return XmlNode;
  }();
  function findClosingIndex(xmlData, str, i, errMsg) {
    var closingIndex = xmlData.indexOf(str, i);
    if (-1 === closingIndex) throw new Error(errMsg);
    return closingIndex + str.length - 1;
  }
  function tagExpWithClosingIndex(xmlData, i) {
    var closingChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ">";
    var attrBoundary,
      tagExp = "";
    for (var index = i; index < xmlData.length; index++) {
      var ch = xmlData[index];
      if (attrBoundary) ch === attrBoundary && (attrBoundary = "");else if ('"' === ch || "'" === ch) attrBoundary = ch;else if (ch === closingChar[0]) {
        if (!closingChar[1]) return {
          data: tagExp,
          index: index
        };
        if (xmlData[index + 1] === closingChar[1]) return {
          data: tagExp,
          index: index
        };
      } else "\t" === ch && (ch = " ");
      tagExp += ch;
    }
  }
  function readTagExp(xmlData, i, removeNSPrefix) {
    var closingChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ">";
    var result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
    if (!result) return;
    var tagExp = result.data;
    var closeIndex = result.index,
      separatorIndex = tagExp.search(/\s/);
    var tagName = tagExp,
      attrExpPresent = !0;
    -1 !== separatorIndex && (tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, ""), tagExp = tagExp.substr(separatorIndex + 1));
    var rawTagName = tagName;
    if (removeNSPrefix) {
      var colonIndex = tagName.indexOf(":");
      -1 !== colonIndex && (tagName = tagName.substr(colonIndex + 1), attrExpPresent = tagName !== result.data.substr(colonIndex + 1));
    }
    return {
      tagName: tagName,
      tagExp: tagExp,
      closeIndex: closeIndex,
      attrExpPresent: attrExpPresent,
      rawTagName: rawTagName
    };
  }
  var attrsRegx = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", "gm");
  var OrderedObjParser = /*#__PURE__*/function () {
    function OrderedObjParser(options) {
      _classCallCheck(this, OrderedObjParser);
      this.currentNode = null, this.options = options, this.tagsNodeStack = [], this.docTypeEntities = {};
    }
    _createClass(OrderedObjParser, [{
      key: "addChild",
      value: function addChild(currentNode, childNode, jPath) {
        var result = childNode.tagname;
        "string" == typeof result ? (childNode.tagname = result, currentNode.addChild(childNode)) : currentNode.addChild(childNode);
      }
    }, {
      key: "buildAttributesMap",
      value: function buildAttributesMap(attrStr, jPath, tagName) {
        var attrs = {};
        if (!attrStr) return;
        var matches = getAllMatches(attrStr, attrsRegx),
          len = matches.length;
        for (var i = 0; i < len; i++) {
          var attrName = matches[i][1],
            oldVal = matches[i][4],
            aName = attrName;
          attrName && (attrs[aName] = void 0 === oldVal || (isNaN(oldVal) ? oldVal : Number(oldVal)));
        }
        return attrs;
      }
    }, {
      key: "parseXml",
      value: function parseXml(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, "\n");
        var xmlObj = new XmlNode("!xml");
        var currentNode = xmlObj,
          textData = "",
          jPath = "";
        for (var i = 0; i < xmlData.length; i++) {
          if ("<" === xmlData[i]) {
            if ("/" === xmlData[i + 1]) {
              var closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed."),
                propIndex = jPath.lastIndexOf(".");
              jPath = jPath.substring(0, propIndex), currentNode = this.tagsNodeStack.pop(), currentNode && currentNode.child && textData && currentNode.child[currentNode.child.length - 1][":@"] && (currentNode.child[currentNode.child.length - 1][":@"].text = textData), textData = "", i = closeIndex;
            } else if ("?" === xmlData[i + 1]) {
              i = readTagExp(xmlData, i, !1, "?>").closeIndex + 1;
            } else if ("!--" === xmlData.substr(i + 1, 3)) {
              i = findClosingIndex(xmlData, "--\x3e", i + 4, "Comment is not closed.");
            } else {
              var result = readTagExp(xmlData, i, !1);
              var tagName = result.tagName,
                tagExp = result.tagExp;
              var attrExpPresent = result.attrExpPresent,
                _closeIndex = result.closeIndex;
              if (tagName !== xmlObj.tagname && (jPath += jPath ? "." + tagName : tagName), tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                "/" === tagName[tagName.length - 1] ? (tagName = tagName.substr(0, tagName.length - 1), jPath = jPath.substr(0, jPath.length - 1), tagExp = tagName) : tagExp = tagExp.substr(0, tagExp.length - 1);
                var childNode = new XmlNode(tagName);
                tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                var _childNode = new XmlNode(tagName);
                this.tagsNodeStack.push(currentNode), tagName !== tagExp && attrExpPresent && (_childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, _childNode, jPath), currentNode = _childNode;
              }
              textData = "", i = _closeIndex;
            }
          } else textData += xmlData[i];
        }
        return xmlObj.child;
      }
    }]);
    return OrderedObjParser;
  }();

  function prettify(node, options) {
    return compress(node);
  }
  function compress(arr, jPath) {
    var compressedObj = {};
    for (var i = 0; i < arr.length; i++) {
      var tagObj = arr[i],
        property = propName(tagObj);
      if (void 0 !== property && tagObj[property]) {
        var val = compress(tagObj[property]);
        isLeafTag(val);
        tagObj[":@"] && assignAttributes(val, tagObj[":@"]), void 0 !== compressedObj[property] && compressedObj.hasOwnProperty(property) ? (Array.isArray(compressedObj[property]) || (compressedObj[property] = [compressedObj[property]]), compressedObj[property].push(val)) : compressedObj[property] = val;
      }
    }
    return compressedObj;
  }
  function propName(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (":@" !== key) return key;
    }
  }
  function assignAttributes(obj, attrMap, jpath) {
    if (attrMap) {
      var keys = Object.keys(attrMap),
        len = keys.length;
      for (var i = 0; i < len; i++) {
        var atrrName = keys[i];
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
  function isLeafTag(obj) {
    return 0 === Object.keys(obj).length;
  }

  var XMLParser = /*#__PURE__*/function () {
    function XMLParser(options) {
      _classCallCheck(this, XMLParser);
      this.options = Object.assign({}, XMLParser.defaultOptions, options);
    }
    _createClass(XMLParser, [{
      key: "valid",
      value: function valid(xml) {
        return xml.startsWith("<");
      }
    }, {
      key: "parse",
      value: function parse(xmlData) {
        if (!this.valid) return !1;
        var orderedResult = new OrderedObjParser(this.options).parseXml(xmlData);
        return prettify(orderedResult, this.options);
      }
    }]);
    return XMLParser;
  }();
  XMLParser.defaultOptions = {};
  function isSvg(str) {
    return str.startsWith("<svg") || str.startsWith("<?xml");
  }
  function isXML(str) {
    return str.startsWith("<");
  }

  var __awaiter$4 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function incrementalAddTo(group, graphic) {
    group.incrementalAppendChild(graphic);
  }
  function waitForAllSubLayers(stage) {
    return __awaiter$4(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var promiseList, layers;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            promiseList = [], layers = stage.getChildren();
            _context.next = 3;
            return new Promise(function (resolve) {
              application.global.getRequestAnimationFrame()(function () {
                resolve(null);
              });
            });
          case 3:
            layers.forEach(function (l) {
              l.subLayers.size && l.subLayers.forEach(function (sl) {
                sl.drawContribution && sl.drawContribution.hooks && sl.drawContribution.rendering && promiseList.push(new Promise(function (resolve) {
                  sl.drawContribution.hooks.completeDraw.tap("outWait", function () {
                    sl.drawContribution.hooks.completeDraw.taps = sl.drawContribution.hooks.completeDraw.taps.filter(function (i) {
                      return "outWait" !== i.name;
                    }), resolve(null);
                  });
                }));
              });
            });
            _context.next = 6;
            return Promise.all(promiseList);
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
  }
  function boundStroke(bounds, halfW, miter) {
    var pad = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), bounds;
  }
  function miterAdjustment(miter, strokeWidth) {
    return miter ? strokeWidth : 0;
  }
  var NUMBER_TYPE = 0;
  function genNumberType() {
    return NUMBER_TYPE++;
  }
  exports.TextDirection = void 0;
  !function (TextDirection) {
    TextDirection[TextDirection.HORIZONTAL = 0] = "HORIZONTAL", TextDirection[TextDirection.VERTICAL = 1] = "VERTICAL";
  }(exports.TextDirection || (exports.TextDirection = {}));
  function verticalLayout(text) {
    var nextCharacter = [];
    var flag = 0,
      currStr = "";
    for (var i = 0; i < text.length; i++) rotateText(text[i]) ? flag ? currStr += text[i] : (flag = 1, currStr = text[i]) : (flag && (nextCharacter.push({
      text: currStr,
      direction: exports.TextDirection.VERTICAL
    }), currStr = "", flag = 0), nextCharacter.push({
      text: text[i],
      direction: exports.TextDirection.HORIZONTAL
    }));
    return currStr && nextCharacter.push({
      text: currStr,
      direction: exports.TextDirection.VERTICAL
    }), nextCharacter;
  }
  var rotateCharList = ["…", "（", "）", "—", "【", "】", "「", "」", "《", "》"],
    rotateCharMap = new Map();
  rotateCharList.forEach(function (c) {
    return rotateCharMap.set(c, !0);
  });
  var noRotateCharList = [""],
    noRotateCharMap = new Map();
  function rotateText(c) {
    if (rotateCharMap.has(c)) return !0;
    if (noRotateCharMap.has(c)) return !1;
    var rotate = !1;
    return c.codePointAt(0) < 256 && (rotate = !0), rotate;
  }
  noRotateCharList.forEach(function (c) {
    return noRotateCharMap.set(c, !0);
  });
  function xul(str) {
    var xmlStr = isArray$1(str) ? str[0] : str,
      config = [];
    if (!xmlStr) return config;
    if (!0 === isXML(xmlStr)) {
      var data = new XMLParser().parse(xmlStr);
      data.tc && Object.keys(data.tc).forEach(function (k) {
        "text" === k ? config.push(parseRTTextXML(data.tc[k])) : config.push(parseRTImageXML(data.tc[k]));
      });
    }
    return config;
  }
  function parseRTTextXML(str) {
    var output = {
      text: ""
    };
    parseCommonXML(str, output);
    var inlineText = str["#text"];
    return inlineText && (output.text = inlineText), output;
  }
  function parseCommonXML(str, output) {
    var attr = str.attribute;
    if (attr) {
      attr.split(";").forEach(function (attrItem) {
        if (!attrItem) return;
        var kv = attrItem.split(":");
        if (2 === kv.length) {
          var val = parseFloat(kv[1]);
          output[kv[0].trim()] = isFinite(val) ? val : kv[1].trim();
        } else {
          var _val = "";
          for (var i = 1; i < kv.length; i++) i > 1 && (_val += ":"), _val += kv[i].trim();
          output[kv[0].trim()] = _val;
        }
      });
    }
  }
  function parseRTImageXML(str) {
    var output = {
      image: "",
      width: 0,
      height: 0
    };
    parseCommonXML(str, output);
    var image = output.image;
    return image && (output.image = image.replaceAll("&quot", '"').replaceAll("&lt", "<").replaceAll("&gt", ">")), output;
  }

  var ARC_NUMBER_TYPE = genNumberType();
  var ARC3D_NUMBER_TYPE = genNumberType();
  var AREA_NUMBER_TYPE = genNumberType();
  var CIRCLE_NUMBER_TYPE = genNumberType();
  var GLYPH_NUMBER_TYPE = genNumberType();
  var GROUP_NUMBER_TYPE = genNumberType();
  var IMAGE_NUMBER_TYPE = genNumberType();
  var LINE_NUMBER_TYPE = genNumberType();
  var PATH_NUMBER_TYPE = genNumberType();
  var POLYGON_NUMBER_TYPE = genNumberType();
  var PYRAMID3D_NUMBER_TYPE = genNumberType();
  var RECT_NUMBER_TYPE = genNumberType();
  var RECT3D_NUMBER_TYPE = genNumberType();
  var RICHTEXT_NUMBER_TYPE = genNumberType();
  var SYMBOL_NUMBER_TYPE = genNumberType();
  var TEXT_NUMBER_TYPE = genNumberType();
  var GraphicService = Symbol["for"]("GraphicService");
  var GraphicCreator$1 = Symbol["for"]("GraphicCreator");
  var SVG_ATTRIBUTE_MAP = {
    "stroke-linecap": "lineCap",
    "stroke-linejoin": "lineJoin",
    "stroke-dasharray": "lineDash",
    "stroke-dashoffset": "lineDashOffset",
    "stroke-width": "lineWidth",
    "fill-opacity": "fillOpacity",
    "stroke-opacity": "strokeOpacity"
  };
  var SVG_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_ATTRIBUTE_MAP);
  var SVG_PARSE_ATTRIBUTE_MAP = {
    "stroke-linecap": "lineCap",
    "stroke-linejoin": "lineJoin",
    "stroke-dasharray": "lineDash",
    "stroke-dashoffset": "lineDashOffset",
    "stroke-width": "lineWidth",
    "fill-opacity": "fillOpacity",
    "stroke-opacity": "strokeOpacity",
    stroke: "stroke",
    fill: "fill"
  };
  var SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

  exports.GroupUpdateAABBBoundsMode = void 0;
  !function (GroupUpdateAABBBoundsMode) {
    GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.LESS_GROUP = 0] = "LESS_GROUP", GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.MORE_GROUP = 1] = "MORE_GROUP";
  }(exports.GroupUpdateAABBBoundsMode || (exports.GroupUpdateAABBBoundsMode = {}));
  var Group = /*#__PURE__*/function (_Graphic) {
    _inherits(Group, _Graphic);
    var _super = _createSuper(Group);
    function Group(params) {
      var _this;
      _classCallCheck(this, Group);
      _this = _super.call(this, params), _this.type = "group", _this.parent = null, _this.isContainer = !0, _this.numberType = GROUP_NUMBER_TYPE, _this._childUpdateTag = exports.UpdateTag.UPDATE_BOUNDS;
      return _this;
    }
    _createClass(Group, [{
      key: "setMode",
      value: function setMode(mode) {
        "3d" === mode ? this.set3dMode() : this.set2dMode();
      }
    }, {
      key: "set3dMode",
      value: function set3dMode() {
        this.in3dMode = !0;
      }
    }, {
      key: "set2dMode",
      value: function set2dMode() {
        this.in3dMode = !1;
      }
    }, {
      key: "setTheme",
      value: function setTheme(t) {
        return this.theme || (this.theme = new Theme()), this.theme.setTheme(t, this);
      }
    }, {
      key: "createTheme",
      value: function createTheme() {
        this.theme || (this.theme = new Theme());
      }
    }, {
      key: "hideAll",
      value: function hideAll() {
        this.setAttribute("visible", !1), this.forEachChildren(function (item) {
          item.isContainer && item.hideAll ? item.hideAll() : item.setAttribute("visible", !1);
        });
      }
    }, {
      key: "showAll",
      value: function showAll() {
        this.setAttribute("visible", !0), this.forEachChildren(function (item) {
          item.isContainer && item.showAll ? item.showAll() : item.setAttribute("visible", !0);
        });
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(x, y, mode) {
        if (mode === exports.IContainPointMode.GLOBAL) {
          var point = new Point(x, y);
          return this.parent && this.parent.globalTransMatrix.transformPoint(point, point), this.AABBBounds.contains(point.x, point.y);
        }
        return this.AABBBounds.contains(x, y);
      }
    }, {
      key: "shouldUpdateAABBBounds",
      value: function shouldUpdateAABBBounds() {
        return !!_get(_getPrototypeOf(Group.prototype), "shouldUpdateAABBBounds", this).call(this) || !!(this._childUpdateTag & exports.UpdateTag.UPDATE_BOUNDS);
      }
    }, {
      key: "tryUpdateAABBBounds",
      value: function tryUpdateAABBBounds() {
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
        var selfChange = this.shouldSelfChangeUpdateAABBBounds(),
          bounds = this.doUpdateAABBBounds();
        return this.addUpdateLayoutTag(), application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), bounds;
      }
    }, {
      key: "doUpdateLocalMatrix",
      value: function doUpdateLocalMatrix() {
        var _this$attribute = this.attribute,
          _this$attribute$x = _this$attribute.x,
          x = _this$attribute$x === void 0 ? DefaultTransform.x : _this$attribute$x,
          _this$attribute$y = _this$attribute.y,
          y = _this$attribute$y === void 0 ? DefaultTransform.y : _this$attribute$y,
          _this$attribute$dx = _this$attribute.dx,
          dx = _this$attribute$dx === void 0 ? DefaultTransform.dx : _this$attribute$dx,
          _this$attribute$dy = _this$attribute.dy,
          dy = _this$attribute$dy === void 0 ? DefaultTransform.dy : _this$attribute$dy,
          _this$attribute$scale = _this$attribute.scaleX,
          scaleX = _this$attribute$scale === void 0 ? DefaultTransform.scaleX : _this$attribute$scale,
          _this$attribute$scale2 = _this$attribute.scaleY,
          scaleY = _this$attribute$scale2 === void 0 ? DefaultTransform.scaleY : _this$attribute$scale2,
          _this$attribute$angle = _this$attribute.angle,
          angle = _this$attribute$angle === void 0 ? DefaultTransform.angle : _this$attribute$angle,
          postMatrix = _this$attribute.postMatrix;
        if (0 !== x || 0 !== y || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle || postMatrix) return _get(_getPrototypeOf(Group.prototype), "doUpdateLocalMatrix", this).call(this);
        this._transMatrix.reset();
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var attribute = this.attribute,
          groupTheme = getTheme(this).group;
        this._AABBBounds.clear();
        var bounds = application.graphicService.updateGroupAABBBounds(attribute, groupTheme, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? groupTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.parent && this.parent.addChildUpdateBoundTag(), this.clearUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
      }
    }, {
      key: "clearUpdateBoundTag",
      value: function clearUpdateBoundTag() {
        this._updateTag &= exports.UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= exports.UpdateTag.CLEAR_BOUNDS;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "addUpdateBoundTag",
      value: function addUpdateBoundTag() {
        this._updateTag |= exports.UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
      }
    }, {
      key: "addChildUpdateBoundTag",
      value: function addChildUpdateBoundTag() {
        this._childUpdateTag & exports.UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= exports.UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag());
      }
    }, {
      key: "getTheme",
      value: function getTheme() {
        return this.theme.getTheme(this);
      }
    }, {
      key: "incrementalAppendChild",
      value: function incrementalAppendChild(node) {
        var data = _get(_getPrototypeOf(Group.prototype), "appendChild", this).call(this, node);
        return this.stage && data && (data.stage = this.stage, data.layer = this.layer), this.addUpdateBoundTag(), application.graphicService.onAddIncremental(node, this, this.stage), data;
      }
    }, {
      key: "incrementalClearChild",
      value: function incrementalClearChild() {
        _get(_getPrototypeOf(Group.prototype), "removeAllChild", this).call(this), this.addUpdateBoundTag(), application.graphicService.onClearIncremental(this, this.stage);
      }
    }, {
      key: "appendChild",
      value: function appendChild(node) {
        var addStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        var data = _get(_getPrototypeOf(Group.prototype), "appendChild", this).call(this, node);
        return addStage && this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(newNode, referenceNode) {
        var data = _get(_getPrototypeOf(Group.prototype), "insertBefore", this).call(this, newNode, referenceNode);
        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
      }
    }, {
      key: "insertAfter",
      value: function insertAfter(newNode, referenceNode) {
        var data = _get(_getPrototypeOf(Group.prototype), "insertAfter", this).call(this, newNode, referenceNode);
        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
      }
    }, {
      key: "insertInto",
      value: function insertInto(newNode, idx) {
        var data = _get(_getPrototypeOf(Group.prototype), "insertInto", this).call(this, newNode, idx);
        return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
      }
    }, {
      key: "removeChild",
      value: function removeChild(child) {
        var data = _get(_getPrototypeOf(Group.prototype), "removeChild", this).call(this, child);
        return child.stage = null, application.graphicService.onRemove(child), this.addUpdateBoundTag(), data;
      }
    }, {
      key: "removeAllChild",
      value: function removeAllChild() {
        var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        this.forEachChildren(function (child) {
          application.graphicService.onRemove(child), deep && child.isContainer && child.removeAllChild(deep);
        }), _get(_getPrototypeOf(Group.prototype), "removeAllChild", this).call(this), this.addUpdateBoundTag();
      }
    }, {
      key: "setStage",
      value: function setStage(stage, layer) {
        var _this2 = this;
        this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage), this.forEachChildren(function (item) {
          item.setStage(stage, _this2.layer);
        }));
      }
    }, {
      key: "addUpdatePositionTag",
      value: function addUpdatePositionTag() {
        _get(_getPrototypeOf(Group.prototype), "addUpdatePositionTag", this).call(this), this.forEachChildren(function (g) {
          g.isContainer && g.addUpdateGlobalPositionTag();
        });
      }
    }, {
      key: "addUpdateGlobalPositionTag",
      value: function addUpdateGlobalPositionTag() {
        _get(_getPrototypeOf(Group.prototype), "addUpdateGlobalPositionTag", this).call(this), this.forEachChildren(function (g) {
          g.isContainer && g.addUpdateGlobalPositionTag();
        });
      }
    }, {
      key: "tryUpdateGlobalTransMatrix",
      value: function tryUpdateGlobalTransMatrix() {
        var clearTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        if (this.shouldUpdateGlobalMatrix()) {
          if (this._globalTransMatrix) {
            if (this.parent) {
              var m = this.parent.globalTransMatrix;
              this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
            }
          } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
          this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
        }
        return this._globalTransMatrix;
      }
    }, {
      key: "shouldUpdateGlobalMatrix",
      value: function shouldUpdateGlobalMatrix() {
        return !!(this._updateTag & exports.UpdateTag.UPDATE_GLOBAL_MATRIX);
      }
    }, {
      key: "_getChildByName",
      value: function _getChildByName(name, deep) {
        return this.find(function (node) {
          return node.name === name;
        }, deep);
      }
    }, {
      key: "createOrUpdateChild",
      value: function createOrUpdateChild(graphicName, attributes, graphicType) {
        var graphic = this._getChildByName(graphicName);
        return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), graphic.name = graphicName, this.add(graphic)), graphic;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Group(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Group.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Group;
  }(Graphic);
  Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
  function createGroup(attributes) {
    return new Group(attributes);
  }

  var Layer = /*#__PURE__*/function (_Group) {
    _inherits(Layer, _Group);
    var _super = _createSuper(Layer);
    function Layer(stage, global, window, params) {
      var _this;
      _classCallCheck(this, Layer);
      var _a;
      _this = _super.call(this, {}), _this.stage = stage, _this.global = global, _this.window = window, _this.main = params.main, _this.layerHandler = params.layerHandler, _this.layerHandler.init(_assertThisInitialized(_this), window, {
        main: params.main,
        canvasId: params.canvasId,
        width: _this.viewWidth,
        height: _this.viewHeight,
        zIndex: null !== (_a = params.zIndex) && void 0 !== _a ? _a : 0
      }), _this.layer = _assertThisInitialized(_this), _this.subLayers = new Map(), _this.theme = new Theme(), _this.background = "rgba(0, 0, 0, 0)", _this.afterDrawCbs = [];
      return _this;
    }
    _createClass(Layer, [{
      key: "offscreen",
      get: function get() {
        return this.layerHandler.offscreen;
      }
    }, {
      key: "layerMode",
      get: function get() {
        return this.layerHandler.type;
      }
    }, {
      key: "width",
      get: function get() {
        return this.stage ? this.stage.width : 0;
      }
    }, {
      key: "height",
      get: function get() {
        return this.stage ? this.stage.height : 0;
      }
    }, {
      key: "viewWidth",
      get: function get() {
        return this.stage ? this.stage.viewWidth : 0;
      }
    }, {
      key: "viewHeight",
      get: function get() {
        return this.stage ? this.stage.viewHeight : 0;
      }
    }, {
      key: "dirtyBound",
      get: function get() {
        throw new Error("暂不支持");
      }
    }, {
      key: "dpr",
      get: function get() {
        return this._dpr;
      }
    }, {
      key: "combineSubLayer",
      value: function combineSubLayer() {
        var _this2 = this;
        var removeIncrementalKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        var subLayers = Array.from(this.subLayers.values()).sort(function (a, b) {
          return a.zIndex - b.zIndex;
        });
        this.layerHandler.merge(subLayers.map(function (l) {
          return l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), l.layer.getNativeHandler();
        })), removeIncrementalKey && subLayers.forEach(function (l) {
          l.group && (l.group.incremental = 0);
        }), subLayers.forEach(function (l) {
          application.layerService.releaseLayer(_this2.stage, l.layer);
        }), this.subLayers.clear();
      }
    }, {
      key: "getNativeHandler",
      value: function getNativeHandler() {
        return this.layerHandler;
      }
    }, {
      key: "setStage",
      value: function setStage(stage, layer) {
        _get(_getPrototypeOf(Layer.prototype), "setStage", this).call(this, stage, this);
      }
    }, {
      key: "pick",
      value: function pick(x, y) {
        throw new Error("暂不支持");
      }
    }, {
      key: "tryRenderSecondaryLayer",
      value: function tryRenderSecondaryLayer(params, userParams) {
        var _this3 = this;
        this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length && this.layerHandler.secondaryHandlers.forEach(function (h) {
          h.layer.renderCount = _this3.renderCount, h.layer.render(params, userParams);
        });
      }
    }, {
      key: "render",
      value: function render(params, userParams) {
        var _this4 = this;
        var _a;
        this.layerHandler.render([this], {
          renderService: params.renderService,
          stage: this.stage,
          layer: this,
          viewBox: params.viewBox,
          transMatrix: params.transMatrix,
          background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
          updateBounds: params.updateBounds
        }, userParams), this.afterDrawCbs.forEach(function (c) {
          return c(_this4);
        }), this.tryRenderSecondaryLayer(params, userParams);
      }
    }, {
      key: "resize",
      value: function resize(w, h) {
        this.layerHandler.resize(w, h);
      }
    }, {
      key: "resizeView",
      value: function resizeView(w, h) {
        this.layerHandler.resizeView(w, h);
      }
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        this.layerHandler.setDpr(dpr);
      }
    }, {
      key: "afterDraw",
      value: function afterDraw(cb) {
        this.afterDrawCbs.push(cb);
      }
    }, {
      key: "startAnimate",
      value: function startAnimate(t) {
        throw new Error("暂不支持");
      }
    }, {
      key: "setToFrame",
      value: function setToFrame(t) {
        throw new Error("暂不支持");
      }
    }, {
      key: "prepare",
      value: function prepare(dirtyBounds, params) {}
    }, {
      key: "release",
      value: function release() {
        var _this5 = this;
        _get(_getPrototypeOf(Layer.prototype), "release", this).call(this), this.layerHandler.release(), this.subLayers && this.subLayers.forEach(function (l) {
          application.layerService.releaseLayer(_this5.stage, l.layer);
        });
      }
    }, {
      key: "drawTo",
      value: function drawTo(target, params) {
        var _this6 = this;
        var _a;
        this.layerHandler.drawTo(target, [this], Object.assign({
          background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
          renderService: params.renderService,
          viewBox: params.viewBox,
          transMatrix: params.transMatrix,
          stage: this.stage,
          layer: this
        }, params)), this.afterDrawCbs.forEach(function (c) {
          return c(_this6);
        });
      }
    }]);
    return Layer;
  }(Group);

  var TransformUtil = Symbol["for"]("TransformUtil");
  var GraphicUtil = Symbol["for"]("GraphicUtil");
  var LayerService = Symbol["for"]("LayerService");
  var StaticLayerHandlerContribution = Symbol["for"]("StaticLayerHandlerContribution");
  var DynamicLayerHandlerContribution = Symbol["for"]("DynamicLayerHandlerContribution");
  var VirtualLayerHandlerContribution = Symbol["for"]("VirtualLayerHandlerContribution");

  var _DefaultLayerService_,
    __decorate$1C = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$1e = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  exports.DefaultLayerService = _DefaultLayerService_ = /*#__PURE__*/function () {
    function DefaultLayerService_1() {
      _classCallCheck(this, DefaultLayerService_1);
      this.layerMap = new Map(), this.global = application.global;
    }
    _createClass(DefaultLayerService_1, [{
      key: "tryInit",
      value: function tryInit() {
        this.inited || (this.staticLayerCountInEnv = this.global.getStaticCanvasCount(), this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount(), this.inited = !0);
      }
    }, {
      key: "getStageLayer",
      value: function getStageLayer(stage) {
        return this.layerMap.get(stage);
      }
    }, {
      key: "getRecommendedLayerType",
      value: function getRecommendedLayerType(layerMode) {
        return layerMode || (0 !== this.staticLayerCountInEnv ? "static" : 0 !== this.dynamicLayerCountInEnv ? "dynamic" : "virtual");
      }
    }, {
      key: "getLayerHandler",
      value: function getLayerHandler(layerMode) {
        var layerHandler;
        return layerHandler = "static" === layerMode ? container.get(StaticLayerHandlerContribution) : "dynamic" === layerMode ? container.get(DynamicLayerHandlerContribution) : container.get(VirtualLayerHandlerContribution), layerHandler;
      }
    }, {
      key: "createLayer",
      value: function createLayer(stage) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
          main: !1
        };
        var _a;
        this.tryInit();
        var layerMode = this.getRecommendedLayerType(options.layerMode);
        layerMode = options.main || options.canvasId ? "static" : layerMode;
        var layerHandler = this.getLayerHandler(layerMode),
          layer = new Layer(stage, this.global, stage.window, Object.assign(Object.assign({
            main: !1
          }, options), {
            layerMode: layerMode,
            canvasId: null !== (_a = options.canvasId) && void 0 !== _a ? _a : _DefaultLayerService_.GenerateLayerId(),
            layerHandler: layerHandler
          })),
          stageLayers = this.layerMap.get(stage) || [];
        return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), this.staticLayerCountInEnv--, layer;
      }
    }, {
      key: "prepareStageLayer",
      value: function prepareStageLayer(stage) {
        var mainHandler;
        stage.forEachChildren(function (l) {
          var handler = l.getNativeHandler();
          "virtual" === handler.type ? (handler.mainHandler = mainHandler, mainHandler.secondaryHandlers.push(handler)) : (mainHandler = handler, mainHandler.secondaryHandlers = []);
        });
      }
    }, {
      key: "releaseLayer",
      value: function releaseLayer(stage, layer) {
        layer.release();
        var stageLayers = this.layerMap.get(stage) || [];
        this.layerMap.set(stage, stageLayers.filter(function (l) {
          return l !== layer;
        }));
      }
    }, {
      key: "layerCount",
      value: function layerCount(stage) {
        return (this.layerMap.get(stage) || []).length;
      }
    }, {
      key: "restLayerCount",
      value: function restLayerCount(stage) {
        return "browser" === this.global.env ? 10 : 0;
      }
    }, {
      key: "releaseStage",
      value: function releaseStage(stage) {
        this.layerMap["delete"](stage);
      }
    }], [{
      key: "GenerateLayerId",
      value: function GenerateLayerId() {
        return "".concat(_DefaultLayerService_.idprefix, "_").concat(_DefaultLayerService_.prefix_count++);
      }
    }]);
    return DefaultLayerService_1;
  }();
  exports.DefaultLayerService.idprefix = "visactor_layer", exports.DefaultLayerService.prefix_count = 0, exports.DefaultLayerService = _DefaultLayerService_ = __decorate$1C([injectable(), __metadata$1e("design:paramtypes", [])], exports.DefaultLayerService);

  var coreModule = new ContainerModule(function (bind) {
    bind(VGlobal).to(exports.DefaultGlobal).inSingletonScope(), bind(VWindow).to(exports.DefaultWindow), bind(GraphicUtil).to(exports.DefaultGraphicUtil).inSingletonScope(), bind(TransformUtil).to(exports.DefaultTransformUtil).inSingletonScope(), bind(LayerService).to(exports.DefaultLayerService).inSingletonScope();
  });

  function runFill(fill, background) {
    return !(!fill && !background);
  }
  function runStroke(stroke, lineWidth) {
    var s;
    return s = isArray$1(stroke) ? stroke.some(function (item) {
      return item || void 0 === item;
    }) : !!stroke, s && lineWidth > 0;
  }
  function fillVisible(opacity, fillOpacity, fill) {
    return fill && opacity * fillOpacity > 0;
  }
  function rectFillVisible(opacity, fillOpacity, width, height, fill) {
    return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
  }
  function strokeVisible(opacity, strokeOpacity) {
    return opacity * strokeOpacity > 0;
  }
  function rectStrokeVisible(opacity, strokeOpacity, width, height) {
    return opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
  }
  function drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
    if (!graphic.pathProxy) return !1;
    var themeAttributes = getTheme(graphic, null == params ? void 0 : params.theme)[graphic.type],
      _graphic$attribute = graphic.attribute,
      _graphic$attribute$fi = _graphic$attribute.fill,
      fill = _graphic$attribute$fi === void 0 ? themeAttributes.fill : _graphic$attribute$fi,
      _graphic$attribute$st = _graphic$attribute.stroke,
      stroke = _graphic$attribute$st === void 0 ? themeAttributes.stroke : _graphic$attribute$st,
      _graphic$attribute$op = _graphic$attribute.opacity,
      opacity = _graphic$attribute$op === void 0 ? themeAttributes.opacity : _graphic$attribute$op,
      _graphic$attribute$fi2 = _graphic$attribute.fillOpacity,
      fillOpacity = _graphic$attribute$fi2 === void 0 ? themeAttributes.fillOpacity : _graphic$attribute$fi2,
      _graphic$attribute$li = _graphic$attribute.lineWidth,
      lineWidth = _graphic$attribute$li === void 0 ? themeAttributes.lineWidth : _graphic$attribute$li,
      _graphic$attribute$st2 = _graphic$attribute.strokeOpacity,
      strokeOpacity = _graphic$attribute$st2 === void 0 ? themeAttributes.strokeOpacity : _graphic$attribute$st2,
      _graphic$attribute$vi = _graphic$attribute.visible,
      visible = _graphic$attribute$vi === void 0 ? themeAttributes.visible : _graphic$attribute$vi,
      _graphic$attribute$x = _graphic$attribute.x,
      originX = _graphic$attribute$x === void 0 ? themeAttributes.x : _graphic$attribute$x,
      _graphic$attribute$y = _graphic$attribute.y,
      originY = _graphic$attribute$y === void 0 ? themeAttributes.y : _graphic$attribute$y,
      fVisible = fillVisible(opacity, fillOpacity, fill),
      sVisible = strokeVisible(opacity, strokeOpacity),
      doFill = runFill(fill),
      doStroke = runStroke(stroke, lineWidth);
    if (!visible) return !0;
    if (!doFill && !doStroke) return !0;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return !0;
    context.beginPath();
    var path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    return renderCommandList(path.commandList, context, x, y), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.fill())), !0;
  }
  function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    var x10 = x1 - x0,
      y10 = y1 - y0,
      x32 = x3 - x2,
      y32 = y3 - y2;
    var t = y32 * x10 - x32 * y10;
    return t * t < epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, [x0 + t * x10, y0 + t * y10]);
  }
  function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
    var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
    var cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2;
    var cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;
    return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1)
    };
  }
  function drawArcPath$1(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
    var _arc$getParsedAngle = arc.getParsedAngle(),
      startAngle = _arc$getParsedAngle.startAngle,
      endAngle = _arc$getParsedAngle.endAngle,
      deltaAngle = abs(endAngle - startAngle),
      clockwise = endAngle > startAngle;
    var collapsedToLine = !1;
    if (outerRadius < innerRadius) {
      var temp = outerRadius;
      outerRadius = innerRadius, innerRadius = temp;
    }
    if (outerRadius <= epsilon) context.moveTo(cx, cy);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise));else {
      var cornerRadius = arc.getParsedCornerRadius(),
        _arc$getParsePadAngle = arc.getParsePadAngle(startAngle, endAngle),
        outerDeltaAngle = _arc$getParsePadAngle.outerDeltaAngle,
        innerDeltaAngle = _arc$getParsePadAngle.innerDeltaAngle,
        outerStartAngle = _arc$getParsePadAngle.outerStartAngle,
        outerEndAngle = _arc$getParsePadAngle.outerEndAngle,
        innerEndAngle = _arc$getParsePadAngle.innerEndAngle,
        innerStartAngle = _arc$getParsePadAngle.innerStartAngle,
        outerCornerRadiusStart = cornerRadius,
        outerCornerRadiusEnd = cornerRadius,
        innerCornerRadiusEnd = cornerRadius,
        innerCornerRadiusStart = cornerRadius,
        maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart),
        maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
      var limitedOcr = maxOuterCornerRadius,
        limitedIcr = maxInnerCornerRadius;
      var xors = outerRadius * cos(outerStartAngle),
        yors = outerRadius * sin(outerStartAngle),
        xire = innerRadius * cos(innerEndAngle),
        yire = innerRadius * sin(innerEndAngle);
      var xore, yore, xirs, yirs;
      if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
        var oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
        if (oc) {
          var ax = xors - oc[0],
            ay = yors - oc[1],
            bx = xore - oc[0],
            by = yore - oc[1],
            kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
            lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
        }
      }
      if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), collapsedToLine = !0;else if (limitedOcr > epsilon) {
        var cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
          cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
          t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
          t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
        limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
      } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
      if (!(innerRadius > epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
        var _cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
          _cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
          _t = cornerTangents(xire, yire, xore, yore, innerRadius, -_cornerRadiusEnd, Number(clockwise)),
          _t2 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -_cornerRadiusStart, Number(clockwise));
        if (!partStroke || partStroke[1] ? context.lineTo(cx + _t.cx + _t.x01, cy + _t.cy + _t.y01) : context.moveTo(cx + _t.cx + _t.x01, cy + _t.cy + _t.y01), limitedIcr < maxInnerCornerRadius && _cornerRadiusStart === _cornerRadiusEnd) {
          var arcEndAngle = atan2(_t2.y01, _t2.x01);
          !partStroke || partStroke[2] ? context.arc(cx + _t.cx, cy + _t.cy, limitedIcr, atan2(_t.y01, _t.x01), arcEndAngle, !clockwise) : context.moveTo(cx + _t.cx + cos(arcEndAngle), cy + _t.cy + sin(arcEndAngle));
        } else !partStroke || partStroke[2] ? (_cornerRadiusEnd > 0 && context.arc(cx + _t.cx, cy + _t.cy, _cornerRadiusEnd, atan2(_t.y01, _t.x01), atan2(_t.y11, _t.x11), !clockwise), context.arc(cx, cy, innerRadius, atan2(_t.cy + _t.y11, _t.cx + _t.x11), atan2(_t2.cy + _t2.y11, _t2.cx + _t2.x11), clockwise), _cornerRadiusStart > 0 && context.arc(cx + _t2.cx, cy + _t2.cy, _cornerRadiusStart, atan2(_t2.y11, _t2.x11), atan2(_t2.y01, _t2.x01), !clockwise)) : _cornerRadiusStart > 0 ? context.moveTo(cx + _t2.cx + _cornerRadiusStart * cos(atan2(_t2.y01, _t2.x01)), cy + _t2.cy + _cornerRadiusStart * sin(atan2(_t2.y01, _t2.x01))) : context.moveTo(cx + xirs, cy + yirs);
      } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
    }
    return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), collapsedToLine;
  }

  var ConicalCanvas = /*#__PURE__*/function () {
    function ConicalCanvas() {
      _classCallCheck(this, ConicalCanvas);
    }
    _createClass(ConicalCanvas, null, [{
      key: "GetCanvas",
      value: function GetCanvas() {
        try {
          return ConicalCanvas.canvas || (ConicalCanvas.canvas = application.global.createCanvas({})), ConicalCanvas.canvas;
        } catch (err) {
          return null;
        }
      }
    }, {
      key: "GetCtx",
      value: function GetCtx() {
        if (!ConicalCanvas.ctx) {
          var conicalCanvas = ConicalCanvas.GetCanvas();
          ConicalCanvas.ctx = conicalCanvas.getContext("2d");
        }
        return ConicalCanvas.ctx;
      }
    }]);
    return ConicalCanvas;
  }();
  var ColorInterpolate = /*#__PURE__*/function (_LRU) {
    _inherits(ColorInterpolate, _LRU);
    var _super = _createSuper(ColorInterpolate);
    function ColorInterpolate() {
      var _this;
      var stops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
      _classCallCheck(this, ColorInterpolate);
      _this = _super.call(this), _this.cacheParams = {
        CLEAN_THRESHOLD: 100,
        L_TIME: 1e3
      }, _this.dataMap = new Map();
      var canvas = ConicalCanvas.GetCanvas(),
        conicalCtx = ConicalCanvas.GetCtx();
      if (canvas.width = precision, canvas.height = 1, !conicalCtx) return _possibleConstructorReturn(_this);
      if (conicalCtx.translate(0, 0), !conicalCtx) throw new Error("获取ctx发生错误");
      var gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);
      stops.forEach(function (stop) {
        gradient.addColorStop(stop[0], stop[1]);
      }), conicalCtx.fillStyle = gradient, conicalCtx.fillRect(0, 0, precision, 1), _this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;
      return _this;
    }
    _createClass(ColorInterpolate, [{
      key: "getColor",
      value: function getColor(offset) {
        var rgba = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
        return "rgba(".concat(rgba[0], ", ").concat(rgba[1], ", ").concat(rgba[2], ", ").concat(rgba[3] / 255, ")");
      }
    }, {
      key: "GetOrCreate",
      value: function GetOrCreate(x, y, w, h) {
        var stops = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
        var precision = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;
        var str = "".concat(x).concat(y).concat(w).concat(h);
        stops.forEach(function (item) {
          return str += item.join();
        }), str += precision;
        var colorInter = this.dataMap.get(str);
        if (!colorInter) {
          colorInter = {
            data: new ColorInterpolate(stops, precision),
            timestamp: []
          }, this.addLimitedTimestamp(colorInter, Date.now(), {}), this.dataMap.set(str, colorInter);
        }
        return this.clearCache(this.dataMap, this.cacheParams), colorInter.data;
      }
    }], [{
      key: "getInstance",
      value: function getInstance() {
        return ColorInterpolate._instance || (ColorInterpolate._instance = new ColorInterpolate()), ColorInterpolate._instance;
      }
    }]);
    return ColorInterpolate;
  }(LRU);
  var ConicalPatternStore = /*#__PURE__*/function () {
    function ConicalPatternStore() {
      _classCallCheck(this, ConicalPatternStore);
    }
    _createClass(ConicalPatternStore, null, [{
      key: "GetSize",
      value: function GetSize(minSize) {
        for (var i = 0; i < ConicalPatternStore.ImageSize.length; i++) if (ConicalPatternStore.ImageSize[i] >= minSize) return ConicalPatternStore.ImageSize[i];
        return minSize;
      }
    }, {
      key: "Get",
      value: function Get(stops, x, y, startAngle, endAngle, w, h) {
        var key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle),
          data = ConicalPatternStore.cache[key];
        if (!data || 0 === data.length) return null;
        for (var i = 0; i < data.length; i++) if (data[i].width >= w && data[i].height >= h) return data[i].pattern;
        return null;
      }
    }, {
      key: "Set",
      value: function Set(stops, x, y, startAngle, endAngle, pattern, w, h) {
        var key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
        ConicalPatternStore.cache[key] ? ConicalPatternStore.cache[key].push({
          width: w,
          height: h,
          pattern: pattern
        }) : ConicalPatternStore.cache[key] = [{
          width: w,
          height: h,
          pattern: pattern
        }];
      }
    }, {
      key: "GenKey",
      value: function GenKey(stops, x, y, startAngle, endAngle) {
        return "".concat(x, ",").concat(y, ",").concat(startAngle, ",").concat(endAngle, ",").concat(stops.join());
      }
    }]);
    return ConicalPatternStore;
  }();
  ConicalPatternStore.cache = {}, ConicalPatternStore.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560];
  function getConicGradientAt(x, y, angle, color) {
    var stops = color.stops,
      startAngle = color.startAngle,
      endAngle = color.endAngle;
    for (; angle < 0;) angle += pi2;
    for (; angle > pi2;) angle -= pi2;
    if (angle < startAngle) return stops[0].color;
    if (angle > endAngle) return stops[0].color;
    var startStop,
      endStop,
      percent = (angle - startAngle) / (endAngle - startAngle);
    for (var i = 0; i < stops.length; i++) if (stops[i].offset >= percent) {
      startStop = stops[i - 1], endStop = stops[i];
      break;
    }
    return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), interpolateColor(startStop.color, endStop.color, percent, !1);
  }
  function createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {
    var deltaDeg = Math.floor(180 * deltaAngle / Math.PI),
      conicalCanvas = ConicalCanvas.GetCanvas(),
      conicalCtx = ConicalCanvas.GetCtx();
    if (!conicalCtx) return null;
    var width = ConicalPatternStore.GetSize(minW),
      height = ConicalPatternStore.GetSize(minH);
    var pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);
    if (pattern) return pattern;
    var r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2)))),
      stepNum = deltaDeg + 1,
      step = deltaAngle / Math.max(1, stepNum - 1),
      colorInter = ColorInterpolate.getInstance().GetOrCreate(x, y, width, height, stops, stepNum),
      lineWidth = 2 * Math.PI * r / 360;
    conicalCanvas.width = width, conicalCanvas.height = height, conicalCtx.setTransform(1, 0, 0, 1, 0, 0), conicalCtx.clearRect(0, 0, width, height), conicalCtx.translate(x, y), conicalCtx.rotate(startAngle);
    for (var i = 0, len = stepNum - 1; i < len && !(startAngle + i * step > endAngle); i++) {
      var color = colorInter.getColor(i);
      conicalCtx.beginPath(), conicalCtx.rotate(step), conicalCtx.moveTo(0, 0), conicalCtx.lineTo(r, -2 * lineWidth), conicalCtx.lineTo(r, 0), conicalCtx.fillStyle = color, conicalCtx.closePath(), conicalCtx.fill();
    }
    var imageData = conicalCtx.getImageData(0, 0, width, height);
    return conicalCanvas.width = imageData.width, conicalCanvas.height = imageData.height, conicalCtx.putImageData(imageData, 0, 0), pattern = context.createPattern(conicalCanvas, "no-repeat"), pattern && ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height), pattern;
  }

  var ArcRenderContribution = Symbol["for"]("ArcRenderContribution");
  var AreaRenderContribution = Symbol["for"]("AreaRenderContribution");
  var CircleRenderContribution = Symbol["for"]("CircleRenderContribution");
  var GroupRenderContribution = Symbol["for"]("GroupRenderContribution");
  var ImageRenderContribution = Symbol["for"]("ImageRenderContribution");
  var PathRenderContribution = Symbol["for"]("PathRenderContribution");
  var PolygonRenderContribution = Symbol["for"]("PolygonRenderContribution");
  var RectRenderContribution = Symbol["for"]("RectRenderContribution");
  var SymbolRenderContribution = Symbol["for"]("SymbolRenderContribution");
  var TextRenderContribution = Symbol["for"]("TextRenderContribution");
  var CommonRenderContribution = Symbol["for"]("CommonRenderContribution");
  var InteractiveSubRenderContribution = Symbol["for"]("InteractiveSubRenderContribution");

  var CIRCLE_UPDATE_TAG_KEY = ["radius", "startAngle", "endAngle"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var Circle = /*#__PURE__*/function (_Graphic) {
    _inherits(Circle, _Graphic);
    var _super = _createSuper(Circle);
    function Circle() {
      var _this;
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        radius: 1
      };
      _classCallCheck(this, Circle);
      _this = _super.call(this, params), _this.type = "circle", _this.numberType = CIRCLE_NUMBER_TYPE;
      return _this;
    }
    _createClass(Circle, [{
      key: "isValid",
      value: function isValid() {
        return _get(_getPrototypeOf(Circle.prototype), "isValid", this).call(this) && this._isValid();
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        var _this$attribute = this.attribute,
          startAngle = _this$attribute.startAngle,
          endAngle = _this$attribute.endAngle,
          radius = _this$attribute.radius;
        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds(full) {
        var circleTheme = getTheme(this).circle;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateCircleAABBBounds(attribute, getTheme(this).circle, this._AABBBounds, full, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? circleTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this).circle[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(Circle.prototype), "needUpdateTags", this).call(this, keys, CIRCLE_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(Circle.prototype), "needUpdateTag", this).call(this, key, CIRCLE_UPDATE_TAG_KEY);
      }
    }, {
      key: "toCustomPath",
      value: function toCustomPath() {
        var _a, _b, _c;
        var attribute = this.attribute,
          radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"),
          startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"),
          endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle"),
          path = new CustomPath2D();
        return path.arc(0, 0, radius, startAngle, endAngle), path;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Circle(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Circle.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Circle;
  }(Graphic);
  Circle.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
  function createCircle(attributes) {
    return new Circle(attributes);
  }

  function getContextFont(text) {
    var defaultAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var fontSizeScale = arguments.length > 2 ? arguments[2] : undefined;
    fontSizeScale || (fontSizeScale = 1);
    var _text$fontStyle = text.fontStyle,
      fontStyle = _text$fontStyle === void 0 ? defaultAttr.fontStyle : _text$fontStyle,
      _text$fontVariant = text.fontVariant,
      fontVariant = _text$fontVariant === void 0 ? defaultAttr.fontVariant : _text$fontVariant,
      _text$fontWeight = text.fontWeight,
      fontWeight = _text$fontWeight === void 0 ? defaultAttr.fontWeight : _text$fontWeight,
      _text$fontSize = text.fontSize,
      fontSize = _text$fontSize === void 0 ? defaultAttr.fontSize : _text$fontSize,
      _text$fontFamily = text.fontFamily,
      fontFamily = _text$fontFamily === void 0 ? defaultAttr.fontFamily : _text$fontFamily;
    return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
  }
  function textDrawOffsetY(baseline, h) {
    return "top" === baseline ? Math.ceil(.79 * h) : "middle" === baseline ? Math.round(.3 * h) : "bottom" === baseline ? Math.round(-.21 * h) : 0;
  }
  function textDrawOffsetX(textAlign, width) {
    return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
  }
  function textLayoutOffsetY(baseline, lineHeight, fontSize) {
    var buf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? buf - lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), -(lineHeight - fontSize) / 2 - .79 * fontSize);
  }

  var CanvasTextLayout = /*#__PURE__*/function () {
    function CanvasTextLayout(fontFamily, options, textMeasure) {
      _classCallCheck(this, CanvasTextLayout);
      this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
    }
    _createClass(CanvasTextLayout, [{
      key: "LayoutBBox",
      value: function LayoutBBox(bbox, textAlign, textBaseline) {
        if ("left" === textAlign || "start" === textAlign) bbox.xOffset = 0;else if ("center" === textAlign) bbox.xOffset = bbox.width / -2;else {
          if ("right" !== textAlign && "end" !== textAlign) throw new Error("非法的textAlign");
          bbox.xOffset = -bbox.width;
        }
        return bbox.yOffset = "top" === textBaseline ? 0 : "middle" === textBaseline ? bbox.height / -2 : "alphabetic" === textBaseline ? -.79 * bbox.height : -bbox.height, bbox;
      }
    }, {
      key: "GetLayout",
      value: function GetLayout(str, width, height, textAlign, textBaseline, lineHeight, suffix, wordBreak, suffixPosition) {
        var linesLayout = [],
          bboxWH = [width, height],
          bboxOffset = [0, 0];
        for (; str.length > 0;) {
          var _this$textMeasure$cli = this.textMeasure.clipTextWithSuffix(str, this.textOptions, width, suffix, wordBreak, suffixPosition),
            clipText = _this$textMeasure$cli.str;
          linesLayout.push({
            str: clipText,
            width: this.textMeasure.measureTextWidth(clipText, this.textOptions)
          }), str = str.substring(clipText.length);
        }
        "left" === textAlign || "start" === textAlign || ("center" === textAlign ? bboxOffset[0] = bboxWH[0] / -2 : "right" !== textAlign && "end" !== textAlign || (bboxOffset[0] = -bboxWH[0])), "top" === textBaseline || ("middle" === textBaseline ? bboxOffset[1] = bboxWH[1] / -2 : "bottom" === textBaseline && (bboxOffset[1] = -bboxWH[1]));
        var bbox = {
          xOffset: bboxOffset[0],
          yOffset: bboxOffset[1],
          width: bboxWH[0],
          height: bboxWH[1]
        };
        return this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
      }
    }, {
      key: "GetLayoutByLines",
      value: function GetLayoutByLines(lines, textAlign, textBaseline, lineHeight) {
        var suffix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
        var wordBreak = arguments.length > 5 ? arguments[5] : undefined;
        var lineWidth = arguments.length > 6 ? arguments[6] : undefined;
        var suffixPosition = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : "end";
        lines = lines.map(function (l) {
          return l.toString();
        });
        var linesLayout = [],
          bboxWH = [0, 0];
        if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
          var width;
          for (var i = 0, len = lines.length; i < len; i++) width = Math.min(this.textMeasure.measureTextWidth(lines[i], this.textOptions), lineWidth), linesLayout.push({
            str: this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, width, suffix, wordBreak, suffixPosition).str,
            width: width
          });
          bboxWH[0] = lineWidth;
        } else {
          var _width, text;
          lineWidth = 0;
          for (var _i = 0, _len = lines.length; _i < _len; _i++) text = lines[_i], _width = this.textMeasure.measureTextWidth(text, this.textOptions), lineWidth = Math.max(lineWidth, _width), linesLayout.push({
            str: text,
            width: _width
          });
          bboxWH[0] = lineWidth;
        }
        bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce(function (a, b) {
          return Math.max(a, b.width);
        }, 0);
        var bbox = {
          xOffset: 0,
          yOffset: 0,
          width: bboxWH[0],
          height: bboxWH[1]
        };
        return this.LayoutBBox(bbox, textAlign, textBaseline), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
      }
    }, {
      key: "layoutWithBBox",
      value: function layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
        var origin = [0, 0],
          totalLineHeight = lines.length * lineHeight;
        "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
        for (var i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
        return {
          bbox: bbox,
          lines: lines,
          fontFamily: this.fontFamily,
          fontSize: this.textOptions.fontSize,
          fontWeight: this.textOptions.fontWeight,
          lineHeight: lineHeight,
          textAlign: textAlign,
          textBaseline: textBaseline
        };
      }
    }, {
      key: "lineOffset",
      value: function lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
        return "left" === textAlign || "start" === textAlign ? line.leftOffset = 0 : "center" === textAlign ? line.leftOffset = (bbox.width - line.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line.leftOffset = bbox.width - line.width), line.topOffset = (lineHeight - this.textOptions.fontSize) / 2 + .79 * this.textOptions.fontSize + origin[1], origin[1] += lineHeight, line;
      }
    }]);
    return CanvasTextLayout;
  }();

  var TEXT_UPDATE_TAG_KEY = ["text", "maxLineWidth", "textAlign", "textBaseline", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var Text = /*#__PURE__*/function (_Graphic) {
    _inherits(Text, _Graphic);
    var _super = _createSuper(Text);
    function Text() {
      var _this;
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        text: "",
        fontSize: 16
      };
      _classCallCheck(this, Text);
      _this = _super.call(this, params), _this.type = "text", _this.numberType = TEXT_NUMBER_TYPE, _this.cache = {};
      return _this;
    }
    _createClass(Text, [{
      key: "font",
      get: function get() {
        var textTheme = getTheme(this).text;
        return this._font || (this._font = getContextFont(this.attribute, textTheme)), this._font;
      }
    }, {
      key: "clipedText",
      get: function get() {
        var _a;
        var attribute = this.attribute,
          textTheme = getTheme(this).text;
        if (!this.isSimplify()) return;
        var _attribute$maxLineWid = attribute.maxLineWidth,
          maxLineWidth = _attribute$maxLineWid === void 0 ? textTheme.maxLineWidth : _attribute$maxLineWid;
        return Number.isFinite(maxLineWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
      }
    }, {
      key: "clipedWidth",
      get: function get() {
        if (this.isSimplify()) return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
      }
    }, {
      key: "cliped",
      get: function get() {
        var textTheme = getTheme(this).text,
          attribute = this.attribute;
        if (this.isMultiLine) return;
        var _attribute$maxLineWid2 = attribute.maxLineWidth,
          maxLineWidth = _attribute$maxLineWid2 === void 0 ? textTheme.maxLineWidth : _attribute$maxLineWid2;
        return !!Number.isFinite(maxLineWidth) && (this.tryUpdateAABBBounds(), "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map(function (item) {
          return item.text;
        }).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString());
      }
    }, {
      key: "multilineLayout",
      get: function get() {
        if (this.isMultiLine) return this.tryUpdateAABBBounds(), this.cache.layoutData;
      }
    }, {
      key: "isSimplify",
      value: function isSimplify() {
        return !this.isMultiLine && "vertical" !== this.attribute.direction;
      }
    }, {
      key: "isMultiLine",
      get: function get() {
        return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return _get(_getPrototypeOf(Text.prototype), "isValid", this).call(this) && this._isValid();
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        var text = this.attribute.text;
        return isArray$1(text) ? !text.every(function (t) {
          return null == t || "" === t;
        }) : null != text && "" !== text;
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var textTheme = getTheme(this).text;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateTextAABBBounds(attribute, textTheme, this._AABBBounds, this),
          _this$attribute$bound = this.attribute.boundsPadding,
          boundsPadding = _this$attribute$bound === void 0 ? textTheme.boundsPadding : _this$attribute$bound,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "updateWrapAABBBounds",
      value: function updateWrapAABBBounds(text) {
        var _a, _b, _c, _d;
        var textTheme = getTheme(this).text,
          _this$attribute = this.attribute,
          _this$attribute$fontF = _this$attribute.fontFamily,
          fontFamily = _this$attribute$fontF === void 0 ? textTheme.fontFamily : _this$attribute$fontF,
          _this$attribute$textA = _this$attribute.textAlign,
          textAlign = _this$attribute$textA === void 0 ? textTheme.textAlign : _this$attribute$textA,
          _this$attribute$textB = _this$attribute.textBaseline,
          textBaseline = _this$attribute$textB === void 0 ? textTheme.textBaseline : _this$attribute$textB,
          _this$attribute$fontS = _this$attribute.fontSize,
          fontSize = _this$attribute$fontS === void 0 ? textTheme.fontSize : _this$attribute$fontS,
          _this$attribute$ellip = _this$attribute.ellipsis,
          ellipsis = _this$attribute$ellip === void 0 ? textTheme.ellipsis : _this$attribute$ellip,
          maxLineWidth = _this$attribute.maxLineWidth,
          _this$attribute$strok = _this$attribute.stroke,
          stroke = _this$attribute$strok === void 0 ? textTheme.stroke : _this$attribute$strok,
          _this$attribute$lineW = _this$attribute.lineWidth,
          lineWidth = _this$attribute$lineW === void 0 ? textTheme.lineWidth : _this$attribute$lineW,
          _this$attribute$wordB = _this$attribute.wordBreak,
          wordBreak = _this$attribute$wordB === void 0 ? textTheme.wordBreak : _this$attribute$wordB,
          _this$attribute$fontW = _this$attribute.fontWeight,
          fontWeight = _this$attribute$fontW === void 0 ? textTheme.fontWeight : _this$attribute$fontW,
          _this$attribute$ignor = _this$attribute.ignoreBuf,
          ignoreBuf = _this$attribute$ignor === void 0 ? textTheme.ignoreBuf : _this$attribute$ignor,
          _this$attribute$suffi = _this$attribute.suffixPosition,
          suffixPosition = _this$attribute$suffi === void 0 ? textTheme.suffixPosition : _this$attribute$suffi,
          _this$attribute$heigh = _this$attribute.heightLimit,
          heightLimit = _this$attribute$heigh === void 0 ? 0 : _this$attribute$heigh,
          lineClamp = _this$attribute.lineClamp,
          lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize,
          buf = ignoreBuf ? 0 : 2;
        if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
          var _bbox = this.cache.layoutData.bbox;
          return this._AABBBounds.set(_bbox.xOffset, _bbox.yOffset, _bbox.xOffset + _bbox.width, _bbox.yOffset + _bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        var textMeasure = application.graphicUtil.textMeasure,
          layoutObj = new CanvasTextLayout(fontFamily, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
          }, textMeasure),
          lines = isArray$1(text) ? text.map(function (l) {
            return l.toString();
          }) : [text.toString()],
          linesLayout = [],
          bboxWH = [0, 0];
        var lineCountLimit = 1 / 0;
        if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
          if (maxLineWidth > 0) for (var i = 0; i < lines.length; i++) {
            var str = lines[i];
            var needCut = !0;
            if (i === lineCountLimit - 1) {
              var _clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
              linesLayout.push({
                str: _clip.str,
                width: _clip.width
              });
              break;
            }
            var clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
            if ("" !== str && "" === clip.str) {
              if (ellipsis) {
                var clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
                clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
              } else clip.str = "", clip.width = 0;
              needCut = !1;
            }
            if (linesLayout.push({
              str: clip.str,
              width: clip.width
            }), clip.str.length === str.length) ;else if (needCut) {
              var newStr = str.substring(clip.str.length);
              lines.splice(i + 1, 0, newStr);
            }
          }
          var maxWidth = 0;
          linesLayout.forEach(function (layout) {
            maxWidth = Math.max(maxWidth, layout.width);
          }), bboxWH[0] = maxWidth;
        } else {
          var width,
            _text,
            _lineWidth = 0;
          for (var _i = 0, len = lines.length; _i < len; _i++) {
            if (_i === lineCountLimit - 1) {
              var _clip2 = layoutObj.textMeasure.clipTextWithSuffix(lines[_i], layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
              linesLayout.push({
                str: _clip2.str,
                width: _clip2.width
              }), _lineWidth = Math.max(_lineWidth, _clip2.width);
              break;
            }
            _text = lines[_i], width = layoutObj.textMeasure.measureTextWidth(_text, layoutObj.textOptions, "break-word" === wordBreak), _lineWidth = Math.max(_lineWidth, width), linesLayout.push({
              str: _text,
              width: width
            });
          }
          bboxWH[0] = _lineWidth;
        }
        bboxWH[1] = linesLayout.length * (lineHeight + buf);
        var bbox = {
          xOffset: 0,
          yOffset: 0,
          width: bboxWH[0],
          height: bboxWH[1]
        };
        layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
        var layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
    }, {
      key: "updateSingallineAABBBounds",
      value: function updateSingallineAABBBounds(text) {
        var textTheme = getTheme(this).text,
          _this$attribute2 = this.attribute,
          _this$attribute2$dire = _this$attribute2.direction,
          direction = _this$attribute2$dire === void 0 ? textTheme.direction : _this$attribute2$dire,
          _this$attribute2$unde = _this$attribute2.underlineOffset,
          underlineOffset = _this$attribute2$unde === void 0 ? textTheme.underlineOffset : _this$attribute2$unde,
          b = "horizontal" === direction ? this.updateHorizontalSinglelineAABBBounds(text) : this.updateVerticalSinglelineAABBBounds(text);
        return "horizontal" === direction && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
      }
    }, {
      key: "updateMultilineAABBBounds",
      value: function updateMultilineAABBBounds(text) {
        var textTheme = getTheme(this).text,
          _this$attribute3 = this.attribute,
          _this$attribute3$dire = _this$attribute3.direction,
          direction = _this$attribute3$dire === void 0 ? textTheme.direction : _this$attribute3$dire,
          _this$attribute3$unde = _this$attribute3.underlineOffset,
          underlineOffset = _this$attribute3$unde === void 0 ? textTheme.underlineOffset : _this$attribute3$unde,
          b = "horizontal" === direction ? this.updateHorizontalMultilineAABBBounds(text) : this.updateVerticalMultilineAABBBounds(text);
        return "horizontal" === direction && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
      }
    }, {
      key: "updateHorizontalSinglelineAABBBounds",
      value: function updateHorizontalSinglelineAABBBounds(text) {
        var _a, _b;
        var textTheme = getTheme(this).text,
          _this$attribute$wrap = this.attribute.wrap,
          wrap = _this$attribute$wrap === void 0 ? textTheme.wrap : _this$attribute$wrap;
        if (wrap) return this.updateWrapAABBBounds([text]);
        var textMeasure = application.graphicUtil.textMeasure;
        var width, str;
        var attribute = this.attribute,
          _attribute$maxLineWid3 = attribute.maxLineWidth,
          maxLineWidth = _attribute$maxLineWid3 === void 0 ? textTheme.maxLineWidth : _attribute$maxLineWid3,
          _attribute$ellipsis = attribute.ellipsis,
          ellipsis = _attribute$ellipsis === void 0 ? textTheme.ellipsis : _attribute$ellipsis,
          _attribute$textAlign = attribute.textAlign,
          textAlign = _attribute$textAlign === void 0 ? textTheme.textAlign : _attribute$textAlign,
          _attribute$textBaseli = attribute.textBaseline,
          textBaseline = _attribute$textBaseli === void 0 ? textTheme.textBaseline : _attribute$textBaseli,
          _attribute$fontFamily = attribute.fontFamily,
          fontFamily = _attribute$fontFamily === void 0 ? textTheme.fontFamily : _attribute$fontFamily,
          _attribute$fontSize = attribute.fontSize,
          fontSize = _attribute$fontSize === void 0 ? textTheme.fontSize : _attribute$fontSize,
          _attribute$fontWeight = attribute.fontWeight,
          fontWeight = _attribute$fontWeight === void 0 ? textTheme.fontWeight : _attribute$fontWeight,
          _attribute$stroke = attribute.stroke,
          stroke = _attribute$stroke === void 0 ? textTheme.stroke : _attribute$stroke,
          _attribute$lineWidth = attribute.lineWidth,
          lineWidth = _attribute$lineWidth === void 0 ? textTheme.lineWidth : _attribute$lineWidth,
          _attribute$ignoreBuf = attribute.ignoreBuf,
          ignoreBuf = _attribute$ignoreBuf === void 0 ? textTheme.ignoreBuf : _attribute$ignoreBuf,
          _attribute$whiteSpace = attribute.whiteSpace,
          whiteSpace = _attribute$whiteSpace === void 0 ? textTheme.whiteSpace : _attribute$whiteSpace,
          _attribute$suffixPosi = attribute.suffixPosition,
          suffixPosition = _attribute$suffixPosi === void 0 ? textTheme.suffixPosition : _attribute$suffixPosi;
        if ("normal" === whiteSpace) return this.updateWrapAABBBounds(text);
        var buf = ignoreBuf ? 0 : Math.max(2, .075 * fontSize),
          textFontSize = attribute.fontSize || textTheme.fontSize,
          lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, textFontSize)) && void 0 !== _a ? _a : textFontSize + buf;
        if (!this.shouldUpdateShape() && this.cache) {
          width = null !== (_b = this.cache.clipedWidth) && void 0 !== _b ? _b : 0;
          var _dx = textDrawOffsetX(textAlign, width),
            _dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
          return this._AABBBounds.set(_dx, _dy, _dx + width, _dy + lineHeight), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        if (Number.isFinite(maxLineWidth)) {
          if (ellipsis) {
            var strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis,
              data = textMeasure.clipTextWithSuffix(text.toString(), {
                fontSize: fontSize,
                fontWeight: fontWeight,
                fontFamily: fontFamily
              }, maxLineWidth, strEllipsis, !1, suffixPosition);
            str = data.str, width = data.width;
          } else {
            var _data = textMeasure.clipText(text.toString(), {
              fontSize: fontSize,
              fontWeight: fontWeight,
              fontFamily: fontFamily
            }, maxLineWidth, !1);
            str = _data.str, width = _data.width;
          }
          this.cache.clipedText = str, this.cache.clipedWidth = width;
        } else width = textMeasure.measureTextWidth(text.toString(), {
          fontSize: fontSize,
          fontWeight: fontWeight,
          fontFamily: fontFamily
        }), this.cache.clipedText = text.toString(), this.cache.clipedWidth = width;
        this.clearUpdateShapeTag();
        var dx = textDrawOffsetX(textAlign, width);
        var lh = lineHeight;
        application.global && application.global.isSafari() && (lh += .2 * fontSize);
        var dy = textLayoutOffsetY(textBaseline, lh, fontSize, buf);
        return this._AABBBounds.set(dx, dy, dx + width, dy + lh), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
    }, {
      key: "getBaselineMapAlign",
      value: function getBaselineMapAlign() {
        return Text.baselineMapAlign;
      }
    }, {
      key: "getAlignMapBaseline",
      value: function getAlignMapBaseline() {
        return Text.alignMapBaseline;
      }
    }, {
      key: "updateVerticalSinglelineAABBBounds",
      value: function updateVerticalSinglelineAABBBounds(text) {
        var _a, _b, _c;
        var textTheme = getTheme(this).text,
          textMeasure = application.graphicUtil.textMeasure;
        var width;
        var attribute = this.attribute,
          _attribute$ignoreBuf2 = attribute.ignoreBuf,
          ignoreBuf = _attribute$ignoreBuf2 === void 0 ? textTheme.ignoreBuf : _attribute$ignoreBuf2,
          buf = ignoreBuf ? 0 : 2,
          _attribute$maxLineWid4 = attribute.maxLineWidth,
          maxLineWidth = _attribute$maxLineWid4 === void 0 ? textTheme.maxLineWidth : _attribute$maxLineWid4,
          _attribute$ellipsis2 = attribute.ellipsis,
          ellipsis = _attribute$ellipsis2 === void 0 ? textTheme.ellipsis : _attribute$ellipsis2,
          _attribute$fontSize2 = attribute.fontSize,
          fontSize = _attribute$fontSize2 === void 0 ? textTheme.fontSize : _attribute$fontSize2,
          _attribute$fontWeight2 = attribute.fontWeight,
          fontWeight = _attribute$fontWeight2 === void 0 ? textTheme.fontWeight : _attribute$fontWeight2,
          _attribute$fontFamily2 = attribute.fontFamily,
          fontFamily = _attribute$fontFamily2 === void 0 ? textTheme.fontFamily : _attribute$fontFamily2,
          _attribute$stroke2 = attribute.stroke,
          stroke = _attribute$stroke2 === void 0 ? textTheme.stroke : _attribute$stroke2,
          _attribute$lineWidth2 = attribute.lineWidth,
          lineWidth = _attribute$lineWidth2 === void 0 ? textTheme.lineWidth : _attribute$lineWidth2,
          _attribute$verticalMo = attribute.verticalMode,
          verticalMode = _attribute$verticalMo === void 0 ? textTheme.verticalMode : _attribute$verticalMo,
          _attribute$suffixPosi2 = attribute.suffixPosition,
          suffixPosition = _attribute$suffixPosi2 === void 0 ? textTheme.suffixPosition : _attribute$suffixPosi2,
          lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
        var _attribute$textAlign2 = attribute.textAlign,
          textAlign = _attribute$textAlign2 === void 0 ? textTheme.textAlign : _attribute$textAlign2,
          _attribute$textBaseli2 = attribute.textBaseline,
          textBaseline = _attribute$textBaseli2 === void 0 ? textTheme.textBaseline : _attribute$textBaseli2;
        if (!verticalMode) {
          var t = textAlign;
          textAlign = null !== (_b = Text.baselineMapAlign[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = Text.alignMapBaseline[t]) && void 0 !== _c ? _c : "top";
        }
        if (!this.shouldUpdateShape() && this.cache) {
          width = this.cache.clipedWidth;
          var _dx2 = textDrawOffsetX(textAlign, width),
            _dy2 = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
          return this._AABBBounds.set(_dy2, _dx2, _dy2 + lineHeight, _dx2 + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        var verticalList = [verticalLayout(text.toString())];
        if (Number.isFinite(maxLineWidth)) {
          if (ellipsis) {
            var strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis,
              data = textMeasure.clipTextWithSuffixVertical(verticalList[0], {
                fontSize: fontSize,
                fontWeight: fontWeight,
                fontFamily: fontFamily
              }, maxLineWidth, strEllipsis, !1, suffixPosition);
            verticalList = [data.verticalList], width = data.width;
          } else {
            var _data2 = textMeasure.clipTextVertical(verticalList[0], {
              fontSize: fontSize,
              fontWeight: fontWeight,
              fontFamily: fontFamily
            }, maxLineWidth, !1);
            verticalList = [_data2.verticalList], width = _data2.width;
          }
          this.cache.verticalList = verticalList, this.cache.clipedWidth = width;
        } else width = 0, verticalList[0].forEach(function (t) {
          var w = t.direction === exports.TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
          });
          width += w, t.width = w;
        }), this.cache.verticalList = verticalList, this.cache.clipedWidth = width;
        this.clearUpdateShapeTag();
        var dx = textDrawOffsetX(textAlign, width),
          dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
        return this._AABBBounds.set(dy, dx, dy + lineHeight, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
    }, {
      key: "updateHorizontalMultilineAABBBounds",
      value: function updateHorizontalMultilineAABBBounds(text) {
        var _a, _b;
        var textTheme = getTheme(this).text,
          _this$attribute$wrap2 = this.attribute.wrap,
          wrap = _this$attribute$wrap2 === void 0 ? textTheme.wrap : _this$attribute$wrap2;
        if (wrap) return this.updateWrapAABBBounds(text);
        var attribute = this.attribute,
          _attribute$fontFamily3 = attribute.fontFamily,
          fontFamily = _attribute$fontFamily3 === void 0 ? textTheme.fontFamily : _attribute$fontFamily3,
          _attribute$textAlign3 = attribute.textAlign,
          textAlign = _attribute$textAlign3 === void 0 ? textTheme.textAlign : _attribute$textAlign3,
          _attribute$textBaseli3 = attribute.textBaseline,
          textBaseline = _attribute$textBaseli3 === void 0 ? textTheme.textBaseline : _attribute$textBaseli3,
          _attribute$fontSize3 = attribute.fontSize,
          fontSize = _attribute$fontSize3 === void 0 ? textTheme.fontSize : _attribute$fontSize3,
          _attribute$fontWeight3 = attribute.fontWeight,
          fontWeight = _attribute$fontWeight3 === void 0 ? textTheme.fontWeight : _attribute$fontWeight3,
          _attribute$ellipsis3 = attribute.ellipsis,
          ellipsis = _attribute$ellipsis3 === void 0 ? textTheme.ellipsis : _attribute$ellipsis3,
          maxLineWidth = attribute.maxLineWidth,
          _attribute$stroke3 = attribute.stroke,
          stroke = _attribute$stroke3 === void 0 ? textTheme.stroke : _attribute$stroke3,
          _attribute$lineWidth3 = attribute.lineWidth,
          lineWidth = _attribute$lineWidth3 === void 0 ? textTheme.lineWidth : _attribute$lineWidth3,
          _attribute$whiteSpace2 = attribute.whiteSpace,
          whiteSpace = _attribute$whiteSpace2 === void 0 ? textTheme.whiteSpace : _attribute$whiteSpace2,
          _attribute$suffixPosi3 = attribute.suffixPosition,
          suffixPosition = _attribute$suffixPosi3 === void 0 ? textTheme.suffixPosition : _attribute$suffixPosi3,
          lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : attribute.fontSize || textTheme.fontSize;
        if ("normal" === whiteSpace) return this.updateWrapAABBBounds(text);
        if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
          var _bbox2 = this.cache.layoutData.bbox;
          return this._AABBBounds.set(_bbox2.xOffset, _bbox2.yOffset, _bbox2.xOffset + _bbox2.width, _bbox2.yOffset + _bbox2.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        var textMeasure = application.graphicUtil.textMeasure,
          layoutData = new CanvasTextLayout(fontFamily, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
          }, textMeasure).GetLayoutByLines(text, textAlign, textBaseline, lineHeight, !0 === ellipsis ? textTheme.ellipsis : ellipsis || void 0, !1, maxLineWidth, suffixPosition),
          bbox = layoutData.bbox;
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
    }, {
      key: "updateVerticalMultilineAABBBounds",
      value: function updateVerticalMultilineAABBBounds(text) {
        var _a, _b, _c;
        var textTheme = getTheme(this).text,
          textMeasure = application.graphicUtil.textMeasure;
        var width;
        var attribute = this.attribute,
          _attribute$ignoreBuf3 = attribute.ignoreBuf,
          ignoreBuf = _attribute$ignoreBuf3 === void 0 ? textTheme.ignoreBuf : _attribute$ignoreBuf3,
          buf = ignoreBuf ? 0 : 2,
          _attribute$maxLineWid5 = attribute.maxLineWidth,
          maxLineWidth = _attribute$maxLineWid5 === void 0 ? textTheme.maxLineWidth : _attribute$maxLineWid5,
          _attribute$ellipsis4 = attribute.ellipsis,
          ellipsis = _attribute$ellipsis4 === void 0 ? textTheme.ellipsis : _attribute$ellipsis4,
          _attribute$fontFamily4 = attribute.fontFamily,
          fontFamily = _attribute$fontFamily4 === void 0 ? textTheme.fontFamily : _attribute$fontFamily4,
          _attribute$fontSize4 = attribute.fontSize,
          fontSize = _attribute$fontSize4 === void 0 ? textTheme.fontSize : _attribute$fontSize4,
          _attribute$fontWeight4 = attribute.fontWeight,
          fontWeight = _attribute$fontWeight4 === void 0 ? textTheme.fontWeight : _attribute$fontWeight4,
          _attribute$stroke4 = attribute.stroke,
          stroke = _attribute$stroke4 === void 0 ? textTheme.stroke : _attribute$stroke4,
          _attribute$lineWidth4 = attribute.lineWidth,
          lineWidth = _attribute$lineWidth4 === void 0 ? textTheme.lineWidth : _attribute$lineWidth4,
          _attribute$verticalMo2 = attribute.verticalMode,
          verticalMode = _attribute$verticalMo2 === void 0 ? textTheme.verticalMode : _attribute$verticalMo2,
          _attribute$suffixPosi4 = attribute.suffixPosition,
          suffixPosition = _attribute$suffixPosi4 === void 0 ? textTheme.suffixPosition : _attribute$suffixPosi4,
          lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
        var _attribute$textAlign4 = attribute.textAlign,
          textAlign = _attribute$textAlign4 === void 0 ? textTheme.textAlign : _attribute$textAlign4,
          _attribute$textBaseli4 = attribute.textBaseline,
          textBaseline = _attribute$textBaseli4 === void 0 ? textTheme.textBaseline : _attribute$textBaseli4;
        if (!verticalMode) {
          var t = textAlign;
          textAlign = null !== (_b = Text.baselineMapAlign[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = Text.alignMapBaseline[t]) && void 0 !== _c ? _c : "top";
        }
        if (width = 0, !this.shouldUpdateShape() && this.cache) {
          this.cache.verticalList.forEach(function (item) {
            var w = item.reduce(function (a, b) {
              return a + b.width;
            }, 0);
            width = max(w, width);
          });
          var _dx3 = textDrawOffsetX(textAlign, width),
            _height = this.cache.verticalList.length * lineHeight,
            _dy3 = textLayoutOffsetY(textBaseline, _height, fontSize);
          return this._AABBBounds.set(_dy3, _dx3, _dy3 + _height, _dx3 + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        var verticalLists = text.map(function (str) {
          return verticalLayout(str.toString());
        });
        verticalLists.forEach(function (verticalData, i) {
          if (Number.isFinite(maxLineWidth)) {
            if (ellipsis) {
              var strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis,
                data = textMeasure.clipTextWithSuffixVertical(verticalData, {
                  fontSize: fontSize,
                  fontWeight: fontWeight,
                  fontFamily: fontFamily
                }, maxLineWidth, strEllipsis, !1, suffixPosition);
              verticalLists[i] = data.verticalList, width = data.width;
            } else {
              var _data3 = textMeasure.clipTextVertical(verticalData, {
                fontSize: fontSize,
                fontWeight: fontWeight,
                fontFamily: fontFamily
              }, maxLineWidth, !1);
              verticalLists[i] = _data3.verticalList, width = _data3.width;
            }
          } else width = 0, verticalData.forEach(function (t) {
            var w = t.direction === exports.TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
              fontSize: fontSize,
              fontWeight: fontWeight,
              fontFamily: fontFamily
            });
            width += w, t.width = w;
          });
        }), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach(function (item) {
          var w = item.reduce(function (a, b) {
            return a + b.width;
          }, 0);
          width = max(w, width);
        });
        var dx = textDrawOffsetX(textAlign, width),
          height = this.cache.verticalList.length * lineHeight,
          dy = textLayoutOffsetY(textBaseline, height, fontSize);
        return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this).text[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TEXT_UPDATE_TAG_KEY;
        return _get(_getPrototypeOf(Text.prototype), "needUpdateTags", this).call(this, keys, k);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        var k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TEXT_UPDATE_TAG_KEY;
        return _get(_getPrototypeOf(Text.prototype), "needUpdateTag", this).call(this, key, k);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Text(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Text.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Text;
  }(Graphic);
  Text.NOWORK_ANIMATE_ATTR = Object.assign({
    ellipsis: 1,
    wordBreak: 1,
    direction: 1,
    textAlign: 1,
    textBaseline: 1,
    fontFamily: 1,
    fontWeight: 1
  }, NOWORK_ANIMATE_ATTR), Text.baselineMapAlign = {
    top: "left",
    bottom: "right",
    middle: "center"
  }, Text.alignMapBaseline = {
    left: "top",
    right: "bottom",
    center: "middle"
  };
  function createText(attributes) {
    return new Text(attributes);
  }

  var WRAP_TEXT_UPDATE_TAG_KEY = ["heightLimit", "lineClamp"];
  var WrapText = /*#__PURE__*/function (_Text) {
    _inherits(WrapText, _Text);
    var _super = _createSuper(WrapText);
    function WrapText(params) {
      _classCallCheck(this, WrapText);
      return _super.call(this, Object.assign(Object.assign({}, params), {
        wrap: !0
      }));
    }
    _createClass(WrapText, [{
      key: "_isValid",
      value: function _isValid() {
        var text = this.attribute.text;
        return isArray$1(text) ? !text.every(function (t) {
          return null == t || "" === t;
        }) : null != text && "" !== text;
      }
    }, {
      key: "updateMultilineAABBBounds",
      value: function updateMultilineAABBBounds(text) {
        var _a, _b, _c, _d;
        var textTheme = getTheme(this).text,
          _this$attribute = this.attribute,
          _this$attribute$fontF = _this$attribute.fontFamily,
          fontFamily = _this$attribute$fontF === void 0 ? textTheme.fontFamily : _this$attribute$fontF,
          _this$attribute$textA = _this$attribute.textAlign,
          textAlign = _this$attribute$textA === void 0 ? textTheme.textAlign : _this$attribute$textA,
          _this$attribute$textB = _this$attribute.textBaseline,
          textBaseline = _this$attribute$textB === void 0 ? textTheme.textBaseline : _this$attribute$textB,
          _this$attribute$fontS = _this$attribute.fontSize,
          fontSize = _this$attribute$fontS === void 0 ? textTheme.fontSize : _this$attribute$fontS,
          _this$attribute$ellip = _this$attribute.ellipsis,
          ellipsis = _this$attribute$ellip === void 0 ? textTheme.ellipsis : _this$attribute$ellip,
          maxLineWidth = _this$attribute.maxLineWidth,
          _this$attribute$strok = _this$attribute.stroke,
          stroke = _this$attribute$strok === void 0 ? textTheme.stroke : _this$attribute$strok,
          _this$attribute$lineW = _this$attribute.lineWidth,
          lineWidth = _this$attribute$lineW === void 0 ? textTheme.lineWidth : _this$attribute$lineW,
          _this$attribute$wordB = _this$attribute.wordBreak,
          wordBreak = _this$attribute$wordB === void 0 ? textTheme.wordBreak : _this$attribute$wordB,
          _this$attribute$fontW = _this$attribute.fontWeight,
          fontWeight = _this$attribute$fontW === void 0 ? textTheme.fontWeight : _this$attribute$fontW,
          _this$attribute$ignor = _this$attribute.ignoreBuf,
          ignoreBuf = _this$attribute$ignor === void 0 ? textTheme.ignoreBuf : _this$attribute$ignor,
          _this$attribute$heigh = _this$attribute.heightLimit,
          heightLimit = _this$attribute$heigh === void 0 ? 0 : _this$attribute$heigh,
          _this$attribute$suffi = _this$attribute.suffixPosition,
          suffixPosition = _this$attribute$suffi === void 0 ? textTheme.suffixPosition : _this$attribute$suffi,
          lineClamp = _this$attribute.lineClamp,
          lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize,
          buf = ignoreBuf ? 0 : 2;
        if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
          var _bbox = this.cache.layoutData.bbox;
          return this._AABBBounds.set(_bbox.xOffset, _bbox.yOffset, _bbox.xOffset + _bbox.width, _bbox.yOffset + _bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
        }
        var textMeasure = application.graphicUtil.textMeasure,
          layoutObj = new CanvasTextLayout(fontFamily, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
          }, textMeasure),
          lines = text.map(function (l) {
            return l.toString();
          }),
          linesLayout = [],
          bboxWH = [0, 0];
        var lineCountLimit = 1 / 0;
        if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
          if (maxLineWidth > 0) for (var i = 0; i < lines.length; i++) {
            var str = lines[i];
            var needCut = !0;
            if (i === lineCountLimit - 1) {
              var _clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
              linesLayout.push({
                str: _clip.str,
                width: _clip.width
              });
              break;
            }
            var clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
            if ("" !== str && "" === clip.str) {
              if (ellipsis) {
                var clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
                clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
              } else clip.str = "", clip.width = 0;
              needCut = !1;
            }
            if (linesLayout.push({
              str: clip.str,
              width: clip.width
            }), clip.str.length === str.length) ;else if (needCut) {
              var newStr = str.substring(clip.str.length);
              lines.splice(i + 1, 0, newStr);
            }
          }
          var maxWidth = 0;
          linesLayout.forEach(function (layout) {
            maxWidth = Math.max(maxWidth, layout.width);
          }), bboxWH[0] = maxWidth;
        } else {
          var width,
            _text,
            _lineWidth = 0;
          for (var _i = 0, len = lines.length; _i < len; _i++) {
            if (_i === lineCountLimit - 1) {
              var _clip2 = layoutObj.textMeasure.clipTextWithSuffix(lines[_i], layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
              linesLayout.push({
                str: _clip2.str,
                width: _clip2.width
              }), _lineWidth = Math.max(_lineWidth, _clip2.width);
              break;
            }
            _text = lines[_i], width = layoutObj.textMeasure.measureTextWidth(_text, layoutObj.textOptions, "break-word" === wordBreak), _lineWidth = Math.max(_lineWidth, width), linesLayout.push({
              str: _text,
              width: width
            });
          }
          bboxWH[0] = _lineWidth;
        }
        bboxWH[1] = linesLayout.length * (lineHeight + buf);
        var bbox = {
          xOffset: 0,
          yOffset: 0,
          width: bboxWH[0],
          height: bboxWH[1]
        };
        layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
        var layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
        return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        for (var i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
          var attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
          if (-1 !== keys.indexOf(attrKey)) return !0;
        }
        return _get(_getPrototypeOf(WrapText.prototype), "needUpdateTags", this).call(this, keys);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        for (var i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
          if (key === WRAP_TEXT_UPDATE_TAG_KEY[i]) return !0;
        }
        return _get(_getPrototypeOf(WrapText.prototype), "needUpdateTag", this).call(this, key);
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return WrapText.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return WrapText;
  }(Text);
  function createWrapText(attributes) {
    return new WrapText(attributes);
  }

  var BaseSymbol = /*#__PURE__*/function () {
    function BaseSymbol() {
      _classCallCheck(this, BaseSymbol);
    }
    _createClass(BaseSymbol, [{
      key: "bounds",
      value: function bounds(size, _bounds) {
        if (isNumber$1(size)) {
          var halfS = size / 2;
          _bounds.x1 = -halfS, _bounds.x2 = halfS, _bounds.y1 = -halfS, _bounds.y2 = halfS;
        } else _bounds.x1 = -size[0] / 2, _bounds.x2 = size[0] / 2, _bounds.y1 = -size[1] / 2, _bounds.y2 = size[1] / 2;
      }
    }]);
    return BaseSymbol;
  }();

  function circle(ctx, r, x, y, z) {
    return z ? ctx.arc(x, y, r, 0, tau, !1, z) : ctx.arc(x, y, r, 0, tau), !1;
  }
  var CircleSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(CircleSymbol, _BaseSymbol);
    var _super = _createSuper(CircleSymbol);
    function CircleSymbol() {
      var _this;
      _classCallCheck(this, CircleSymbol);
      _this = _super.apply(this, arguments), _this.type = "circle", _this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
      return _this;
    }
    _createClass(CircleSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y, z) {
        return circle(ctx, size / 2, x, y, z);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset, z) {
        return circle(ctx, size / 2 + offset, x, y, z);
      }
    }, {
      key: "drawToSvgPath",
      value: function drawToSvgPath(size, x, y, z) {
        var r = size / 2;
        return "M ".concat(x - r, ", ").concat(y, " a ").concat(r, ",").concat(r, " 0 1,0 ").concat(2 * r, ",0 a ").concat(r, ",").concat(r, " 0 1,0 -").concat(2 * r, ",0");
      }
    }]);
    return CircleSymbol;
  }(BaseSymbol);
  var circle$1 = new CircleSymbol();

  function cross(ctx, r, x, y, z) {
    return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), ctx.closePath(), !0;
  }
  function crossOffset(ctx, r, x, y, offset, z) {
    return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), ctx.closePath(), !0;
  }
  var CrossSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(CrossSymbol, _BaseSymbol);
    var _super = _createSuper(CrossSymbol);
    function CrossSymbol() {
      var _this;
      _classCallCheck(this, CrossSymbol);
      _this = _super.apply(this, arguments), _this.type = "cross", _this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
      return _this;
    }
    _createClass(CrossSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y, z) {
        return cross(ctx, size / 6, x, y, z);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset, z) {
        return crossOffset(ctx, size / 6, x, y, offset, z);
      }
    }]);
    return CrossSymbol;
  }(BaseSymbol);
  var cross$1 = new CrossSymbol();

  function diamond(ctx, r, x, y, z) {
    return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), ctx.lineTo(x - r, y, z), ctx.closePath(), !0;
  }
  var DiamondSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(DiamondSymbol, _BaseSymbol);
    var _super = _createSuper(DiamondSymbol);
    function DiamondSymbol() {
      var _this;
      _classCallCheck(this, DiamondSymbol);
      _this = _super.apply(this, arguments), _this.type = "diamond", _this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
      return _this;
    }
    _createClass(DiamondSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y, z) {
        return diamond(ctx, size / 2, x, y, z);
      }
    }, {
      key: "drawFitDir",
      value: function drawFitDir(ctx, size, x, y, z) {
        return diamond(ctx, size / 2, x, y, z);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset, z) {
        return diamond(ctx, size / 2 + offset, x, y, z);
      }
    }]);
    return DiamondSymbol;
  }(BaseSymbol);
  var diamond$1 = new DiamondSymbol();

  function square(ctx, r, x, y) {
    var wh = 2 * r;
    return ctx.rect(x - r, y - r, wh, wh), !1;
  }
  var SquareSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(SquareSymbol, _BaseSymbol);
    var _super = _createSuper(SquareSymbol);
    function SquareSymbol() {
      var _this;
      _classCallCheck(this, SquareSymbol);
      _this = _super.apply(this, arguments), _this.type = "square", _this.pathStr = "M-0.5,-0.5h1v1h-1Z";
      return _this;
    }
    _createClass(SquareSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y) {
        return square(ctx, size / 2, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset) {
        return square(ctx, size / 2 + offset, x, y);
      }
    }]);
    return SquareSymbol;
  }(BaseSymbol);
  var square$1 = new SquareSymbol();

  function trianglUp(ctx, r, x, y) {
    return ctx.moveTo(x + r, r + y), ctx.lineTo(x - r, r + y), ctx.lineTo(x, y - r), ctx.closePath(), !0;
  }
  function trianglUpOffset(ctx, r, x, y, offset) {
    return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), !0;
  }
  var TriangleUpSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(TriangleUpSymbol, _BaseSymbol);
    var _super = _createSuper(TriangleUpSymbol);
    function TriangleUpSymbol() {
      var _this;
      _classCallCheck(this, TriangleUpSymbol);
      _this = _super.apply(this, arguments), _this.type = "triangleUp", _this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
      return _this;
    }
    _createClass(TriangleUpSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y) {
        return trianglUp(ctx, size / 2, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset) {
        return trianglUpOffset(ctx, size / 2, x, y, offset);
      }
    }]);
    return TriangleUpSymbol;
  }(BaseSymbol);
  var triangleUp = new TriangleUpSymbol();

  var TriangleSymbol = /*#__PURE__*/function (_TriangleUpSymbol) {
    _inherits(TriangleSymbol, _TriangleUpSymbol);
    var _super = _createSuper(TriangleSymbol);
    function TriangleSymbol() {
      var _this;
      _classCallCheck(this, TriangleSymbol);
      _this = _super.apply(this, arguments), _this.type = "triangle";
      return _this;
    }
    return _createClass(TriangleSymbol);
  }(TriangleUpSymbol);
  var triangle = new TriangleSymbol();

  var kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10),
    kx = Math.sin(tau / 10) * kr,
    ky = -Math.cos(tau / 10) * kr;
  function star(ctx, r, transX, transY) {
    var x = kx * r,
      y = ky * r;
    ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
        c = Math.cos(a),
        s = Math.sin(a);
      ctx.lineTo(s * r + transX, -c * r + transY), ctx.lineTo(c * x - s * y + transX, s * x + c * y + transY);
    }
    return ctx.closePath(), !0;
  }
  var StarSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(StarSymbol, _BaseSymbol);
    var _super = _createSuper(StarSymbol);
    function StarSymbol() {
      var _this;
      _classCallCheck(this, StarSymbol);
      _this = _super.apply(this, arguments), _this.type = "star", _this.pathStr = "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z";
      return _this;
    }
    _createClass(StarSymbol, [{
      key: "draw",
      value: function draw(ctx, size, transX, transY) {
        return star(ctx, size / 2, transX, transY);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, transX, transY, offset) {
        return star(ctx, size / 2 + offset, transX, transY);
      }
    }]);
    return StarSymbol;
  }(BaseSymbol);
  var star$1 = new StarSymbol();

  var sqrt3$1 = sqrt(3);
  function arrow(ctx, r, transX, transY) {
    var triangleH = r,
      trangleBottomSide = triangleH / sqrt3$1,
      rectW = trangleBottomSide / 5,
      rectH = r;
    return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), !0;
  }
  var ArrowSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(ArrowSymbol, _BaseSymbol);
    var _super = _createSuper(ArrowSymbol);
    function ArrowSymbol() {
      var _this;
      _classCallCheck(this, ArrowSymbol);
      _this = _super.apply(this, arguments), _this.type = "arrow", _this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
      return _this;
    }
    _createClass(ArrowSymbol, [{
      key: "draw",
      value: function draw(ctx, size, transX, transY) {
        return arrow(ctx, size / 2, transX, transY);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, transX, transY, offset) {
        return arrow(ctx, size / 2 + offset, transX, transY);
      }
    }]);
    return ArrowSymbol;
  }(BaseSymbol);
  var arrow$1 = new ArrowSymbol();

  function wedge(ctx, r, transX, transY) {
    var h = 2 * r;
    return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), !0;
  }
  var WedgeSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(WedgeSymbol, _BaseSymbol);
    var _super = _createSuper(WedgeSymbol);
    function WedgeSymbol() {
      var _this;
      _classCallCheck(this, WedgeSymbol);
      _this = _super.apply(this, arguments), _this.type = "wedge", _this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
      return _this;
    }
    _createClass(WedgeSymbol, [{
      key: "draw",
      value: function draw(ctx, size, transX, transY) {
        return wedge(ctx, size / 2, transX, transY);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, transX, transY, offset) {
        return wedge(ctx, size / 2 + offset, transX, transY);
      }
    }]);
    return WedgeSymbol;
  }(BaseSymbol);
  var wedge$1 = new WedgeSymbol();

  function stroke(ctx, r, transX, transY) {
    return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), !1;
  }
  var StrokeSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(StrokeSymbol, _BaseSymbol);
    var _super = _createSuper(StrokeSymbol);
    function StrokeSymbol() {
      var _this;
      _classCallCheck(this, StrokeSymbol);
      _this = _super.apply(this, arguments), _this.type = "stroke", _this.pathStr = "";
      return _this;
    }
    _createClass(StrokeSymbol, [{
      key: "draw",
      value: function draw(ctx, size, transX, transY) {
        return stroke(ctx, size / 2, transX, transY);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, transX, transY, offset) {
        return stroke(ctx, size / 2 + offset, transX, transY);
      }
    }]);
    return StrokeSymbol;
  }(BaseSymbol);
  var stroke$1 = new StrokeSymbol();

  var c$1 = -.5,
    s$1 = sqrt(3) / 2,
    k$1 = 1 / sqrt(12);
  function wye(ctx, r, transX, transY) {
    var x0 = r / 2,
      y0 = r * k$1,
      x1 = x0,
      y1 = r * k$1 + r,
      x2 = -x1,
      y2 = y1;
    return ctx.moveTo(x0 + transX, y0 + transY), ctx.lineTo(x1 + transX, y1 + transY), ctx.lineTo(x2 + transX, y2 + transY), ctx.lineTo(c$1 * x0 - s$1 * y0 + transX, s$1 * x0 + c$1 * y0 + transY), ctx.lineTo(c$1 * x1 - s$1 * y1 + transX, s$1 * x1 + c$1 * y1 + transY), ctx.lineTo(c$1 * x2 - s$1 * y2 + transX, s$1 * x2 + c$1 * y2 + transY), ctx.lineTo(c$1 * x0 + s$1 * y0 + transX, c$1 * y0 - s$1 * x0 + transY), ctx.lineTo(c$1 * x1 + s$1 * y1 + transX, c$1 * y1 - s$1 * x1 + transY), ctx.lineTo(c$1 * x2 + s$1 * y2 + transX, c$1 * y2 - s$1 * x2 + transY), ctx.closePath(), !1;
  }
  var WyeSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(WyeSymbol, _BaseSymbol);
    var _super = _createSuper(WyeSymbol);
    function WyeSymbol() {
      var _this;
      _classCallCheck(this, WyeSymbol);
      _this = _super.apply(this, arguments), _this.type = "wye", _this.pathStr = "M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z";
      return _this;
    }
    _createClass(WyeSymbol, [{
      key: "draw",
      value: function draw(ctx, size, transX, transY) {
        return wye(ctx, size / 2, transX, transY);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, transX, transY, offset) {
        return wye(ctx, size / 2 + offset, transX, transY);
      }
    }]);
    return WyeSymbol;
  }(BaseSymbol);
  var wye$1 = new WyeSymbol();

  function trianglLeft(ctx, r, x, y) {
    return ctx.moveTo(-r + x, y), ctx.lineTo(r + x, r + y), ctx.lineTo(r + x, y - r), ctx.closePath(), !0;
  }
  function trianglLeftOffset(ctx, r, x, y, offset) {
    return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), !0;
  }
  var TriangleLeftSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(TriangleLeftSymbol, _BaseSymbol);
    var _super = _createSuper(TriangleLeftSymbol);
    function TriangleLeftSymbol() {
      var _this;
      _classCallCheck(this, TriangleLeftSymbol);
      _this = _super.apply(this, arguments), _this.type = "triangleLeft", _this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
      return _this;
    }
    _createClass(TriangleLeftSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y) {
        return trianglLeft(ctx, size / 2, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset) {
        return trianglLeftOffset(ctx, size / 2, x, y, offset);
      }
    }]);
    return TriangleLeftSymbol;
  }(BaseSymbol);
  var triangleLeft = new TriangleLeftSymbol();

  function trianglRight(ctx, r, x, y) {
    return ctx.moveTo(x - r, r + y), ctx.lineTo(r + x, y), ctx.lineTo(x - r, y - r), ctx.closePath(), !0;
  }
  function trianglRightOffset(ctx, r, x, y, offset) {
    return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), !0;
  }
  var TriangleRightSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(TriangleRightSymbol, _BaseSymbol);
    var _super = _createSuper(TriangleRightSymbol);
    function TriangleRightSymbol() {
      var _this;
      _classCallCheck(this, TriangleRightSymbol);
      _this = _super.apply(this, arguments), _this.type = "triangleRight", _this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
      return _this;
    }
    _createClass(TriangleRightSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y) {
        return trianglRight(ctx, size / 2, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset) {
        return trianglRightOffset(ctx, size / 2, x, y, offset);
      }
    }]);
    return TriangleRightSymbol;
  }(BaseSymbol);
  var triangleRight = new TriangleRightSymbol();

  function trianglDown(ctx, r, x, y) {
    return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y - r), ctx.lineTo(x, y + r), ctx.closePath(), !0;
  }
  function trianglDownOffset(ctx, r, x, y, offset) {
    return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), !0;
  }
  var TriangleDownSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(TriangleDownSymbol, _BaseSymbol);
    var _super = _createSuper(TriangleDownSymbol);
    function TriangleDownSymbol() {
      var _this;
      _classCallCheck(this, TriangleDownSymbol);
      _this = _super.apply(this, arguments), _this.type = "triangleDown", _this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
      return _this;
    }
    _createClass(TriangleDownSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y) {
        return trianglDown(ctx, size / 2, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset) {
        return trianglDownOffset(ctx, size / 2, x, y, offset);
      }
    }]);
    return TriangleDownSymbol;
  }(BaseSymbol);
  var triangleDown = new TriangleDownSymbol();

  var sqrt3 = sqrt(3);
  function thinTriangle(ctx, r, x, y) {
    var h = r * sqrt3;
    return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), ctx.closePath(), !0;
  }
  var ThinTriangleSymbol = /*#__PURE__*/function (_TriangleUpSymbol) {
    _inherits(ThinTriangleSymbol, _TriangleUpSymbol);
    var _super = _createSuper(ThinTriangleSymbol);
    function ThinTriangleSymbol() {
      var _this;
      _classCallCheck(this, ThinTriangleSymbol);
      _this = _super.apply(this, arguments), _this.type = "thinTriangle", _this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
      return _this;
    }
    _createClass(ThinTriangleSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y) {
        return thinTriangle(ctx, size / 2 / sqrt3, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset) {
        return thinTriangle(ctx, size / 2 / sqrt3 + offset, x, y);
      }
    }]);
    return ThinTriangleSymbol;
  }(TriangleUpSymbol);
  var thinTriangle$1 = new ThinTriangleSymbol();

  function arrow2Left(ctx, r, transX, transY) {
    var r2 = 2 * r;
    return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), !0;
  }
  var Arrow2LeftSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(Arrow2LeftSymbol, _BaseSymbol);
    var _super = _createSuper(Arrow2LeftSymbol);
    function Arrow2LeftSymbol() {
      var _this;
      _classCallCheck(this, Arrow2LeftSymbol);
      _this = _super.apply(this, arguments), _this.type = "arrow2Left", _this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5";
      return _this;
    }
    _createClass(Arrow2LeftSymbol, [{
      key: "draw",
      value: function draw(ctx, size, transX, transY) {
        return arrow2Left(ctx, size / 4, transX, transY);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Left(ctx, size / 4 + offset, transX, transY);
      }
    }]);
    return Arrow2LeftSymbol;
  }(BaseSymbol);
  var arrow2Left$1 = new Arrow2LeftSymbol();

  function arrow2Right(ctx, r, transX, transY) {
    var r2 = 2 * r;
    return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), !0;
  }
  var Arrow2RightSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(Arrow2RightSymbol, _BaseSymbol);
    var _super = _createSuper(Arrow2RightSymbol);
    function Arrow2RightSymbol() {
      var _this;
      _classCallCheck(this, Arrow2RightSymbol);
      _this = _super.apply(this, arguments), _this.type = "arrow2Right", _this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5";
      return _this;
    }
    _createClass(Arrow2RightSymbol, [{
      key: "draw",
      value: function draw(ctx, size, transX, transY) {
        return arrow2Right(ctx, size / 4, transX, transY);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Right(ctx, size / 4 + offset, transX, transY);
      }
    }]);
    return Arrow2RightSymbol;
  }(BaseSymbol);
  var arrow2Right$1 = new Arrow2RightSymbol();

  function arrow2Up(ctx, r, transX, transY) {
    var r2 = 2 * r;
    return ctx.moveTo(transX - r2, transY + r), ctx.lineTo(transX, transY - r), ctx.lineTo(transX + r2, transY + r), !0;
  }
  var Arrow2UpSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(Arrow2UpSymbol, _BaseSymbol);
    var _super = _createSuper(Arrow2UpSymbol);
    function Arrow2UpSymbol() {
      var _this;
      _classCallCheck(this, Arrow2UpSymbol);
      _this = _super.apply(this, arguments), _this.type = "arrow2Up", _this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25";
      return _this;
    }
    _createClass(Arrow2UpSymbol, [{
      key: "draw",
      value: function draw(ctx, size, transX, transY) {
        return arrow2Up(ctx, size / 4, transX, transY);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Up(ctx, size / 4 + offset, transX, transY);
      }
    }]);
    return Arrow2UpSymbol;
  }(BaseSymbol);
  var arrow2Up$1 = new Arrow2UpSymbol();

  function arrow2Down(ctx, r, transX, transY) {
    var r2 = 2 * r;
    return ctx.moveTo(transX - r2, transY - r), ctx.lineTo(transX, transY + r), ctx.lineTo(transX + r2, transY - r), !0;
  }
  var Arrow2DownSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(Arrow2DownSymbol, _BaseSymbol);
    var _super = _createSuper(Arrow2DownSymbol);
    function Arrow2DownSymbol() {
      var _this;
      _classCallCheck(this, Arrow2DownSymbol);
      _this = _super.apply(this, arguments), _this.type = "arrow2Down", _this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25";
      return _this;
    }
    _createClass(Arrow2DownSymbol, [{
      key: "draw",
      value: function draw(ctx, size, transX, transY) {
        return arrow2Down(ctx, size / 4, transX, transY);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, transX, transY, offset) {
        return arrow2Down(ctx, size / 4 + offset, transX, transY);
      }
    }]);
    return Arrow2DownSymbol;
  }(BaseSymbol);
  var arrow2Down$1 = new Arrow2DownSymbol();

  function lineV(ctx, r, x, y, z) {
    return ctx.moveTo(x, y - r), ctx.lineTo(x, y + r), !0;
  }
  var LineVSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(LineVSymbol, _BaseSymbol);
    var _super = _createSuper(LineVSymbol);
    function LineVSymbol() {
      var _this;
      _classCallCheck(this, LineVSymbol);
      _this = _super.apply(this, arguments), _this.type = "lineV", _this.pathStr = "M0,-0.5L0,0.5";
      return _this;
    }
    _createClass(LineVSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y, z) {
        return lineV(ctx, size / 2, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset, z) {
        return lineV(ctx, size / 2 + offset, x, y);
      }
    }, {
      key: "drawToSvgPath",
      value: function drawToSvgPath(size, x, y, z) {
        var r = size / 2;
        return "M ".concat(x, ", ").concat(y - r, " L ").concat(x, ",").concat(y + r);
      }
    }]);
    return LineVSymbol;
  }(BaseSymbol);
  var lineV$1 = new LineVSymbol();

  function lineH(ctx, r, x, y, z) {
    return ctx.moveTo(x - r, y), ctx.lineTo(x + r, y), !0;
  }
  var LineHSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(LineHSymbol, _BaseSymbol);
    var _super = _createSuper(LineHSymbol);
    function LineHSymbol() {
      var _this;
      _classCallCheck(this, LineHSymbol);
      _this = _super.apply(this, arguments), _this.type = "lineH", _this.pathStr = "M-0.5,0L0.5,0";
      return _this;
    }
    _createClass(LineHSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y, z) {
        return lineH(ctx, size / 2, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset, z) {
        return lineH(ctx, size / 2 + offset, x, y);
      }
    }, {
      key: "drawToSvgPath",
      value: function drawToSvgPath(size, x, y, z) {
        var r = size / 2;
        return "M ".concat(x - r, ", ").concat(y, " L ").concat(x + r, ",").concat(y);
      }
    }]);
    return LineHSymbol;
  }(BaseSymbol);
  var lineH$1 = new LineHSymbol();

  function close(ctx, r, x, y, z) {
    return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y + r), ctx.moveTo(x + r, y - r), ctx.lineTo(x - r, y + r), !0;
  }
  var CloseSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(CloseSymbol, _BaseSymbol);
    var _super = _createSuper(CloseSymbol);
    function CloseSymbol() {
      var _this;
      _classCallCheck(this, CloseSymbol);
      _this = _super.apply(this, arguments), _this.type = "close", _this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5";
      return _this;
    }
    _createClass(CloseSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y, z) {
        return close(ctx, size / 2, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset, z) {
        return close(ctx, size / 2 + offset, x, y);
      }
    }, {
      key: "drawToSvgPath",
      value: function drawToSvgPath(size, x, y, z) {
        var r = size / 2;
        return "M ".concat(x - r, ", ").concat(y - r, " L ").concat(x + r, ",").concat(y + r, " M ").concat(x + r, ", ").concat(y - r, " L ").concat(x - r, ",").concat(y + r);
      }
    }]);
    return CloseSymbol;
  }(BaseSymbol);
  var close$1 = new CloseSymbol();

  function rectSizeArray(ctx, size, x, y) {
    return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), !1;
  }
  function rectSize(ctx, size, x, y) {
    var w = size,
      h = size / 2;
    return ctx.rect(x - w / 2, y - h / 2, w, h), !1;
  }
  var RectSymbol = /*#__PURE__*/function (_BaseSymbol) {
    _inherits(RectSymbol, _BaseSymbol);
    var _super = _createSuper(RectSymbol);
    function RectSymbol() {
      var _this;
      _classCallCheck(this, RectSymbol);
      _this = _super.apply(this, arguments), _this.type = "rect", _this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z";
      return _this;
    }
    _createClass(RectSymbol, [{
      key: "draw",
      value: function draw(ctx, size, x, y) {
        return isNumber$1(size) ? rectSize(ctx, size, x, y) : rectSizeArray(ctx, size, x, y);
      }
    }, {
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset) {
        return isNumber$1(size) ? rectSize(ctx, size + 2 * offset, x, y) : rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x, y);
      }
    }]);
    return RectSymbol;
  }(BaseSymbol);
  var rect = new RectSymbol();

  var tempBounds = new AABBBounds();
  var CustomSymbolClass = /*#__PURE__*/function () {
    function CustomSymbolClass(type, path) {
      var isSvg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
      _classCallCheck(this, CustomSymbolClass);
      this.pathStr = "", this.type = type, isArray$1(path) ? this.svgCache = path : this.path = path, this.isSvg = isSvg;
    }
    _createClass(CustomSymbolClass, [{
      key: "drawOffset",
      value: function drawOffset(ctx, size, x, y, offset, z, cb) {
        return this.isSvg ? !!this.svgCache && (this.svgCache.forEach(function (item) {
          ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
        }), !1) : (renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset), !1);
      }
    }, {
      key: "draw",
      value: function draw(ctx, size, x, y, z, cb) {
        return this.isSvg ? !!this.svgCache && (this.svgCache.forEach(function (item) {
          ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
        }), !1) : (renderCommandList(this.path.commandList, ctx, x, y, size, size), !1);
      }
    }, {
      key: "bounds",
      value: function bounds(size, _bounds) {
        if (this.isSvg) {
          if (!this.svgCache) return;
          return _bounds.clear(), void this.svgCache.forEach(function (_ref) {
            var path = _ref.path;
            tempBounds.x1 = path.bounds.x1 * size, tempBounds.y1 = path.bounds.y1 * size, tempBounds.x2 = path.bounds.x2 * size, tempBounds.y2 = path.bounds.y2 * size, _bounds.union(tempBounds);
          });
        }
        this.path.bounds && (_bounds.x1 = this.path.bounds.x1 * size, _bounds.y1 = this.path.bounds.y1 * size, _bounds.x2 = this.path.bounds.x2 * size, _bounds.y2 = this.path.bounds.y2 * size);
      }
    }]);
    return CustomSymbolClass;
  }();

  var builtinSymbols = [circle$1, cross$1, diamond$1, square$1, thinTriangle$1, triangle, star$1, arrow$1, wedge$1, stroke$1, wye$1, triangleLeft, triangleRight, triangleUp, triangleDown, arrow2Left$1, arrow2Right$1, arrow2Up$1, arrow2Down$1, rect, lineV$1, lineH$1, close$1];
  var builtinSymbolsMap = {};
  builtinSymbols.forEach(function (symbol) {
    builtinSymbolsMap[symbol.type] = symbol;
  });
  var builtInSymbolStrMap = {
    arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
    arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
    rectRound: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
    roundLine: "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z"
  };

  var _tempBounds$1 = new AABBBounds(),
    SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var _Symbol = /*#__PURE__*/function (_Graphic) {
    _inherits(_Symbol, _Graphic);
    var _super = _createSuper(_Symbol);
    function _Symbol() {
      var _this;
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        symbolType: "circle"
      };
      _classCallCheck(this, _Symbol);
      _this = _super.call(this, params), _this.type = "symbol", _this.numberType = SYMBOL_NUMBER_TYPE;
      return _this;
    }
    _createClass(_Symbol, [{
      key: "getParsedPath",
      value: function getParsedPath() {
        return this.shouldUpdateShape() && (this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return _get(_getPrototypeOf(_Symbol.prototype), "isValid", this).call(this) && this._isValid();
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        var size = this.attribute.size;
        return isArray$1(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
      }
    }, {
      key: "doUpdateParsedPath",
      value: function doUpdateParsedPath() {
        var symbolTheme = getTheme(this).symbol;
        var _this$attribute$symbo = this.attribute.symbolType,
          symbolType = _this$attribute$symbo === void 0 ? symbolTheme.symbolType : _this$attribute$symbo,
          path = builtinSymbolsMap[symbolType];
        if (path) return this._parsedPath = path, path;
        if (path = _Symbol.userSymbolMap[symbolType], path) return this._parsedPath = path, path;
        symbolType = builtInSymbolStrMap[symbolType] || symbolType;
        if (!0 === isSvg(symbolType)) {
          var parser = new XMLParser(),
            _parser$parse = parser.parse(symbolType),
            svg = _parser$parse.svg;
          if (!svg) return null;
          var _path = isArray$1(svg.path) ? svg.path : [svg.path];
          _tempBounds$1.clear();
          var cacheList = [];
          _path.forEach(function (item) {
            var cache = new CustomPath2D().fromString(item.d),
              attribute = {};
            SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach(function (k) {
              item[k] && (attribute[SVG_PARSE_ATTRIBUTE_MAP[k]] = item[k]);
            }), cacheList.push({
              path: cache,
              attribute: attribute
            }), _tempBounds$1.union(cache.bounds);
          });
          var _width = _tempBounds$1.width(),
            _height = _tempBounds$1.height(),
            _scale = 1 / max(_width, _height);
          return cacheList.forEach(function (cache) {
            return cache.path.transform(0, 0, _scale, _scale);
          }), this._parsedPath = new CustomSymbolClass(symbolType, cacheList, !0), _Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;
        }
        var cache = new CustomPath2D().fromString(symbolType),
          width = cache.bounds.width(),
          height = cache.bounds.height(),
          scale = 1 / max(width, height);
        return cache.transform(0, 0, scale, scale), this._parsedPath = new CustomSymbolClass(symbolType, cache), _Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds(full) {
        var symbolTheme = getTheme(this).symbol;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateSymbolAABBBounds(attribute, getTheme(this).symbol, this._AABBBounds, full, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? symbolTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this).symbol[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(_Symbol.prototype), "needUpdateTags", this).call(this, keys, SYMBOL_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(_Symbol.prototype), "needUpdateTag", this).call(this, key, SYMBOL_UPDATE_TAG_KEY);
      }
    }, {
      key: "toCustomPath",
      value: function toCustomPath() {
        var symbolInstance = this.getParsedPath(),
          size = this.attribute.size,
          formattedSize = isArray$1(size) ? size : [size, size];
        return symbolInstance.path ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : new CustomPath2D().fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new _Symbol(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return _Symbol.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return _Symbol;
  }(Graphic);
  _Symbol.userSymbolMap = {}, _Symbol.NOWORK_ANIMATE_ATTR = Object.assign({
    symbolType: 1
  }, NOWORK_ANIMATE_ATTR);
  function createSymbol(attributes) {
    return new _Symbol(attributes);
  }

  var LINE_UPDATE_TAG_KEY = ["segments", "points", "curveType"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var Line$1 = /*#__PURE__*/function (_Graphic) {
    _inherits(Line, _Graphic);
    var _super = _createSuper(Line);
    function Line() {
      var _this;
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Line);
      _this = _super.call(this, params), _this.type = "line", _this.numberType = LINE_NUMBER_TYPE;
      return _this;
    }
    _createClass(Line, [{
      key: "isValid",
      value: function isValid() {
        return _get(_getPrototypeOf(Line.prototype), "isValid", this).call(this) && this._isValid();
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        if (this.pathProxy) return !0;
        var _this$attribute = this.attribute,
          points = _this$attribute.points,
          segments = _this$attribute.segments;
        return segments ? 0 !== segments.length : !!points && !(points.length <= 1);
      }
    }, {
      key: "_interpolate",
      value: function _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var lineTheme = getTheme(this).line;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateLineAABBBounds(attribute, getTheme(this).line, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? lineTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this).line[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(Line.prototype), "needUpdateTags", this).call(this, keys, LINE_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(Line.prototype), "needUpdateTag", this).call(this, key, LINE_UPDATE_TAG_KEY);
      }
    }, {
      key: "toCustomPath",
      value: function toCustomPath() {
        var attribute = this.attribute,
          path = new CustomPath2D(),
          segments = attribute.segments,
          parsePoints = function parsePoints(points) {
            if (points && points.length) {
              var isFirst = !0;
              points.forEach(function (point) {
                !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), isFirst = !1);
              });
            }
          };
        return segments && segments.length ? segments.forEach(function (seg) {
          parsePoints(seg.points);
        }) : attribute.points && parsePoints(attribute.points), path;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Line(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Line.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Line;
  }(Graphic);
  Line$1.NOWORK_ANIMATE_ATTR = Object.assign({
    segments: 1,
    curveType: 1
  }, NOWORK_ANIMATE_ATTR);
  function createLine(attributes) {
    return new Line$1(attributes);
  }

  var RECT_UPDATE_TAG_KEY = ["width", "x1", "y1", "height", "cornerRadius"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var Rect = /*#__PURE__*/function (_Graphic) {
    _inherits(Rect, _Graphic);
    var _super = _createSuper(Rect);
    function Rect(params) {
      var _this;
      _classCallCheck(this, Rect);
      _this = _super.call(this, params), _this.type = "rect", _this.numberType = RECT_NUMBER_TYPE;
      return _this;
    }
    _createClass(Rect, [{
      key: "isValid",
      value: function isValid() {
        return _get(_getPrototypeOf(Rect.prototype), "isValid", this).call(this) && this._isValid();
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        return !0;
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var rectTheme = getTheme(this).rect;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateRectAABBBounds(attribute, getTheme(this).rect, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? rectTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this).rect[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(Rect.prototype), "needUpdateTags", this).call(this, keys, RECT_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(Rect.prototype), "needUpdateTag", this).call(this, key, RECT_UPDATE_TAG_KEY);
      }
    }, {
      key: "toCustomPath",
      value: function toCustomPath() {
        var attribute = this.attribute,
          _normalizeRectAttribu = normalizeRectAttributes(attribute),
          x = _normalizeRectAttribu.x,
          y = _normalizeRectAttribu.y,
          width = _normalizeRectAttribu.width,
          height = _normalizeRectAttribu.height,
          path = new CustomPath2D();
        return path.moveTo(x, y), path.rect(x, y, width, height), path;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Rect(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Rect.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Rect;
  }(Graphic);
  Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
  function createRect(attributes) {
    return new Rect(attributes);
  }

  var CUBE_VERTICES = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
  var Rect3d = /*#__PURE__*/function (_Rect) {
    _inherits(Rect3d, _Rect);
    var _super = _createSuper(Rect3d);
    function Rect3d(params) {
      var _this;
      _classCallCheck(this, Rect3d);
      _this = _super.call(this, params), _this.type = "rect3d", _this.numberType = RECT3D_NUMBER_TYPE;
      return _this;
    }
    _createClass(Rect3d, [{
      key: "findFace",
      value: function findFace() {
        var faces = {
            polygons: [],
            vertices: [],
            edges: []
          },
          rectTheme = getTheme(this).rect3d,
          _this$attribute = this.attribute,
          x1 = _this$attribute.x1,
          y1 = _this$attribute.y1,
          x = _this$attribute.x,
          y = _this$attribute.y,
          _this$attribute$lengt = _this$attribute.length,
          length = _this$attribute$lengt === void 0 ? min(rectTheme.width, rectTheme.height) : _this$attribute$lengt;
        var _this$attribute2 = this.attribute,
          width = _this$attribute2.width,
          height = _this$attribute2.height;
        width = null != width ? width : x1 - x, height = null != height ? height : y1 - y;
        for (var i = 0; i < CUBE_VERTICES.length; i++) {
          var v = CUBE_VERTICES[i];
          faces.vertices.push([v[0] * width, v[1] * height, v[2] * length]);
        }
        return faces.polygons.push({
          polygon: [0, 1, 5, 4],
          normal: [0, -1, 0]
        }), faces.polygons.push({
          polygon: [2, 3, 7, 6],
          normal: [0, 1, 0]
        }), faces.polygons.push({
          polygon: [4, 7, 3, 0],
          normal: [-1, 0, 0]
        }), faces.polygons.push({
          polygon: [1, 2, 6, 5],
          normal: [1, 0, 0]
        }), faces.polygons.push({
          polygon: [0, 1, 2, 3],
          normal: [0, 0, -1]
        }), faces.polygons.push({
          polygon: [4, 5, 6, 7],
          normal: [0, 0, 1]
        }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Rect3d.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Rect3d;
  }(Rect);
  Rect3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
  function createRect3d(attributes) {
    return new Rect3d(attributes);
  }

  var Glyph = /*#__PURE__*/function (_Graphic) {
    _inherits(Glyph, _Graphic);
    var _super = _createSuper(Glyph);
    function Glyph(params) {
      var _this;
      _classCallCheck(this, Glyph);
      _this = _super.call(this, params), _this.type = "glyph", _this.numberType = GLYPH_NUMBER_TYPE, _this.subGraphic = [], _this._onInit && _this._onInit(_assertThisInitialized(_this)), _this.valid = _this.isValid();
      return _this;
    }
    _createClass(Glyph, [{
      key: "setSubGraphic",
      value: function setSubGraphic(subGraphic) {
        var _this2 = this;
        this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach(function (g) {
          g.glyphHost = _this2, Object.setPrototypeOf(g.attribute, _this2.attribute);
        }), this.valid = this.isValid(), this.addUpdateBoundTag();
      }
    }, {
      key: "detachSubGraphic",
      value: function detachSubGraphic() {
        this.subGraphic.forEach(function (g) {
          g.glyphHost = null, Object.setPrototypeOf(g.attribute, {});
        });
      }
    }, {
      key: "getSubGraphic",
      value: function getSubGraphic() {
        return this.subGraphic;
      }
    }, {
      key: "onInit",
      value: function onInit(cb) {
        this._onInit = cb;
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(cb) {
        this._onUpdate = cb;
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return !0;
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(key, value, forceUpdateTag, context) {
        _get(_getPrototypeOf(Glyph.prototype), "setAttribute", this).call(this, key, value, forceUpdateTag, context), this.subGraphic.forEach(function (g) {
          g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
        });
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(params) {
        var forceUpdateTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
        var context = arguments.length > 2 ? arguments[2] : undefined;
        _get(_getPrototypeOf(Glyph.prototype), "setAttributes", this).call(this, params, forceUpdateTag, context), this.subGraphic.forEach(function (g) {
          g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
        });
      }
    }, {
      key: "translate",
      value: function translate(x, y) {
        return _get(_getPrototypeOf(Glyph.prototype), "translate", this).call(this, x, y), this.subGraphic.forEach(function (g) {
          g.addUpdatePositionTag(), g.addUpdateBoundTag();
        }), this;
      }
    }, {
      key: "translateTo",
      value: function translateTo(x, y) {
        return _get(_getPrototypeOf(Glyph.prototype), "translateTo", this).call(this, x, y), this.subGraphic.forEach(function (g) {
          g.addUpdatePositionTag(), g.addUpdateBoundTag();
        }), this;
      }
    }, {
      key: "scale",
      value: function scale(scaleX, scaleY, scaleCenter) {
        return _get(_getPrototypeOf(Glyph.prototype), "scale", this).call(this, scaleX, scaleY, scaleCenter), this.subGraphic.forEach(function (g) {
          g.addUpdatePositionTag(), g.addUpdateBoundTag();
        }), this;
      }
    }, {
      key: "scaleTo",
      value: function scaleTo(scaleX, scaleY) {
        return _get(_getPrototypeOf(Glyph.prototype), "scaleTo", this).call(this, scaleX, scaleY), this.subGraphic.forEach(function (g) {
          g.addUpdatePositionTag(), g.addUpdateBoundTag();
        }), this;
      }
    }, {
      key: "rotate",
      value: function rotate(angle) {
        return _get(_getPrototypeOf(Glyph.prototype), "rotate", this).call(this, angle), this.subGraphic.forEach(function (g) {
          g.addUpdatePositionTag(), g.addUpdateBoundTag();
        }), this;
      }
    }, {
      key: "rotateTo",
      value: function rotateTo(angle) {
        return _get(_getPrototypeOf(Glyph.prototype), "rotate", this).call(this, angle), this.subGraphic.forEach(function (g) {
          g.addUpdatePositionTag(), g.addUpdateBoundTag();
        }), this;
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        this._AABBBounds.clear();
        var bounds = application.graphicService.updateGlyphAABBBounds(this.attribute, getTheme(this).glyph, this._AABBBounds, this);
        return this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return !1;
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return !1;
      }
    }, {
      key: "useStates",
      value: function useStates(states, hasAnimation) {
        var _this3 = this;
        var _a;
        if (!states.length) return void this.clearStates(hasAnimation);
        if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some(function (stateName, index) {
          return _this3.currentStates[index] !== stateName;
        }))) return;
        var stateAttrs = {},
          subAttrs = this.subGraphic.map(function () {
            return {};
          });
        states.forEach(function (stateName) {
          var _a;
          var attrs = _this3.glyphStateProxy ? _this3.glyphStateProxy(stateName, states) : _this3.glyphStates[stateName];
          attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a = attrs.subAttributes) || void 0 === _a ? void 0 : _a.length) && subAttrs.forEach(function (subAttrs, index) {
            Object.assign(subAttrs, attrs.subAttributes[index]);
          }));
        }), this.subGraphic.forEach(function (graphic, index) {
          graphic.updateNormalAttrs(subAttrs[index]), graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);
        }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
      }
    }, {
      key: "clearStates",
      value: function clearStates(hasAnimation) {
        var _this4 = this;
        this.hasState() && this.normalAttrs && (this.subGraphic.forEach(function (graphic) {
          graphic.applyStateAttrs(graphic.normalAttrs, _this4.currentStates, hasAnimation, !0), graphic.normalAttrs = null;
        }), this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0), this.normalAttrs = null, this.currentStates = []);
      }
    }, {
      key: "clone",
      value: function clone() {
        var glyph = new Glyph(Object.assign({}, this.attribute));
        return glyph.setSubGraphic(this.subGraphic.map(function (g) {
          return g.clone();
        })), glyph;
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Glyph.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Glyph;
  }(Graphic);
  Glyph.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
  function createGlyph(attributes) {
    return new Glyph(attributes);
  }

  var Frame = /*#__PURE__*/function () {
    function Frame(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
      _classCallCheck(this, Frame);
      this.left = left, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, this.bottom = top + height, this.right = left + width, this.ellipsis = ellipsis, this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, this.directionKey = DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), this.icons = icons) : this.icons = new Map();
    }
    _createClass(Frame, [{
      key: "draw",
      value: function draw(ctx, drawIcon) {
        var _this$getActualSize = this.getActualSize(),
          actualWidth = _this$getActualSize.width,
          actualHeight = _this$getActualSize.height,
          width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
        var height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
        height = Math.min(height, actualHeight);
        var deltaY = 0;
        switch (this.globalBaseline) {
          case "top":
            deltaY = 0;
            break;
          case "middle":
            deltaY = -height / 2;
            break;
          case "bottom":
            deltaY = -height;
        }
        var deltaX = 0;
        "right" === this.globalAlign || "end" === this.globalAlign ? deltaX = -width : "center" === this.globalAlign && (deltaX = -width / 2);
        var frameHeight = this[this.directionKey.height];
        this.singleLine && (frameHeight = this.lines[0].height + 1);
        var lastLineTag = !1;
        if ("middle" === this.verticalDirection) {
          if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (var i = 0; i < this.lines.length; i++) {
            var _this$lines$i = this.lines[i],
              top = _this$lines$i.top,
              _height = _this$lines$i.height;
            if (top + _height < this[this.directionKey.top] || top + _height > this[this.directionKey.top] + frameHeight) return lastLineTag;
            var lastLine = !1;
            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, drawIcon);
          } else {
            var detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
            "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
            for (var _i = 0; _i < this.lines.length; _i++) this.lines[_i].draw(ctx, !1, this.lines[_i][this.directionKey.left] + deltaX, this.lines[_i][this.directionKey.top] + deltaY, drawIcon);
          }
        } else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection) for (var _i2 = 0; _i2 < this.lines.length; _i2++) {
          var _this$lines$_i = this.lines[_i2];
            _this$lines$_i.top;
            var _height2 = _this$lines$_i.height,
            y = frameHeight - this.lines[_i2].top - this.lines[_i2].height;
          if (0 === frameHeight) this.lines[_i2].draw(ctx, !1, deltaX, y + deltaY, drawIcon);else {
            if (y + _height2 > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) return lastLineTag;
            {
              var _lastLine = !1;
              this.ellipsis && this.lines[_i2 + 1] && y - this.lines[_i2 + 1].height < this[this.directionKey.top] && (_lastLine = !0, lastLineTag = !0), this.lines[_i2].draw(ctx, _lastLine, deltaX, y + deltaY, drawIcon);
            }
          }
        } else {
          "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
          for (var _i3 = 0; _i3 < this.lines.length; _i3++) {
            "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[_i3].height + this.lines[_i3].top);
            var _this$lines$_i2 = this.lines[_i3],
              _top2 = _this$lines$_i2.top,
              _height3 = _this$lines$_i2.height;
            if (0 === frameHeight) this.lines[_i3].draw(ctx, !1, this.lines[_i3][this.directionKey.left] + deltaX, this.lines[_i3][this.directionKey.top] + deltaY, drawIcon);else {
              if (_top2 + _height3 < this[this.directionKey.top] || _top2 + _height3 > this[this.directionKey.top] + frameHeight) return lastLineTag;
              {
                var _lastLine2 = !1;
                this.ellipsis && this.lines[_i3 + 1] && this.lines[_i3 + 1].top + this.lines[_i3 + 1].height > this[this.directionKey.top] + frameHeight && (_lastLine2 = !0, lastLineTag = !0), this.lines[_i3].draw(ctx, _lastLine2, this.lines[_i3][this.directionKey.left] + deltaX, this.lines[_i3][this.directionKey.top] + deltaY, drawIcon);
              }
            }
          }
        }
        return lastLineTag;
      }
    }, {
      key: "getActualSize",
      value: function getActualSize() {
        return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
      }
    }, {
      key: "getRawActualSize",
      value: function getRawActualSize() {
        var width = 0,
          height = 0;
        for (var i = 0; i < this.lines.length; i++) {
          var line = this.lines[i];
          line.actualWidth > width && (width = line.actualWidth), height += line.height;
        }
        return {
          width: "vertical" === this.layoutDirection ? height : width,
          height: "vertical" === this.layoutDirection ? width : height
        };
      }
    }, {
      key: "getActualSizeWidthEllipsis",
      value: function getActualSizeWidthEllipsis() {
        var widthBound = 0,
          heightBound = 0;
        var _this$getRawActualSiz = this.getRawActualSize();
          _this$getRawActualSiz.width;
          var actualHeight = _this$getRawActualSiz.height;
        this.width;
        this.height || actualHeight || 0;
        var frameHeight = this[this.directionKey.height];
        if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection) {
          if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (var i = 0; i < this.lines.length; i++) {
            var _this$lines$i2 = this.lines[i],
              top = _this$lines$i2.top,
              _height4 = _this$lines$i2.height;
            if (top + _height4 < this[this.directionKey.top] || top + _height4 > this[this.directionKey.top] + frameHeight) ;else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
              var lineWidth = this.lines[i].getWidthWithEllips();
              lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
            } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
          } else {
            Math.floor((frameHeight - this.actualHeight) / 2);
            for (var _i4 = 0; _i4 < this.lines.length; _i4++) this.lines[_i4].actualWidth > widthBound && (widthBound = this.lines[_i4].actualWidth), heightBound += this.lines[_i4].height;
          }
        } else if ("bottom" === this.verticalDirection) for (var _i5 = 0; _i5 < this.lines.length; _i5++) {
          var _this$lines$_i3 = this.lines[_i5];
            _this$lines$_i3.top;
            var _height5 = _this$lines$_i3.height,
            y = frameHeight - this.lines[_i5].top - this.lines[_i5].height;
          if (0 === frameHeight) this.lines[_i5].actualWidth > widthBound && (widthBound = this.lines[_i5].actualWidth), heightBound += this.lines[_i5].height;else if (y + _height5 > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ;else {
            if (this.ellipsis && this.lines[_i5 + 1] && y - this.lines[_i5 + 1].height < this[this.directionKey.top]) {
              var _lineWidth = this.lines[_i5].getWidthWithEllips();
              _lineWidth > widthBound && (widthBound = _lineWidth), heightBound += this.lines[_i5].height;
            } else this.lines[_i5].actualWidth > widthBound && (widthBound = this.lines[_i5].actualWidth), heightBound += this.lines[_i5].height;
          }
        } else for (var _i6 = 0; _i6 < this.lines.length; _i6++) {
          var _this$lines$_i4 = this.lines[_i6],
            _top4 = _this$lines$_i4.top,
            _height6 = _this$lines$_i4.height;
          if (0 === frameHeight) this.lines[_i6].actualWidth > widthBound && (widthBound = this.lines[_i6].actualWidth), heightBound += this.lines[_i6].height;else if (_top4 + _height6 < this[this.directionKey.top] || _top4 + _height6 > this[this.directionKey.top] + frameHeight) ;else {
            if (this.ellipsis && this.lines[_i6 + 1] && this.lines[_i6 + 1].top + this.lines[_i6 + 1].height > this[this.directionKey.top] + frameHeight) {
              var _lineWidth2 = this.lines[_i6].getWidthWithEllips();
              _lineWidth2 > widthBound && (widthBound = _lineWidth2), heightBound += this.lines[_i6].height;
            } else this.lines[_i6].actualWidth > widthBound && (widthBound = this.lines[_i6].actualWidth), heightBound += this.lines[_i6].height;
          }
        }
        return {
          width: "vertical" === this.layoutDirection ? heightBound : widthBound,
          height: "vertical" === this.layoutDirection ? widthBound : heightBound
        };
      }
    }]);
    return Frame;
  }();

  var Paragraph = /*#__PURE__*/function () {
    function Paragraph(text, newLine, character) {
      _classCallCheck(this, Paragraph);
      this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic";
      var lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
      this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), this.height = this.lineHeight;
      var _measureTextCanvas = measureTextCanvas(text, character),
        ascent = _measureTextCanvas.ascent,
        height = _measureTextCanvas.height,
        descent = _measureTextCanvas.descent,
        width = _measureTextCanvas.width;
      var halfDetaHeight = 0,
        deltaAscent = 0,
        deltaDescent = 0;
      this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), this.length = text.length, this.width = width || 0, this.text = text || "", this.newLine = newLine || !1, this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, "vertical" === character.direction && (this.direction = character.direction, this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, this.height = this.widthOrigin, this.lineHeight = this.height);
    }
    _createClass(Paragraph, [{
      key: "updateWidth",
      value: function updateWidth() {
        var _measureTextCanvas2 = measureTextCanvas(this.text, this.character),
          width = _measureTextCanvas2.width;
        this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, this.width = this.heightOrigin, this.height = this.widthOrigin);
      }
    }, {
      key: "draw",
      value: function draw(ctx, baseline, deltaLeft, isLineFirst, textAlign) {
        var text = this.text,
          left = this.left + deltaLeft;
        baseline += this.top;
        var direction = this.direction;
        if (this.verticalEllipsis) text = "...", direction = "vertical", baseline -= this.ellipsisWidth / 2;else {
          if ("hide" === this.ellipsis) return;
          if ("add" === this.ellipsis) text += "...", "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);else if ("replace" === this.ellipsis) {
            var index = getStrByWithCanvas(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
            if (text = text.slice(0, index), text += "...", "right" === textAlign || "end" === textAlign) {
              var _measureTextCanvas3 = measureTextCanvas(this.text.slice(index), this.character),
                width = _measureTextCanvas3.width;
              "vertical" === direction || (left -= this.ellipsisWidth - width);
            }
          }
        }
        switch (this.character.script) {
          case "super":
            baseline -= this.ascent * (1 / 3);
            break;
          case "sub":
            baseline += this.descent / 2;
        }
        "vertical" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left, baseline), ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left, baseline), left = 0, baseline = 0), this.character.stroke && (applyStrokeStyle(ctx, this.character), ctx.strokeText(text, left, baseline)), applyFillStyle(ctx, this.character), this.character.fill && ctx.fillText(text, left, baseline), this.character.fill && ("boolean" == typeof this.character.lineThrough || "boolean" == typeof this.character.underline ? (this.character.underline && ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1), this.character.lineThrough && ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)) : "underline" === this.character.textDecoration ? ctx.fillRect(left, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1) : "line-through" === this.character.textDecoration && ctx.fillRect(left, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)), "vertical" === direction && ctx.restore();
      }
    }, {
      key: "getWidthWithEllips",
      value: function getWidthWithEllips(direction) {
        var text = this.text;
        var width = "vertical" === direction ? this.height : this.width;
        if ("hide" === this.ellipsis) return width;
        if ("add" === this.ellipsis) return width + this.ellipsisWidth;
        if ("replace" === this.ellipsis) {
          var index = getStrByWithCanvas(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
          text = text.slice(0, index), text += "...";
          var _measureTextCanvas4 = measureTextCanvas(this.text.slice(index), this.character),
            measureWidth = _measureTextCanvas4.width;
          return width + this.ellipsisWidth - measureWidth;
        }
        return width;
      }
    }]);
    return Paragraph;
  }();
  function seperateParagraph(paragraph, index) {
    var text1 = paragraph.text.slice(0, index),
      text2 = paragraph.text.slice(index);
    return [new Paragraph(text1, paragraph.newLine, paragraph.character), new Paragraph(text2, !0, paragraph.character)];
  }

  var IMAGE_UPDATE_TAG_KEY = ["width", "height", "image"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var Image = /*#__PURE__*/function (_Graphic) {
    _inherits(Image, _Graphic);
    var _super = _createSuper(Image);
    function Image(params) {
      var _this;
      _classCallCheck(this, Image);
      _this = _super.call(this, params), _this.type = "image", _this.numberType = IMAGE_NUMBER_TYPE, _this.loadImage(_this.attribute.image);
      return _this;
    }
    _createClass(Image, [{
      key: "width",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0;
      },
      set: function set(width) {
        this.attribute.width === width && (this.attribute.width = width, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "height",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0;
      },
      set: function set(height) {
        this.attribute.height === height && (this.attribute.height = height, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "repeatX",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
      },
      set: function set(repeatX) {
        this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
      }
    }, {
      key: "repeatY",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
      },
      set: function set(repeatY) {
        this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
      }
    }, {
      key: "image",
      get: function get() {
        return this.attribute.image;
      },
      set: function set(image) {
        image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
      }
    }, {
      key: "imageLoadSuccess",
      value: function imageLoadSuccess(url, image, cb) {
        var _this2 = this;
        _get(_getPrototypeOf(Image.prototype), "imageLoadSuccess", this).call(this, url, image, function () {
          _this2.successCallback && _this2.successCallback();
        });
      }
    }, {
      key: "imageLoadFail",
      value: function imageLoadFail(url, cb) {
        var _this3 = this;
        _get(_getPrototypeOf(Image.prototype), "imageLoadFail", this).call(this, url, function () {
          _this3.failCallback && _this3.failCallback();
        });
      }
    }, {
      key: "setAttributes",
      value: function setAttributes(params, forceUpdateTag, context) {
        return params.image && this.loadImage(params.image), _get(_getPrototypeOf(Image.prototype), "setAttributes", this).call(this, params, forceUpdateTag, context);
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(key, value, forceUpdateTag, context) {
        return "image" === key && this.loadImage(value), _get(_getPrototypeOf(Image.prototype), "setAttribute", this).call(this, key, value, forceUpdateTag, context);
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var imageTheme = getTheme(this).image;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateImageAABBBounds(attribute, getTheme(this).image, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? imageTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return DefaultImageAttribute[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(Image.prototype), "needUpdateTags", this).call(this, keys, IMAGE_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(Image.prototype), "needUpdateTag", this).call(this, key, IMAGE_UPDATE_TAG_KEY);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Image(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Image.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Image;
  }(Graphic);
  Image.NOWORK_ANIMATE_ATTR = Object.assign({
    image: 1,
    repeatX: 1,
    repeatY: 1
  }, NOWORK_ANIMATE_ATTR);
  function createImage(attributes) {
    return new Image(attributes);
  }

  var RichTextIcon = /*#__PURE__*/function (_Image) {
    _inherits(RichTextIcon, _Image);
    var _super = _createSuper(RichTextIcon);
    function RichTextIcon(params) {
      var _this;
      _classCallCheck(this, RichTextIcon);
      if (_this = _super.call(this, params), _this._x = 0, _this._y = 0, _this._hovered = !1, _this._marginArray = [0, 0, 0, 0], "always" === params.backgroundShowMode && (_this._hovered = !0), params.margin) {
        var marginArray = parsePadding(params.margin);
        _this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
      }
      _this.onBeforeAttributeUpdate = function (val, attributes, key) {
        if (isArray$1(key) && -1 !== key.indexOf("margin") || "margin" === key) if (attributes.margin) {
          var _marginArray = parsePadding(attributes.margin);
          _this._marginArray = "number" == typeof _marginArray ? [_marginArray, _marginArray, _marginArray, _marginArray] : _marginArray;
        } else _this._marginArray = [0, 0, 0, 0];
      };
      return _possibleConstructorReturn(_this);
    }
    _createClass(RichTextIcon, [{
      key: "width",
      get: function get() {
        var _a;
        return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
      }
    }, {
      key: "height",
      get: function get() {
        var _a;
        return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
      }
    }, {
      key: "tryUpdateAABBBounds",
      value: function tryUpdateAABBBounds() {
        if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
        this.doUpdateAABBBounds();
        var _this$attribute = this.attribute,
          _this$attribute$width = _this$attribute.width,
          width = _this$attribute$width === void 0 ? DefaultImageAttribute.width : _this$attribute$width,
          _this$attribute$heigh = _this$attribute.height,
          height = _this$attribute$heigh === void 0 ? DefaultImageAttribute.height : _this$attribute$heigh,
          _this$attribute2 = this.attribute,
          _this$attribute2$back = _this$attribute2.backgroundWidth,
          backgroundWidth = _this$attribute2$back === void 0 ? width : _this$attribute2$back,
          _this$attribute2$back2 = _this$attribute2.backgroundHeight,
          backgroundHeight = _this$attribute2$back2 === void 0 ? height : _this$attribute2$back2,
          expandX = (backgroundWidth - width) / 2,
          expandY = (backgroundHeight - height) / 2;
        return this._AABBBounds.expand([0, 2 * expandX, 2 * expandY, 0]), this._AABBBounds;
      }
    }, {
      key: "setHoverState",
      value: function setHoverState(hovered) {
        "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
      }
    }]);
    return RichTextIcon;
  }(Image);

  var Line = /*#__PURE__*/function () {
    function Line(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
      var _this = this;
      _classCallCheck(this, Line);
      this.left = left, this.width = width, this.baseline = baseline, this.ascent = ascent, this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map(function (p) {
        return p;
      }), this.textAlign = (this.paragraphs[0] instanceof RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", this.direction = direction, this.directionKey = DIRECTION_KEY[this.direction], this.actualWidth = 0;
      var maxHeight = 0;
      this.paragraphs.forEach(function (word, index) {
        if (0 === index && word instanceof Paragraph) {
          var result = regFirstSpace.exec(word.text);
          0 !== (null == result ? void 0 : result.index) && (word.text = word.text.slice(null == result ? void 0 : result.index), word.updateWidth());
        }
        _this.actualWidth += word[_this.directionKey.width], maxHeight = Math.max(word[_this.directionKey.height], maxHeight);
      }), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, this.calcOffset(width, isWidthMax);
    }
    _createClass(Line, [{
      key: "calcOffset",
      value: function calcOffset(width, isWidthMax) {
        var directionKey = this.directionKey,
          maxHeight = this.height;
        var x = this.left,
          spacing = 0;
        this.actualWidth < width && !isWidthMax && ("right" === this.textAlign || "end" === this.textAlign ? x = width - this.actualWidth : "center" === this.textAlign ? x = (width - this.actualWidth) / 2 : "justify" === this.textAlign && (this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1))), this.paragraphs.map(function (paragraph) {
          paragraph instanceof RichTextIcon ? (paragraph["_" + directionKey.x] = x, x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, x += paragraph[directionKey.width] + spacing);
        });
      }
    }, {
      key: "draw",
      value: function draw(ctx, lastLine, x, y, drawIcon) {
        var _this2 = this;
        if (lastLine) {
          var otherParagraphWidth = 0;
          for (var i = this.paragraphs.length - 1; i >= 0; i--) {
            var paragraph = this.paragraphs[i];
            if (paragraph instanceof RichTextIcon) break;
            if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
              paragraph.verticalEllipsis = !0;
              break;
            }
            var _measureTextCanvas = measureTextCanvas("...", paragraph.character),
              width = _measureTextCanvas.width,
              ellipsisWidth = width || 0;
            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
              paragraph.ellipsis = "add";
              break;
            }
            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
              paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
              break;
            }
            paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
          }
        }
        this.paragraphs.map(function (paragraph, index) {
          if (paragraph instanceof RichTextIcon) return paragraph.setAttributes({
            x: x + paragraph._x,
            y: y + paragraph._y
          }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, _this2.ascent);
          paragraph.draw(ctx, y + _this2.ascent, x, 0 === index, _this2.textAlign);
        });
      }
    }, {
      key: "getWidthWithEllips",
      value: function getWidthWithEllips() {
        var _this3 = this;
        var otherParagraphWidth = 0;
        for (var i = this.paragraphs.length - 1; i >= 0; i--) {
          var paragraph = this.paragraphs[i];
          if (paragraph instanceof RichTextIcon) break;
          var _measureTextCanvas2 = measureTextCanvas("...", paragraph.character),
            _width = _measureTextCanvas2.width,
            ellipsisWidth = _width || 0;
          if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
            paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
            break;
          }
          if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
            paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
            break;
          }
          paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
        }
        var width = 0;
        return this.paragraphs.map(function (paragraph, index) {
          width += paragraph instanceof RichTextIcon ? paragraph.width : paragraph.getWidthWithEllips(_this3.direction);
        }), width;
      }
    }]);
    return Line;
  }();

  var Wrapper = /*#__PURE__*/function () {
    function Wrapper(frame) {
      _classCallCheck(this, Wrapper);
      this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, this.directionKey = DIRECTION_KEY[this.direction];
    }
    _createClass(Wrapper, [{
      key: "store",
      value: function store(paragraph) {
        if (paragraph instanceof RichTextIcon) {
          this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), this.lineWidth += paragraph[this.directionKey.width];
          var iconAscent = 0,
            iconDescent = 0;
          "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
        } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
      }
    }, {
      key: "send",
      value: function send() {
        if (0 === this.lineBuffer.length) return;
        var maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent,
          maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent,
          line = new Line(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
        this.frame.lines.push(line), this.frame.actualHeight += line.height, this.y += line.height, this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
      }
    }, {
      key: "deal",
      value: function deal(paragraph) {
        paragraph instanceof RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), 0 !== paragraph.text.length && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), this.deal(paragraph)) : this.cut(paragraph)));
      }
    }, {
      key: "cut",
      value: function cut(paragraph) {
        var availableWidth = this[this.directionKey.width] - this.lineWidth || 0,
          guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0,
          index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
        if (0 !== index) {
          var _seperateParagraph = seperateParagraph(paragraph, index),
            _seperateParagraph2 = _slicedToArray(_seperateParagraph, 2),
            p1 = _seperateParagraph2[0],
            p2 = _seperateParagraph2[1];
          this.store(p1), this.deal(p2);
        } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
      }
    }]);
    return Wrapper;
  }();

  var RICHTEXT_UPDATE_TAG_KEY = ["width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var RichText = /*#__PURE__*/function (_Graphic) {
    _inherits(RichText, _Graphic);
    var _super = _createSuper(RichText);
    function RichText(params) {
      var _this;
      _classCallCheck(this, RichText);
      _this = _super.call(this, params), _this.type = "richtext", _this._currentHoverIcon = null, _this.numberType = RICHTEXT_NUMBER_TYPE;
      return _this;
    }
    _createClass(RichText, [{
      key: "width",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : DefaultRichTextAttribute.width;
      },
      set: function set(w) {
        this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "height",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : DefaultRichTextAttribute.height;
      },
      set: function set(h) {
        this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "maxWidth",
      get: function get() {
        return this.attribute.maxWidth;
      },
      set: function set(mw) {
        this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "maxHeight",
      get: function get() {
        return this.attribute.maxHeight;
      },
      set: function set(mh) {
        this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "ellipsis",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : DefaultRichTextAttribute.ellipsis;
      },
      set: function set(e) {
        this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "wordBreak",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : DefaultRichTextAttribute.wordBreak;
      },
      set: function set(wb) {
        this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "verticalDirection",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : DefaultRichTextAttribute.verticalDirection;
      },
      set: function set(vd) {
        this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "textAlign",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : DefaultRichTextAttribute.textAlign;
      },
      set: function set(align) {
        this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "textBaseline",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : DefaultRichTextAttribute.textBaseline;
      },
      set: function set(baseline) {
        this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, this.addUpdateShapeAndBoundsTag());
      }
    }, {
      key: "textConfig",
      get: function get() {
        var _a;
        return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : DefaultRichTextAttribute.textConfig;
      },
      set: function set(config) {
        this.attribute.textConfig = config, this.addUpdateShapeAndBoundsTag();
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var richTextTheme = getTheme(this).richtext;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateRichTextAABBBounds(attribute, getTheme(this).richtext, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? richTextTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return DefaultRichTextAttribute[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(RichText.prototype), "needUpdateTags", this).call(this, keys, RICHTEXT_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(RichText.prototype), "needUpdateTag", this).call(this, key, RICHTEXT_UPDATE_TAG_KEY);
      }
    }, {
      key: "getFrameCache",
      value: function getFrameCache() {
        return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
      }
    }, {
      key: "combinedStyleToCharacter",
      value: function combinedStyleToCharacter(config) {
        var _this$attribute = this.attribute,
          fill = _this$attribute.fill,
          stroke = _this$attribute.stroke,
          fontSize = _this$attribute.fontSize,
          fontFamily = _this$attribute.fontFamily,
          fontStyle = _this$attribute.fontStyle,
          fontWeight = _this$attribute.fontWeight,
          lineWidth = _this$attribute.lineWidth;
        return Object.assign({
          fill: fill,
          stroke: stroke,
          fontSize: fontSize,
          fontFamily: fontFamily,
          fontStyle: fontStyle,
          fontWeight: fontWeight,
          lineWidth: lineWidth
        }, config);
      }
    }, {
      key: "doUpdateFrameCache",
      value: function doUpdateFrameCache() {
        var _this2 = this;
        var _a;
        var _this$attribute2 = this.attribute,
          _this$attribute2$text = _this$attribute2.textConfig,
          textConfig = _this$attribute2$text === void 0 ? [] : _this$attribute2$text,
          maxWidth = _this$attribute2.maxWidth,
          maxHeight = _this$attribute2.maxHeight,
          width = _this$attribute2.width,
          height = _this$attribute2.height,
          ellipsis = _this$attribute2.ellipsis,
          wordBreak = _this$attribute2.wordBreak,
          verticalDirection = _this$attribute2.verticalDirection,
          textAlign = _this$attribute2.textAlign,
          textBaseline = _this$attribute2.textBaseline,
          layoutDirection = _this$attribute2.layoutDirection,
          singleLine = _this$attribute2.singleLine,
          paragraphs = [];
        for (var i = 0; i < textConfig.length; i++) if ("image" in textConfig[i]) {
          var config = this.combinedStyleToCharacter(textConfig[i]),
            iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
          if (iconCache) paragraphs.push(iconCache);else {
            var icon = new RichTextIcon(config);
            icon.successCallback = function () {
              var _a;
              _this2.addUpdateBoundTag(), null === (_a = _this2.stage) || void 0 === _a || _a.renderNextFrame();
            }, icon.richtextId = config.id, paragraphs.push(icon);
          }
        } else {
          var richTextConfig = this.combinedStyleToCharacter(textConfig[i]);
          if (isNumber$1(richTextConfig.text) && (richTextConfig.text = "".concat(richTextConfig.text)), richTextConfig.text && richTextConfig.text.includes("\n")) {
            var textParts = richTextConfig.text.split("\n");
            for (var j = 0; j < textParts.length; j++) paragraphs.push(new Paragraph(textParts[j], 0 !== j, richTextConfig));
          } else richTextConfig.text && paragraphs.push(new Paragraph(richTextConfig.text, !1, richTextConfig));
        }
        var maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0,
          maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0,
          richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth),
          richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight),
          frame = new Frame(0, 0, (richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0) || 0, (richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0) || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || !1, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons),
          wrapper = new Wrapper(frame);
        for (var _i = 0; _i < paragraphs.length; _i++) wrapper.deal(paragraphs[_i]);
        wrapper.send();
        if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
          var frameSize = frame.getActualSizeWidthEllipsis();
          var offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
          ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), frame.lines.forEach(function (l) {
            l.calcOffset(offsetSize, !1);
          });
        }
        this._frameCache = frame;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new RichText(Object.assign({}, this.attribute));
      }
    }, {
      key: "setStage",
      value: function setStage(stage, layer) {
        _get(_getPrototypeOf(RichText.prototype), "setStage", this).call(this, stage, layer);
        this.getFrameCache().icons.forEach(function (icon) {
          icon.setStage(stage, layer);
        });
      }
    }, {
      key: "bindIconEvent",
      value: function bindIconEvent() {
        var _this3 = this;
        this.addEventListener("pointermove", function (e) {
          var _a, _b, _c, _d, _e;
          var pickedIcon = _this3.pickIcon(e.global);
          pickedIcon && pickedIcon === _this3._currentHoverIcon || (pickedIcon ? (null === (_a = _this3._currentHoverIcon) || void 0 === _a || _a.setHoverState(!1), _this3._currentHoverIcon = pickedIcon, _this3._currentHoverIcon.setHoverState(!0), null === (_b = _this3.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), null === (_c = _this3.stage) || void 0 === _c || _c.renderNextFrame()) : !pickedIcon && _this3._currentHoverIcon && (_this3._currentHoverIcon.setHoverState(!1), _this3._currentHoverIcon = null, null === (_d = _this3.stage) || void 0 === _d || _d.setCursor(), null === (_e = _this3.stage) || void 0 === _e || _e.renderNextFrame()));
        }), this.addEventListener("pointerleave", function (e) {
          var _a, _b;
          _this3._currentHoverIcon && (_this3._currentHoverIcon.setHoverState(!1), _this3._currentHoverIcon = null, null === (_a = _this3.stage) || void 0 === _a || _a.setCursor(), null === (_b = _this3.stage) || void 0 === _b || _b.renderNextFrame());
        });
      }
    }, {
      key: "pickIcon",
      value: function pickIcon(point) {
        var frameCache = this.getFrameCache(),
          _this$globalTransMatr = this.globalTransMatrix,
          x = _this$globalTransMatr.e,
          y = _this$globalTransMatr.f;
        var pickIcon;
        return frameCache.icons.forEach(function (icon) {
          var _a, _b;
          icon.AABBBounds.containsPoint({
            x: point.x - x,
            y: point.y - y
          }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x, pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y);
        }), pickIcon;
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return RichText.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return RichText;
  }(Graphic);
  RichText.NOWORK_ANIMATE_ATTR = Object.assign({
    ellipsis: 1,
    wordBreak: 1,
    verticalDirection: 1,
    textAlign: 1,
    textBaseline: 1,
    textConfig: 1,
    layoutDirection: 1
  }, NOWORK_ANIMATE_ATTR);
  function createRichText(attributes) {
    return new RichText(attributes);
  }

  var PATH_UPDATE_TAG_KEY = ["path", "customPath"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var Path = /*#__PURE__*/function (_Graphic) {
    _inherits(Path, _Graphic);
    var _super = _createSuper(Path);
    function Path(params) {
      var _this;
      _classCallCheck(this, Path);
      _this = _super.call(this, params), _this.type = "path", _this.numberType = PATH_NUMBER_TYPE;
      return _this;
    }
    _createClass(Path, [{
      key: "pathShape",
      get: function get() {
        return this.tryUpdateAABBBounds(), this.getParsedPathShape();
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return _get(_getPrototypeOf(Path.prototype), "isValid", this).call(this) && this._isValid();
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        var path = this.attribute.path;
        return null != path && "" !== path;
      }
    }, {
      key: "getParsedPathShape",
      value: function getParsedPathShape() {
        var pathTheme = getTheme(this).path;
        if (!this.valid) return pathTheme.path;
        var attribute = this.attribute;
        return attribute.path instanceof CustomPath2D ? attribute.path : (isNil$1(this.cache) && this.doUpdatePathShape(), this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var pathTheme = getTheme(this).path;
        this.doUpdatePathShape(), this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updatePathAABBBounds(attribute, getTheme(this).path, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? pathTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "doUpdatePathShape",
      value: function doUpdatePathShape() {
        var attribute = this.attribute;
        isString$1(attribute.path, !0) ? this.cache = new CustomPath2D().fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D(), attribute.customPath(this.cache, this));
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this).path[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(Path.prototype), "needUpdateTags", this).call(this, keys, PATH_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(Path.prototype), "needUpdateTag", this).call(this, key, PATH_UPDATE_TAG_KEY);
      }
    }, {
      key: "toCustomPath",
      value: function toCustomPath() {
        return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Path(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Path.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Path;
  }(Graphic);
  Path.NOWORK_ANIMATE_ATTR = Object.assign({
    path: 1,
    customPath: 1
  }, NOWORK_ANIMATE_ATTR);
  function createPath(attributes) {
    return new Path(attributes);
  }

  var AREA_UPDATE_TAG_KEY = ["segments", "points", "curveType"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var Area = /*#__PURE__*/function (_Graphic) {
    _inherits(Area, _Graphic);
    var _super = _createSuper(Area);
    function Area(params) {
      var _this;
      _classCallCheck(this, Area);
      _this = _super.call(this, params), _this.type = "area", _this.numberType = AREA_NUMBER_TYPE;
      return _this;
    }
    _createClass(Area, [{
      key: "isValid",
      value: function isValid() {
        return _get(_getPrototypeOf(Area.prototype), "isValid", this).call(this) && this._isValid();
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        if (this.pathProxy) return !0;
        var _this$attribute = this.attribute,
          points = _this$attribute.points,
          segments = _this$attribute.segments;
        return segments ? 0 !== segments.length : !!points && 0 !== points.length;
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var areaTheme = getTheme(this).area;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateAreaAABBBounds(attribute, getTheme(this).area, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? areaTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "_interpolate",
      value: function _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this).area[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(Area.prototype), "needUpdateTags", this).call(this, keys, AREA_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(Area.prototype), "needUpdateTag", this).call(this, key, AREA_UPDATE_TAG_KEY);
      }
    }, {
      key: "toCustomPath",
      value: function toCustomPath() {
        var path = new CustomPath2D(),
          attribute = this.attribute,
          segments = attribute.segments,
          parsePoints = function parsePoints(points) {
            if (points && points.length) {
              var isFirst = !0;
              var basePoints = [];
              if (points.forEach(function (point) {
                var _a, _b;
                !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), basePoints.push({
                  x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
                  y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
                }), isFirst = !1);
              }), basePoints.length) {
                for (var i = basePoints.length - 1; i >= 0; i--) path.lineTo(basePoints[i].x, basePoints[i].y);
                path.closePath();
              }
            }
          };
        return attribute.points ? parsePoints(attribute.points) : segments && segments.length && segments.forEach(function (seg) {
          parsePoints(seg.points);
        }), path;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Area(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Area.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Area;
  }(Graphic);
  Area.NOWORK_ANIMATE_ATTR = Object.assign({
    segments: 1,
    curveType: 1
  }, NOWORK_ANIMATE_ATTR);
  function createArea(attributes) {
    return new Area(attributes);
  }

  var ARC_UPDATE_TAG_KEY = ["innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var Arc = /*#__PURE__*/function (_Graphic) {
    _inherits(Arc, _Graphic);
    var _super = _createSuper(Arc);
    function Arc(params) {
      var _this;
      _classCallCheck(this, Arc);
      _this = _super.call(this, params), _this.type = "arc", _this.numberType = ARC_NUMBER_TYPE;
      return _this;
    }
    _createClass(Arc, [{
      key: "isValid",
      value: function isValid() {
        return _get(_getPrototypeOf(Arc.prototype), "isValid", this).call(this) && this._isValid();
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        var _this$attribute = this.attribute,
          startAngle = _this$attribute.startAngle,
          endAngle = _this$attribute.endAngle,
          outerRadius = _this$attribute.outerRadius,
          innerRadius = _this$attribute.innerRadius;
        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
      }
    }, {
      key: "getParsedCornerRadius",
      value: function getParsedCornerRadius() {
        var arcTheme = getTheme(this).arc,
          _this$attribute2 = this.attribute,
          _this$attribute2$corn = _this$attribute2.cornerRadius,
          cornerRadius = _this$attribute2$corn === void 0 ? arcTheme.cornerRadius : _this$attribute2$corn,
          _this$attribute2$inne = _this$attribute2.innerPadding,
          innerPadding = _this$attribute2$inne === void 0 ? arcTheme.innerPadding : _this$attribute2$inne,
          _this$attribute2$oute = _this$attribute2.outerPadding,
          outerPadding = _this$attribute2$oute === void 0 ? arcTheme.outerPadding : _this$attribute2$oute;
        var _this$attribute3 = this.attribute,
          _this$attribute3$oute = _this$attribute3.outerRadius,
          outerRadius = _this$attribute3$oute === void 0 ? arcTheme.outerRadius : _this$attribute3$oute,
          _this$attribute3$inne = _this$attribute3.innerRadius,
          innerRadius = _this$attribute3$inne === void 0 ? arcTheme.innerRadius : _this$attribute3$inne;
        if (outerRadius += outerPadding, innerRadius -= innerPadding, 0 === cornerRadius || "0%" === cornerRadius) return 0;
        var deltaRadius = Math.abs(outerRadius - innerRadius);
        return Math.min(isNumber$1(cornerRadius, !0) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);
      }
    }, {
      key: "getParsedAngle",
      value: function getParsedAngle() {
        var arcTheme = getTheme(this).arc;
        var _this$attribute4 = this.attribute,
          _this$attribute4$star = _this$attribute4.startAngle,
          startAngle = _this$attribute4$star === void 0 ? arcTheme.startAngle : _this$attribute4$star,
          _this$attribute4$endA = _this$attribute4.endAngle,
          endAngle = _this$attribute4$endA === void 0 ? arcTheme.endAngle : _this$attribute4$endA;
        var _this$attribute$cap = this.attribute.cap,
          cap = _this$attribute$cap === void 0 ? arcTheme.cap : _this$attribute$cap,
          sign = endAngle - startAngle >= 0 ? 1 : -1,
          deltaAngle = endAngle - startAngle;
        if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, cap && abs(deltaAngle) < pi2 - epsilon) {
          var startCap = 1,
            endCap = 1;
          cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
          var _this$attribute5 = this.attribute,
            _this$attribute5$oute = _this$attribute5.outerRadius,
            outerRadius = _this$attribute5$oute === void 0 ? arcTheme.outerRadius : _this$attribute5$oute,
            _this$attribute5$inne = _this$attribute5.innerRadius,
            innerRadius = _this$attribute5$inne === void 0 ? arcTheme.innerRadius : _this$attribute5$inne;
          var _this$attribute6 = this.attribute,
            _this$attribute6$oute = _this$attribute6.outerPadding,
            outerPadding = _this$attribute6$oute === void 0 ? arcTheme.outerPadding : _this$attribute6$oute,
            _this$attribute6$inne = _this$attribute6.innerPadding,
            innerPadding = _this$attribute6$inne === void 0 ? arcTheme.innerPadding : _this$attribute6$inne;
          outerRadius += outerPadding, innerRadius -= innerPadding;
          var capWidth = Math.abs(outerRadius - innerRadius) / 2,
            capAngle = capWidth / outerRadius;
          if (capWidth > epsilon && outerRadius > epsilon) return {
            startAngle: startAngle - sign * capAngle * startCap,
            endAngle: endAngle + sign * capAngle * endCap,
            sc: sign * capAngle * startCap,
            ec: sign * capAngle * endCap
          };
        }
        return {
          startAngle: startAngle,
          endAngle: endAngle
        };
      }
    }, {
      key: "getParsePadAngle",
      value: function getParsePadAngle(startAngle, endAngle) {
        var arcTheme = getTheme(this).arc,
          _this$attribute7 = this.attribute,
          _this$attribute7$inne = _this$attribute7.innerPadding,
          innerPadding = _this$attribute7$inne === void 0 ? arcTheme.innerPadding : _this$attribute7$inne,
          _this$attribute7$oute = _this$attribute7.outerPadding,
          outerPadding = _this$attribute7$oute === void 0 ? arcTheme.outerPadding : _this$attribute7$oute,
          _this$attribute7$padA = _this$attribute7.padAngle,
          padAngle = _this$attribute7$padA === void 0 ? arcTheme.padAngle : _this$attribute7$padA;
        var _this$attribute8 = this.attribute,
          _this$attribute8$oute = _this$attribute8.outerRadius,
          outerRadius = _this$attribute8$oute === void 0 ? arcTheme.outerRadius : _this$attribute8$oute,
          _this$attribute8$inne = _this$attribute8.innerRadius,
          innerRadius = _this$attribute8$inne === void 0 ? arcTheme.innerRadius : _this$attribute8$inne;
        outerRadius += outerPadding, innerRadius -= innerPadding;
        var _this$attribute$padRa = this.attribute.padRadius,
          padRadius = _this$attribute$padRa === void 0 ? sqrt(outerRadius * outerRadius + innerRadius * innerRadius) : _this$attribute$padRa,
          deltaAngle = abs(endAngle - startAngle);
        var outerStartAngle = startAngle,
          outerEndAngle = endAngle,
          innerStartAngle = startAngle,
          innerEndAngle = endAngle;
        var halfPadAngle = padAngle / 2;
        var innerDeltaAngle = deltaAngle,
          outerDeltaAngle = deltaAngle;
        if (halfPadAngle > epsilon && padRadius > epsilon) {
          var sign = endAngle > startAngle ? 1 : -1;
          var p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)),
            p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
          return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign, innerStartAngle += p0, innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
            outerStartAngle: outerStartAngle,
            outerEndAngle: outerEndAngle,
            innerStartAngle: innerStartAngle,
            innerEndAngle: innerEndAngle,
            innerDeltaAngle: innerDeltaAngle,
            outerDeltaAngle: outerDeltaAngle
          };
        }
        return {
          outerStartAngle: outerStartAngle,
          outerEndAngle: outerEndAngle,
          innerStartAngle: innerStartAngle,
          innerEndAngle: innerEndAngle,
          innerDeltaAngle: innerDeltaAngle,
          outerDeltaAngle: outerDeltaAngle
        };
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds(full) {
        var arcTheme = getTheme(this).arc;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateArcAABBBounds(attribute, getTheme(this).arc, this._AABBBounds, full, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? arcTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(Arc.prototype), "needUpdateTags", this).call(this, keys, ARC_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(Arc.prototype), "needUpdateTag", this).call(this, key, ARC_UPDATE_TAG_KEY);
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this).arc[name];
      }
    }, {
      key: "toCustomPath",
      value: function toCustomPath() {
        var attribute = this.attribute,
          _this$getParsedAngle = this.getParsedAngle(),
          startAngle = _this$getParsedAngle.startAngle,
          endAngle = _this$getParsedAngle.endAngle;
        var innerRadius = attribute.innerRadius - (attribute.innerPadding || 0),
          outerRadius = attribute.outerRadius - (attribute.outerPadding || 0);
        var deltaAngle = abs(endAngle - startAngle),
          clockwise = endAngle > startAngle;
        if (outerRadius < innerRadius) {
          var temp = outerRadius;
          outerRadius = innerRadius, innerRadius = temp;
        }
        var path = new CustomPath2D();
        if (outerRadius <= epsilon) path.moveTo(0, 0);else if (deltaAngle >= pi2 - epsilon) path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise));else {
          var xors = outerRadius * cos(startAngle),
            yors = outerRadius * sin(startAngle),
            xire = innerRadius * cos(endAngle),
            yire = innerRadius * sin(endAngle);
          path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), path.closePath();
        }
        return path;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Arc(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Arc.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Arc;
  }(Graphic);
  Arc.NOWORK_ANIMATE_ATTR = Object.assign({
    cap: 1
  }, NOWORK_ANIMATE_ATTR);
  function createArc(attributes) {
    return new Arc(attributes);
  }

  var Arc3d = /*#__PURE__*/function (_Arc) {
    _inherits(Arc3d, _Arc);
    var _super = _createSuper(Arc3d);
    function Arc3d(params) {
      var _this;
      _classCallCheck(this, Arc3d);
      _this = _super.call(this, params), _this.type = "arc3d", _this.numberType = ARC3D_NUMBER_TYPE;
      return _this;
    }
    _createClass(Arc3d, [{
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var polygonTheme = getTheme(this).arc;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updateArc3dAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? polygonTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), this._AABBBounds;
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Arc3d.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Arc3d;
  }(Arc);
  Arc3d.NOWORK_ANIMATE_ATTR = Object.assign({
    cap: 1
  }, NOWORK_ANIMATE_ATTR);
  function createArc3d(attributes) {
    return new Arc3d(attributes);
  }

  var POLYGON_UPDATE_TAG_KEY = ["points", "cornerRadius"].concat(_toConsumableArray(GRAPHIC_UPDATE_TAG_KEY));
  var Polygon = /*#__PURE__*/function (_Graphic) {
    _inherits(Polygon, _Graphic);
    var _super = _createSuper(Polygon);
    function Polygon(params) {
      var _this;
      _classCallCheck(this, Polygon);
      _this = _super.call(this, params), _this.type = "polygon", _this.numberType = POLYGON_NUMBER_TYPE;
      return _this;
    }
    _createClass(Polygon, [{
      key: "isValid",
      value: function isValid() {
        return _get(_getPrototypeOf(Polygon.prototype), "isValid", this).call(this) && this._isValid();
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        var points = this.attribute.points;
        return points && points.length >= 2;
      }
    }, {
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var polygonTheme = getTheme(this).polygon;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updatePolygonAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? polygonTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), this._AABBBounds;
      }
    }, {
      key: "tryUpdateOBBBounds",
      value: function tryUpdateOBBBounds() {
        throw new Error("暂不支持");
      }
    }, {
      key: "_interpolate",
      value: function _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
      }
    }, {
      key: "getDefaultAttribute",
      value: function getDefaultAttribute(name) {
        return getTheme(this).polygon[name];
      }
    }, {
      key: "needUpdateTags",
      value: function needUpdateTags(keys) {
        return _get(_getPrototypeOf(Polygon.prototype), "needUpdateTags", this).call(this, keys, POLYGON_UPDATE_TAG_KEY);
      }
    }, {
      key: "needUpdateTag",
      value: function needUpdateTag(key) {
        return _get(_getPrototypeOf(Polygon.prototype), "needUpdateTag", this).call(this, key, POLYGON_UPDATE_TAG_KEY);
      }
    }, {
      key: "toCustomPath",
      value: function toCustomPath() {
        var points = this.attribute.points,
          path = new CustomPath2D();
        return points.forEach(function (point, index) {
          0 === index ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y);
        }), path.closePath(), path;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Polygon(Object.assign({}, this.attribute));
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Polygon.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Polygon;
  }(Graphic);
  Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
  function createPolygon(attributes) {
    return new Polygon(attributes);
  }

  var Pyramid3d = /*#__PURE__*/function (_Polygon) {
    _inherits(Pyramid3d, _Polygon);
    var _super = _createSuper(Pyramid3d);
    function Pyramid3d(params) {
      var _this;
      _classCallCheck(this, Pyramid3d);
      _this = _super.call(this, params), _this.type = "pyramid3d", _this.numberType = PYRAMID3D_NUMBER_TYPE;
      return _this;
    }
    _createClass(Pyramid3d, [{
      key: "doUpdateAABBBounds",
      value: function doUpdateAABBBounds() {
        var polygonTheme = getTheme(this).polygon;
        this._AABBBounds.clear();
        var attribute = this.attribute,
          bounds = application.graphicService.updatePyramid3dAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this),
          _attribute$boundsPadd = attribute.boundsPadding,
          boundsPadding = _attribute$boundsPadd === void 0 ? polygonTheme.boundsPadding : _attribute$boundsPadd,
          paddingArray = parsePadding(boundsPadding);
        return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), this._AABBBounds;
      }
    }, {
      key: "findFace",
      value: function findFace() {
        var points = this.attribute.points,
          kList = points.map(function (p, i) {
            var p1 = 3 === i ? points[0] : points[i + 1],
              dx = p.x - p1.x;
            return 0 === dx ? 0 : (p.y - p1.y) / dx;
          }),
          pointsMap = points.map(function (p) {
            return {
              p: p,
              d: 0
            };
          });
        var find = !1,
          maxD = 0;
        for (var i = 0; i < kList.length - 1; i++) {
          for (var j = i + 1; j < kList.length; j++) {
            if (kList[i] === kList[j]) {
              find = !0;
              var d1 = PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
              pointsMap[i].d = d1, pointsMap[i + 1].d = d1, maxD = max(maxD, d1);
              var d2 = PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
              pointsMap[j].d = d2, pointsMap[j + 1].d = d2, maxD = max(maxD, d2);
            }
            if (find) break;
          }
          if (find) break;
        }
        for (var _i = points.length - 1; _i >= 0; _i--) {
          var p = points[_i];
          pointsMap.unshift({
            p: p,
            d: 0
          });
        }
        for (var _i2 = 0; _i2 < points.length; _i2++) {
          var delta = (maxD - pointsMap[_i2 + points.length].d) / 2;
          pointsMap[_i2].d += delta, pointsMap[_i2 + points.length].d += delta;
        }
        var faces = {
          polygons: [],
          vertices: [],
          edges: []
        };
        return pointsMap.forEach(function (p) {
          faces.vertices.push([p.p.x, p.p.y, p.d]);
        }), faces.polygons.push({
          polygon: [0, 4, 5, 1],
          normal: [0, -1, 0]
        }), faces.polygons.push({
          polygon: [7, 6, 2, 3],
          normal: [0, 1, 0]
        }), faces.polygons.push({
          polygon: [0, 4, 7, 3],
          normal: [-1, 0, 0]
        }), faces.polygons.push({
          polygon: [1, 5, 6, 2],
          normal: [1, 0, 0]
        }), faces.polygons.push({
          polygon: [0, 1, 2, 3],
          normal: [0, 0, -1]
        }), faces.polygons.push({
          polygon: [4, 5, 6, 7],
          normal: [0, 0, 1]
        }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
      }
    }, {
      key: "_isValid",
      value: function _isValid() {
        return _get(_getPrototypeOf(Pyramid3d.prototype), "_isValid", this).call(this) && 4 === this.attribute.points.length;
      }
    }, {
      key: "getNoWorkAnimateAttr",
      value: function getNoWorkAnimateAttr() {
        return Pyramid3d.NOWORK_ANIMATE_ATTR;
      }
    }]);
    return Pyramid3d;
  }(Polygon);
  Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
  function createPyramid3d(attributes) {
    return new Pyramid3d(attributes);
  }

  var ShadowRoot = /*#__PURE__*/function (_Group) {
    _inherits(ShadowRoot, _Group);
    var _super = _createSuper(ShadowRoot);
    function ShadowRoot(graphic) {
      var _this;
      _classCallCheck(this, ShadowRoot);
      _this = _super.call(this, {
        x: 0,
        y: 0
      }), _this.type = "shadowroot", _this.shadowHost = graphic;
      return _this;
    }
    _createClass(ShadowRoot, [{
      key: "addUpdateBoundTag",
      value: function addUpdateBoundTag() {
        _get(_getPrototypeOf(ShadowRoot.prototype), "addUpdateBoundTag", this).call(this), this.shadowHost && this.shadowHost.addUpdateBoundTag();
      }
    }, {
      key: "addUpdateShapeAndBoundsTag",
      value: function addUpdateShapeAndBoundsTag() {
        _get(_getPrototypeOf(ShadowRoot.prototype), "addUpdateShapeAndBoundsTag", this).call(this), this.shadowHost && this.shadowHost.addUpdateBoundTag();
      }
    }, {
      key: "tryUpdateGlobalTransMatrix",
      value: function tryUpdateGlobalTransMatrix() {
        var clearTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        if (this.shouldUpdateGlobalMatrix()) {
          var m = this.transMatrix;
          this._globalTransMatrix ? this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f) : this._globalTransMatrix = m.clone(), this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
        }
        return this._globalTransMatrix;
      }
    }, {
      key: "doUpdateGlobalMatrix",
      value: function doUpdateGlobalMatrix() {
        if (this.shadowHost) {
          var parentMatrix = this.shadowHost.globalTransMatrix;
          this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
        }
      }
    }, {
      key: "tryUpdateGlobalAABBBounds",
      value: function tryUpdateGlobalAABBBounds() {
        return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), this._globalAABBBounds;
      }
    }]);
    return ShadowRoot;
  }(Group);
  function createShadowRoot(graphic) {
    return new ShadowRoot(graphic);
  }

  var DefaultOuterBorderBoundsContribution = /*#__PURE__*/function () {
    function DefaultOuterBorderBoundsContribution() {
      _classCallCheck(this, DefaultOuterBorderBoundsContribution);
    }
    _createClass(DefaultOuterBorderBoundsContribution, [{
      key: "updateBounds",
      value: function updateBounds(attribute, theme, aabbBounds, graphic) {
        var outerBorder = attribute.outerBorder,
          _attribute$shadowBlur = attribute.shadowBlur,
          shadowBlur = _attribute$shadowBlur === void 0 ? theme.shadowBlur : _attribute$shadowBlur;
        if (outerBorder) {
          var defaultOuterBorder = theme.outerBorder,
            _outerBorder$distance = outerBorder.distance,
            distance = _outerBorder$distance === void 0 ? defaultOuterBorder.distance : _outerBorder$distance,
            _outerBorder$lineWidt = outerBorder.lineWidth,
            lineWidth = _outerBorder$lineWidt === void 0 ? defaultOuterBorder.lineWidth : _outerBorder$lineWidt;
          aabbBounds.expand(distance + (shadowBlur + lineWidth) / 2);
        }
        return aabbBounds;
      }
    }]);
    return DefaultOuterBorderBoundsContribution;
  }();

  var DefaultSymbolOuterBorderBoundsContribution = /*#__PURE__*/function (_DefaultOuterBorderBo) {
    _inherits(DefaultSymbolOuterBorderBoundsContribution, _DefaultOuterBorderBo);
    var _super = _createSuper(DefaultSymbolOuterBorderBoundsContribution);
    function DefaultSymbolOuterBorderBoundsContribution() {
      _classCallCheck(this, DefaultSymbolOuterBorderBoundsContribution);
      return _super.apply(this, arguments);
    }
    _createClass(DefaultSymbolOuterBorderBoundsContribution, [{
      key: "updateBounds",
      value: function updateBounds(attribute, symbolTheme, aabbBounds, graphic) {
        var outerBorder = attribute.outerBorder,
          _attribute$shadowBlur = attribute.shadowBlur,
          shadowBlur = _attribute$shadowBlur === void 0 ? symbolTheme.shadowBlur : _attribute$shadowBlur,
          _attribute$strokeBoun = attribute.strokeBoundsBuffer,
          strokeBoundsBuffer = _attribute$strokeBoun === void 0 ? symbolTheme.strokeBoundsBuffer : _attribute$strokeBoun;
        if (outerBorder) {
          var defaultOuterBorder = symbolTheme.outerBorder,
            _outerBorder$distance = outerBorder.distance,
            distance = _outerBorder$distance === void 0 ? defaultOuterBorder.distance : _outerBorder$distance,
            _outerBorder$lineWidt = outerBorder.lineWidth,
            lineWidth = _outerBorder$lineWidt === void 0 ? defaultOuterBorder.lineWidth : _outerBorder$lineWidt;
          boundStroke(aabbBounds, distance + (shadowBlur + lineWidth) / 2, !0, strokeBoundsBuffer);
        }
        return aabbBounds;
      }
    }]);
    return DefaultSymbolOuterBorderBoundsContribution;
  }(DefaultOuterBorderBoundsContribution);

  var MatrixAllocate = Symbol["for"]("MatrixAllocate");
  var Mat4Allocate = Symbol["for"]("Mat4Allocate");
  function createMat4() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  var DefaultMatrixAllocate = /*#__PURE__*/function () {
    function DefaultMatrixAllocate() {
      _classCallCheck(this, DefaultMatrixAllocate);
      this.pools = [];
    }
    _createClass(DefaultMatrixAllocate, [{
      key: "allocate",
      value: function allocate(a, b, c, d, e, f) {
        if (!this.pools.length) return new Matrix(a, b, c, d, e, f);
        var m = this.pools.pop();
        return m.a = a, m.b = b, m.c = c, m.d = d, m.e = e, m.f = f, m;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(matrix) {
        if (!this.pools.length) return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
        var m = this.pools.pop();
        return m.a = matrix.a, m.b = matrix.b, m.c = matrix.c, m.d = matrix.d, m.e = matrix.e, m.f = matrix.f, m;
      }
    }, {
      key: "free",
      value: function free(d) {
        this.pools.push(d);
      }
    }, {
      key: "length",
      get: function get() {
        return this.pools.length;
      }
    }, {
      key: "release",
      value: function release() {
        this.pools = [];
      }
    }]);
    return DefaultMatrixAllocate;
  }();
  var DefaultMat4Allocate = /*#__PURE__*/function () {
    function DefaultMat4Allocate() {
      _classCallCheck(this, DefaultMat4Allocate);
      this.pools = [];
    }
    _createClass(DefaultMat4Allocate, [{
      key: "allocate",
      value: function allocate() {
        if (!this.pools.length) return createMat4();
        var m = this.pools.pop();
        return DefaultMat4Allocate.identity(m), m;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(d) {
        var m;
        m = this.pools.length ? this.pools.pop() : createMat4();
        for (var i = 0; i < m.length; i++) m[i] = d[i];
        return m;
      }
    }, {
      key: "free",
      value: function free(m) {
        m && this.pools.push(m);
      }
    }, {
      key: "length",
      get: function get() {
        return this.pools.length;
      }
    }, {
      key: "release",
      value: function release() {
        this.pools = [];
      }
    }], [{
      key: "identity",
      value: function identity(out) {
        return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
      }
    }]);
    return DefaultMat4Allocate;
  }();
  var matrixAllocate = new DefaultMatrixAllocate();
  var mat4Allocate = new DefaultMat4Allocate();

  var __decorate$1B = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$1d = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$Q = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  function identity(out) {
    return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
  }
  function rotateX(out, a, rad) {
    var s = Math.sin(rad),
      c = Math.cos(rad),
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
    return a !== out && (out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[4] = a10 * c + a20 * s, out[5] = a11 * c + a21 * s, out[6] = a12 * c + a22 * s, out[7] = a13 * c + a23 * s, out[8] = a20 * c - a10 * s, out[9] = a21 * c - a11 * s, out[10] = a22 * c - a12 * s, out[11] = a23 * c - a13 * s, out;
  }
  function rotateY(out, a, rad) {
    var s = Math.sin(rad),
      c = Math.cos(rad),
      a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
    return a !== out && (out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c - a20 * s, out[1] = a01 * c - a21 * s, out[2] = a02 * c - a22 * s, out[3] = a03 * c - a23 * s, out[8] = a00 * s + a20 * c, out[9] = a01 * s + a21 * c, out[10] = a02 * s + a22 * c, out[11] = a03 * s + a23 * c, out;
  }
  function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
      c = Math.cos(rad),
      a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
    return a !== out && (out[8] = a[8], out[9] = a[9], out[10] = a[10], out[11] = a[11], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c + a10 * s, out[1] = a01 * c + a11 * s, out[2] = a02 * c + a12 * s, out[3] = a03 * c + a13 * s, out[4] = a10 * c - a00 * s, out[5] = a11 * c - a01 * s, out[6] = a12 * c - a02 * s, out[7] = a13 * c - a03 * s, out;
  }
  function translate(out, a, v) {
    var x = v[0],
      y = v[1],
      z = v[2];
    var a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
    return a === out ? (out[12] = a[0] * x + a[4] * y + a[8] * z + a[12], out[13] = a[1] * x + a[5] * y + a[9] * z + a[13], out[14] = a[2] * x + a[6] * y + a[10] * z + a[14], out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]) : (a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a[12], out[13] = a01 * x + a11 * y + a21 * z + a[13], out[14] = a02 * x + a12 * y + a22 * z + a[14], out[15] = a03 * x + a13 * y + a23 * z + a[15]), out;
  }
  function mat3Tomat4(out, b) {
    out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, out[13] = b.f, out[14] = 0, out[15] = 1;
  }
  function multiplyMat4Mat3(out, a, b) {
    var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11],
      a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
    var b0 = b.a,
      b1 = b.b,
      b2 = 0,
      b3 = 0;
    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b.c, b1 = b.d, b2 = 0, b3 = 0, out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = 0, b1 = 0, b2 = 1, b3 = 0, out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b.e, b1 = b.f, b2 = 0, b3 = 1, out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
  }
  function scale(out, a, v) {
    var x = v[0],
      y = v[1],
      z = v[2];
    return out[0] = a[0] * x, out[1] = a[1] * x, out[2] = a[2] * x, out[3] = a[3] * x, out[4] = a[4] * y, out[5] = a[5] * y, out[6] = a[6] * y, out[7] = a[7] * y, out[8] = a[8] * z, out[9] = a[9] * z, out[10] = a[10] * z, out[11] = a[11] * z, out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15], out;
  }
  function multiplyMat4Mat4(out, a, b) {
    var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11],
      a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
    var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
  }
  function getExtraModelMatrix(dx, dy, graphic) {
    var _graphic$attribute = graphic.attribute,
      alpha = _graphic$attribute.alpha,
      beta = _graphic$attribute.beta;
    if (!alpha && !beta) return null;
    var _graphic$attribute$an = graphic.attribute.anchor3d,
      anchor3d = _graphic$attribute$an === void 0 ? graphic.attribute.anchor : _graphic$attribute$an,
      _anchor = [0, 0];
    if (anchor3d) {
      if ("string" == typeof anchor3d[0]) {
        var ratio = parseFloat(anchor3d[0]) / 100,
          bounds = graphic.AABBBounds;
        _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor[0] = anchor3d[0];
      if ("string" == typeof anchor3d[1]) {
        var _ratio = parseFloat(anchor3d[1]) / 100,
          _bounds = graphic.AABBBounds;
        _anchor[1] = _bounds.x1 + (_bounds.x2 - _bounds.x1) * _ratio;
      } else _anchor[1] = anchor3d[1];
    }
    if ("text" === graphic.type) {
      var textAlign = graphic.attribute.textAlign;
      _anchor[0] += textDrawOffsetX(textAlign, graphic.clipedWidth);
    }
    _anchor[0] += dx, _anchor[1] += dy;
    var modelMatrix = mat4Allocate.allocate();
    return translate(modelMatrix, modelMatrix, [_anchor[0], _anchor[1], 0]), beta && rotateX(modelMatrix, modelMatrix, beta), alpha && rotateY(modelMatrix, modelMatrix, alpha), translate(modelMatrix, modelMatrix, [-_anchor[0], -_anchor[1], 0]), modelMatrix;
  }
  function getModelMatrix(out, graphic, theme) {
    var _a;
    var _graphic$attribute2 = graphic.attribute,
      _graphic$attribute2$x = _graphic$attribute2.x,
      x = _graphic$attribute2$x === void 0 ? theme.x : _graphic$attribute2$x,
      _graphic$attribute2$y = _graphic$attribute2.y,
      y = _graphic$attribute2$y === void 0 ? theme.y : _graphic$attribute2$y,
      _graphic$attribute2$z = _graphic$attribute2.z,
      z = _graphic$attribute2$z === void 0 ? theme.z : _graphic$attribute2$z,
      _graphic$attribute2$d = _graphic$attribute2.dx,
      dx = _graphic$attribute2$d === void 0 ? theme.dx : _graphic$attribute2$d,
      _graphic$attribute2$d2 = _graphic$attribute2.dy,
      dy = _graphic$attribute2$d2 === void 0 ? theme.dy : _graphic$attribute2$d2,
      _graphic$attribute2$d3 = _graphic$attribute2.dz,
      dz = _graphic$attribute2$d3 === void 0 ? theme.dz : _graphic$attribute2$d3,
      _graphic$attribute2$s = _graphic$attribute2.scaleX,
      scaleX = _graphic$attribute2$s === void 0 ? theme.scaleX : _graphic$attribute2$s,
      _graphic$attribute2$s2 = _graphic$attribute2.scaleY,
      scaleY = _graphic$attribute2$s2 === void 0 ? theme.scaleY : _graphic$attribute2$s2,
      _graphic$attribute2$s3 = _graphic$attribute2.scaleZ,
      scaleZ = _graphic$attribute2$s3 === void 0 ? theme.scaleZ : _graphic$attribute2$s3,
      _graphic$attribute2$a = _graphic$attribute2.alpha,
      alpha = _graphic$attribute2$a === void 0 ? theme.alpha : _graphic$attribute2$a,
      _graphic$attribute2$b = _graphic$attribute2.beta,
      beta = _graphic$attribute2$b === void 0 ? theme.beta : _graphic$attribute2$b,
      _graphic$attribute2$a2 = _graphic$attribute2.angle,
      angle = _graphic$attribute2$a2 === void 0 ? theme.angle : _graphic$attribute2$a2,
      _graphic$attribute2$a3 = _graphic$attribute2.anchor3d,
      anchor3d = _graphic$attribute2$a3 === void 0 ? graphic.attribute.anchor : _graphic$attribute2$a3,
      anchor = _graphic$attribute2.anchor,
      _anchor = [0, 0, 0];
    if (anchor3d) {
      if ("string" == typeof anchor3d[0]) {
        var ratio = parseFloat(anchor3d[0]) / 100,
          bounds = graphic.AABBBounds;
        _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor[0] = anchor3d[0];
      if ("string" == typeof anchor3d[1]) {
        var _ratio2 = parseFloat(anchor3d[1]) / 100,
          _bounds2 = graphic.AABBBounds;
        _anchor[1] = _bounds2.x1 + (_bounds2.x2 - _bounds2.x1) * _ratio2;
      } else _anchor[1] = anchor3d[1];
      _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
    }
    if (identity(out), translate(out, out, [x + dx, y + dy, z + dz]), translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]), rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]), scale(out, out, [scaleX, scaleY, scaleZ]), angle) {
      var m = mat4Allocate.allocate(),
        _anchor2 = [0, 0];
      if (anchor) {
        if ("string" == typeof anchor3d[0]) {
          var _ratio3 = parseFloat(anchor3d[0]) / 100,
            _bounds3 = graphic.AABBBounds;
          _anchor2[0] = _bounds3.x1 + (_bounds3.x2 - _bounds3.x1) * _ratio3;
        } else _anchor2[0] = anchor3d[0];
        if ("string" == typeof anchor3d[1]) {
          var _ratio4 = parseFloat(anchor3d[1]) / 100,
            _bounds4 = graphic.AABBBounds;
          _anchor2[1] = _bounds4.x1 + (_bounds4.x2 - _bounds4.x1) * _ratio4;
        } else _anchor2[1] = anchor3d[1];
      }
      translate(m, m, [_anchor2[0], _anchor2[1], 0]), rotateZ(m, m, angle), translate(m, m, [-_anchor2[0], -_anchor2[1], 0]), multiplyMat4Mat4(out, out, m);
    }
  }
  function shouldUseMat4(graphic) {
    var _graphic$attribute3 = graphic.attribute,
      alpha = _graphic$attribute3.alpha,
      beta = _graphic$attribute3.beta;
    return alpha || beta;
  }
  exports.DefaultGraphicService = /*#__PURE__*/function () {
    function DefaultGraphicService(creator) {
      _classCallCheck(this, DefaultGraphicService);
      this.creator = creator, this.hooks = {
        onAttributeUpdate: new SyncHook(["graphic"]),
        onSetStage: new SyncHook(["graphic", "stage"]),
        onRemove: new SyncHook(["graphic"]),
        onRelease: new SyncHook(["graphic"]),
        onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
        onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
        beforeUpdateAABBBounds: new SyncHook(["graphic", "stage", "willUpdate", "aabbBounds"]),
        afterUpdateAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange"])
      }, this.tempAABBBounds1 = new AABBBounds(), this.tempAABBBounds2 = new AABBBounds(), this._rectBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._symbolBoundsContribitions = [new DefaultSymbolOuterBorderBoundsContribution()], this._circleBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._arcBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._pathBoundsContribitions = [new DefaultOuterBorderBoundsContribution()];
    }
    _createClass(DefaultGraphicService, [{
      key: "onAttributeUpdate",
      value: function onAttributeUpdate(graphic) {
        this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
      }
    }, {
      key: "onSetStage",
      value: function onSetStage(graphic, stage) {
        this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
      }
    }, {
      key: "onRemove",
      value: function onRemove(graphic) {
        this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
      }
    }, {
      key: "onRelease",
      value: function onRelease(graphic) {
        this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
      }
    }, {
      key: "onAddIncremental",
      value: function onAddIncremental(graphic, group, stage) {
        this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
      }
    }, {
      key: "onClearIncremental",
      value: function onClearIncremental(group, stage) {
        this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
      }
    }, {
      key: "beforeUpdateAABBBounds",
      value: function beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
        this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
      }
    }, {
      key: "afterUpdateAABBBounds",
      value: function afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {
        this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);
      }
    }, {
      key: "updatePathProxyAABBBounds",
      value: function updatePathProxyAABBBounds(aabbBounds, graphic) {
        var path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
        if (!path) return !1;
        var boundsContext = new BoundsContext(aabbBounds);
        return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
      }
    }, {
      key: "updateRectAABBBounds",
      value: function updateRectAABBBounds(attribute, rectTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, rectTheme, aabbBounds, graphic)) return aabbBounds;
        if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
          var width = attribute.width,
            height = attribute.height;
          var x1 = attribute.x1,
            y1 = attribute.y1,
            x = attribute.x,
            y = attribute.y;
          width = null != width ? width : x1 - x, height = null != height ? height : y1 - y, aabbBounds.set(0, 0, width || 0, height || 0);
        }
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._rectBoundsContribitions.length && this._rectBoundsContribitions.forEach(function (c) {
          c.updateBounds(attribute, rectTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }), this.transformAABBBounds(attribute, aabbBounds, rectTheme, !1, graphic), aabbBounds;
      }
    }, {
      key: "updateGroupAABBBounds",
      value: function updateGroupAABBBounds(attribute, groupTheme, aabbBounds, graphic) {
        var width = attribute.width,
          height = attribute.height,
          path = attribute.path,
          _attribute$clip = attribute.clip,
          clip = _attribute$clip === void 0 ? groupTheme.clip : _attribute$clip;
        path && path.length ? path.forEach(function (g) {
          aabbBounds.union(g.AABBBounds);
        }) : null != width && null != height && aabbBounds.set(0, 0, width, height), clip || graphic.forEachChildren(function (node) {
          aabbBounds.union(node.AABBBounds);
        });
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, groupTheme, !1, graphic), aabbBounds;
      }
    }, {
      key: "updateGlyphAABBBounds",
      value: function updateGlyphAABBBounds(attribute, theme, aabbBounds, graphic) {
        return this._validCheck(attribute, theme, aabbBounds, graphic) ? (graphic.getSubGraphic().forEach(function (node) {
          aabbBounds.union(node.AABBBounds);
        }), aabbBounds) : aabbBounds;
      }
    }, {
      key: "updateRichTextAABBBounds",
      value: function updateRichTextAABBBounds(attribute, richtextTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, richtextTheme, aabbBounds, graphic)) return aabbBounds;
        if (!graphic) return aabbBounds;
        var _attribute$width = attribute.width,
          width = _attribute$width === void 0 ? richtextTheme.width : _attribute$width,
          _attribute$height = attribute.height,
          height = _attribute$height === void 0 ? richtextTheme.height : _attribute$height,
          _attribute$maxWidth = attribute.maxWidth,
          maxWidth = _attribute$maxWidth === void 0 ? richtextTheme.maxWidth : _attribute$maxWidth,
          _attribute$maxHeight = attribute.maxHeight,
          maxHeight = _attribute$maxHeight === void 0 ? richtextTheme.maxHeight : _attribute$maxHeight,
          _attribute$textAlign = attribute.textAlign,
          textAlign = _attribute$textAlign === void 0 ? richtextTheme.textAlign : _attribute$textAlign,
          _attribute$textBaseli = attribute.textBaseline,
          textBaseline = _attribute$textBaseli === void 0 ? richtextTheme.textBaseline : _attribute$textBaseli;
        if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height);else {
          var frameCache = graphic.getFrameCache(),
            _frameCache$getActual = frameCache.getActualSize(),
            actualWidth = _frameCache$getActual.width,
            actualHeight = _frameCache$getActual.height;
          var contentWidth = width || actualWidth || 0,
            contentHeight = height || actualHeight || 0;
          contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, aabbBounds.set(0, 0, contentWidth, contentHeight);
        }
        var deltaY = 0;
        switch (textBaseline) {
          case "top":
            deltaY = 0;
            break;
          case "middle":
            deltaY = -aabbBounds.height() / 2;
            break;
          case "bottom":
            deltaY = -aabbBounds.height();
        }
        var deltaX = 0;
        switch (textAlign) {
          case "left":
            deltaX = 0;
            break;
          case "center":
            deltaX = -aabbBounds.width() / 2;
            break;
          case "right":
            deltaX = -aabbBounds.width();
        }
        aabbBounds.translate(deltaX, deltaY);
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, richtextTheme, !1, graphic), aabbBounds;
      }
    }, {
      key: "updateTextAABBBounds",
      value: function updateTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, textTheme, aabbBounds, graphic)) return aabbBounds;
        if (!graphic) return aabbBounds;
        var _graphic$attribute$te = graphic.attribute.text,
          text = _graphic$attribute$te === void 0 ? textTheme.text : _graphic$attribute$te;
        Array.isArray(text) ? graphic.updateMultilineAABBBounds(text) : graphic.updateSingallineAABBBounds(text);
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        var _attribute$scaleX = attribute.scaleX,
          scaleX = _attribute$scaleX === void 0 ? textTheme.scaleX : _attribute$scaleX,
          _attribute$scaleY = attribute.scaleY,
          scaleY = _attribute$scaleY === void 0 ? textTheme.scaleY : _attribute$scaleY,
          _attribute$shadowBlur = attribute.shadowBlur,
          shadowBlur = _attribute$shadowBlur === void 0 ? textTheme.shadowBlur : _attribute$shadowBlur,
          _attribute$strokeBoun = attribute.strokeBoundsBuffer,
          strokeBoundsBuffer = _attribute$strokeBoun === void 0 ? textTheme.strokeBoundsBuffer : _attribute$strokeBoun;
        if (shadowBlur) {
          var shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
          boundStroke(tb1, shadowBlurHalfWidth, !0, strokeBoundsBuffer), aabbBounds.union(tb1);
        }
        return this.combindShadowAABBBounds(aabbBounds, graphic), transformBoundsWithMatrix(aabbBounds, aabbBounds, graphic.transMatrix), aabbBounds;
      }
    }, {
      key: "updatePathAABBBounds",
      value: function updatePathAABBBounds(attribute, pathTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, pathTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic);
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._pathBoundsContribitions.length && this._pathBoundsContribitions.forEach(function (c) {
          c.updateBounds(attribute, pathTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        });
        var _attribute$lineJoin = attribute.lineJoin,
          lineJoin = _attribute$lineJoin === void 0 ? pathTheme.lineJoin : _attribute$lineJoin;
        return this.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, graphic), aabbBounds;
      }
    }, {
      key: "updatePathAABBBoundsImprecise",
      value: function updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        var pathShape = graphic.getParsedPathShape();
        return aabbBounds.union(pathShape.getBounds()), aabbBounds;
      }
    }, {
      key: "updatePyramid3dAABBBounds",
      value: function updatePyramid3dAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        var stage = graphic.stage;
        if (!stage || !stage.camera) return aabbBounds;
        graphic.findFace().vertices.forEach(function (v) {
          var x = v[0],
            y = v[1];
          aabbBounds.add(x, y);
        });
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, polygonTheme, !1, graphic), aabbBounds;
      }
    }, {
      key: "updateArc3dAABBBounds",
      value: function updateArc3dAABBBounds(attribute, arcTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        var stage = graphic.stage;
        if (!stage || !stage.camera) return aabbBounds;
        var _attribute$outerRadiu = attribute.outerRadius,
          outerRadius = _attribute$outerRadiu === void 0 ? arcTheme.outerRadius : _attribute$outerRadiu,
          _attribute$height2 = attribute.height,
          height = _attribute$height2 === void 0 ? 0 : _attribute$height2,
          r = outerRadius + height;
        aabbBounds.setValue(-r, -r, r, r);
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, arcTheme, !1, graphic), aabbBounds;
      }
    }, {
      key: "updatePolygonAABBBounds",
      value: function updatePolygonAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, polygonTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic);
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        var _attribute$lineJoin2 = attribute.lineJoin,
          lineJoin = _attribute$lineJoin2 === void 0 ? polygonTheme.lineJoin : _attribute$lineJoin2;
        return this.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, graphic), aabbBounds;
      }
    }, {
      key: "updatePolygonAABBBoundsImprecise",
      value: function updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic) {
        var _attribute$points = attribute.points,
          points = _attribute$points === void 0 ? polygonTheme.points : _attribute$points;
        return points.forEach(function (p) {
          aabbBounds.add(p.x, p.y);
        }), aabbBounds;
      }
    }, {
      key: "updateLineAABBBounds",
      value: function updateLineAABBBounds(attribute, lineTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, lineTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic));
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        var _attribute$lineJoin3 = attribute.lineJoin,
          lineJoin = _attribute$lineJoin3 === void 0 ? lineTheme.lineJoin : _attribute$lineJoin3;
        return this.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, graphic), aabbBounds;
      }
    }, {
      key: "updateLineAABBBoundsByPoints",
      value: function updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
        var _attribute$points2 = attribute.points,
          points = _attribute$points2 === void 0 ? lineTheme.points : _attribute$points2,
          b = aabbBounds;
        return points.forEach(function (p) {
          b.add(p.x, p.y);
        }), b;
      }
    }, {
      key: "updateLineAABBBoundsBySegments",
      value: function updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
        var _attribute$segments = attribute.segments,
          segments = _attribute$segments === void 0 ? lineTheme.segments : _attribute$segments,
          b = aabbBounds;
        return segments.forEach(function (s) {
          s.points.forEach(function (p) {
            b.add(p.x, p.y);
          });
        }), b;
      }
    }, {
      key: "updateAreaAABBBounds",
      value: function updateAreaAABBBounds(attribute, areaTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, areaTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic));
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        var _attribute$lineJoin4 = attribute.lineJoin,
          lineJoin = _attribute$lineJoin4 === void 0 ? areaTheme.lineJoin : _attribute$lineJoin4;
        return this.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, graphic), aabbBounds;
      }
    }, {
      key: "updateAreaAABBBoundsByPoints",
      value: function updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
        var _attribute$points3 = attribute.points,
          points = _attribute$points3 === void 0 ? areaTheme.points : _attribute$points3,
          b = aabbBounds;
        return points.forEach(function (p) {
          var _a, _b;
          b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
        }), b;
      }
    }, {
      key: "updateAreaAABBBoundsBySegments",
      value: function updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
        var _attribute$segments2 = attribute.segments,
          segments = _attribute$segments2 === void 0 ? areaTheme.segments : _attribute$segments2,
          b = aabbBounds;
        return segments.forEach(function (s) {
          s.points.forEach(function (p) {
            var _a, _b;
            b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
          });
        }), b;
      }
    }, {
      key: "updateCircleAABBBounds",
      value: function updateCircleAABBBounds(attribute, circleTheme, aabbBounds, full, graphic) {
        if (!this._validCheck(attribute, circleTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic));
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._circleBoundsContribitions.length && this._circleBoundsContribitions.forEach(function (c) {
          c.updateBounds(attribute, circleTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        }), this.transformAABBBounds(attribute, aabbBounds, circleTheme, !1, graphic), aabbBounds;
      }
    }, {
      key: "updateCircleAABBBoundsImprecise",
      value: function updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) {
        var _attribute$radius = attribute.radius,
          radius = _attribute$radius === void 0 ? circleTheme.radius : _attribute$radius;
        return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
      }
    }, {
      key: "updateCircleAABBBoundsAccurate",
      value: function updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic) {
        var _attribute$startAngle = attribute.startAngle,
          startAngle = _attribute$startAngle === void 0 ? circleTheme.startAngle : _attribute$startAngle,
          _attribute$endAngle = attribute.endAngle,
          endAngle = _attribute$endAngle === void 0 ? circleTheme.endAngle : _attribute$endAngle,
          _attribute$radius2 = attribute.radius,
          radius = _attribute$radius2 === void 0 ? circleTheme.radius : _attribute$radius2;
        return endAngle - startAngle > pi2 - epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : circleBounds(startAngle, endAngle, radius, aabbBounds), aabbBounds;
      }
    }, {
      key: "updateArcAABBBounds",
      value: function updateArcAABBBounds(attribute, arcTheme, aabbBounds, full, graphic) {
        if (!this._validCheck(attribute, arcTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic));
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._arcBoundsContribitions.length && this._arcBoundsContribitions.forEach(function (c) {
          c.updateBounds(attribute, arcTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        });
        var _attribute$lineJoin5 = attribute.lineJoin,
          lineJoin = _attribute$lineJoin5 === void 0 ? arcTheme.lineJoin : _attribute$lineJoin5;
        return this.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, graphic), aabbBounds;
      }
    }, {
      key: "updateArcAABBBoundsImprecise",
      value: function updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) {
        var _attribute$outerRadiu2 = attribute.outerRadius,
          outerRadius = _attribute$outerRadiu2 === void 0 ? arcTheme.outerRadius : _attribute$outerRadiu2,
          _attribute$innerRadiu = attribute.innerRadius,
          innerRadius = _attribute$innerRadiu === void 0 ? arcTheme.innerRadius : _attribute$innerRadiu;
        var _attribute$outerPaddi = attribute.outerPadding,
          outerPadding = _attribute$outerPaddi === void 0 ? arcTheme.outerPadding : _attribute$outerPaddi,
          _attribute$innerPaddi = attribute.innerPadding,
          innerPadding = _attribute$innerPaddi === void 0 ? arcTheme.innerPadding : _attribute$innerPaddi;
        return outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
      }
    }, {
      key: "updateArcAABBBoundsAccurate",
      value: function updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic) {
        var _attribute$outerRadiu3 = attribute.outerRadius,
          outerRadius = _attribute$outerRadiu3 === void 0 ? arcTheme.outerRadius : _attribute$outerRadiu3,
          _attribute$innerRadiu2 = attribute.innerRadius,
          innerRadius = _attribute$innerRadiu2 === void 0 ? arcTheme.innerRadius : _attribute$innerRadiu2;
        var _attribute$outerPaddi2 = attribute.outerPadding,
          outerPadding = _attribute$outerPaddi2 === void 0 ? arcTheme.outerPadding : _attribute$outerPaddi2,
          _attribute$innerPaddi2 = attribute.innerPadding,
          innerPadding = _attribute$innerPaddi2 === void 0 ? arcTheme.innerPadding : _attribute$innerPaddi2;
        if (outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius) {
          var temp = outerRadius;
          outerRadius = innerRadius, innerRadius = temp;
        }
        var _attribute$endAngle2 = attribute.endAngle,
          endAngle = _attribute$endAngle2 === void 0 ? arcTheme.endAngle : _attribute$endAngle2,
          _attribute$startAngle2 = attribute.startAngle,
          startAngle = _attribute$startAngle2 === void 0 ? arcTheme.startAngle : _attribute$startAngle2;
        if (startAngle > endAngle) {
          var _temp = startAngle;
          startAngle = endAngle, endAngle = _temp;
        }
        return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
      }
    }, {
      key: "updateSymbolAABBBounds",
      value: function updateSymbolAABBBounds(attribute, symbolTheme, aabbBounds, full, graphic) {
        if (!this._validCheck(attribute, symbolTheme, aabbBounds, graphic)) return aabbBounds;
        this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic));
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._symbolBoundsContribitions.length && this._symbolBoundsContribitions.forEach(function (c) {
          c.updateBounds(attribute, symbolTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        });
        var _attribute$lineJoin6 = attribute.lineJoin,
          lineJoin = _attribute$lineJoin6 === void 0 ? symbolTheme.lineJoin : _attribute$lineJoin6;
        return this.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, graphic), aabbBounds;
      }
    }, {
      key: "updateSymbolAABBBoundsImprecise",
      value: function updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) {
        var _attribute$size = attribute.size,
          size = _attribute$size === void 0 ? symbolTheme.size : _attribute$size;
        if (isArray$1(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);else {
          var halfWH = size / 2;
          aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
        }
        return aabbBounds;
      }
    }, {
      key: "updateSymbolAABBBoundsAccurate",
      value: function updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic) {
        if (!graphic) return aabbBounds;
        var _attribute$size2 = attribute.size,
          size = _attribute$size2 === void 0 ? symbolTheme.size : _attribute$size2;
        return graphic.getParsedPath().bounds(size, aabbBounds), aabbBounds;
      }
    }, {
      key: "updateImageAABBBounds",
      value: function updateImageAABBBounds(attribute, imageTheme, aabbBounds, graphic) {
        if (!this._validCheck(attribute, imageTheme, aabbBounds, graphic)) return aabbBounds;
        if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
          var _attribute$width2 = attribute.width,
            width = _attribute$width2 === void 0 ? imageTheme.width : _attribute$width2,
            _attribute$height3 = attribute.height,
            height = _attribute$height3 === void 0 ? imageTheme.height : _attribute$height3;
          aabbBounds.set(0, 0, width, height);
        }
        var tb1 = this.tempAABBBounds1,
          tb2 = this.tempAABBBounds2;
        return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, imageTheme, !1, graphic), aabbBounds;
      }
    }, {
      key: "combindShadowAABBBounds",
      value: function combindShadowAABBBounds(bounds, graphic) {
        if (graphic && graphic.shadowRoot) {
          var b = graphic.shadowRoot.AABBBounds;
          bounds.union(b);
        }
      }
    }, {
      key: "transformAABBBounds",
      value: function transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {
        if (!aabbBounds.empty()) {
          var _attribute$scaleX2 = attribute.scaleX,
            scaleX = _attribute$scaleX2 === void 0 ? theme.scaleX : _attribute$scaleX2,
            _attribute$scaleY2 = attribute.scaleY,
            scaleY = _attribute$scaleY2 === void 0 ? theme.scaleY : _attribute$scaleY2,
            _attribute$stroke = attribute.stroke,
            stroke = _attribute$stroke === void 0 ? theme.stroke : _attribute$stroke,
            _attribute$shadowBlur2 = attribute.shadowBlur,
            shadowBlur = _attribute$shadowBlur2 === void 0 ? theme.shadowBlur : _attribute$shadowBlur2,
            _attribute$lineWidth = attribute.lineWidth,
            lineWidth = _attribute$lineWidth === void 0 ? theme.lineWidth : _attribute$lineWidth,
            _attribute$pickStroke = attribute.pickStrokeBuffer,
            pickStrokeBuffer = _attribute$pickStroke === void 0 ? theme.pickStrokeBuffer : _attribute$pickStroke,
            _attribute$strokeBoun2 = attribute.strokeBoundsBuffer,
            strokeBoundsBuffer = _attribute$strokeBoun2 === void 0 ? theme.strokeBoundsBuffer : _attribute$strokeBoun2,
            tb1 = this.tempAABBBounds1,
            tb2 = this.tempAABBBounds2;
          if (stroke && lineWidth) {
            var scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
            boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
          }
          if (shadowBlur) {
            var _attribute$shadowOffs = attribute.shadowOffsetX,
              shadowOffsetX = _attribute$shadowOffs === void 0 ? theme.shadowOffsetX : _attribute$shadowOffs,
              _attribute$shadowOffs2 = attribute.shadowOffsetY,
              shadowOffsetY = _attribute$shadowOffs2 === void 0 ? theme.shadowOffsetY : _attribute$shadowOffs2,
              shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
            boundStroke(tb1, shadowBlurWidth, !1, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), aabbBounds.union(tb1);
          }
        }
        if (this.combindShadowAABBBounds(aabbBounds, graphic), aabbBounds.empty()) return;
        var updateMatrix = !0;
        var m = graphic.transMatrix;
        graphic && graphic.isContainer && (updateMatrix = !(1 === m.a && 0 === m.b && 0 === m.c && 1 === m.d && 0 === m.e && 0 === m.f)), updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m);
      }
    }, {
      key: "_validCheck",
      value: function _validCheck(attribute, theme, aabbBounds, graphic) {
        if (!graphic) return !0;
        if (!graphic.valid) return aabbBounds.clear(), !1;
        var _attribute$visible = attribute.visible,
          visible = _attribute$visible === void 0 ? theme.visible : _attribute$visible;
        return !!visible || (aabbBounds.clear(), !1);
      }
    }]);
    return DefaultGraphicService;
  }();
  exports.DefaultGraphicService = __decorate$1B([injectable(), __param$Q(0, inject(GraphicCreator$1)), __metadata$1d("design:paramtypes", [Object])], exports.DefaultGraphicService);

  var GraphicCreator = /*#__PURE__*/function () {
    function GraphicCreator() {
      _classCallCheck(this, GraphicCreator);
      this.store = new Map();
    }
    _createClass(GraphicCreator, [{
      key: "RegisterGraphicCreator",
      value: function RegisterGraphicCreator(name, cb) {
        this.store.set(name, cb), this[name] = cb;
      }
    }, {
      key: "CreateGraphic",
      value: function CreateGraphic(name, params) {
        var cb = this.store.get(name);
        return cb ? cb(params) : null;
      }
    }]);
    return GraphicCreator;
  }();
  var graphicCreator = new GraphicCreator();

  var text, richText;
  function getTextBounds(params) {
    return text || (text = graphicCreator.CreateGraphic("text", {})), text.initAttributes(params), text.AABBBounds;
  }
  function getRichTextBounds(params) {
    return richText || (richText = graphicCreator.CreateGraphic("richtext", {})), richText.setAttributes(params), richText.AABBBounds;
  }

  var result = {
    x: 0,
    y: 0,
    z: 0,
    lastModelMatrix: null
  };
  var BaseRender = /*#__PURE__*/function () {
    function BaseRender() {
      _classCallCheck(this, BaseRender);
    }
    _createClass(BaseRender, [{
      key: "init",
      value: function init(contributions) {
        var _this = this;
        contributions && (this._renderContribitions = contributions.getContributions()), this._renderContribitions || (this._renderContribitions = []), this.builtinContributions && this.builtinContributions.forEach(function (item) {
          return _this._renderContribitions.push(item);
        }), this._renderContribitions.length && (this._renderContribitions.sort(function (a, b) {
          return b.order - a.order;
        }), this._beforeRenderContribitions = this._renderContribitions.filter(function (c) {
          return c.time === exports.BaseRenderContributionTime.beforeFillStroke;
        }), this._afterRenderContribitions = this._renderContribitions.filter(function (c) {
          return c.time === exports.BaseRenderContributionTime.afterFillStroke;
        }));
      }
    }, {
      key: "beforeRenderStep",
      value: function beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
        this._beforeRenderContribitions && this._beforeRenderContribitions.forEach(function (c) {
          c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
        });
      }
    }, {
      key: "afterRenderStep",
      value: function afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
        this._afterRenderContribitions && this._afterRenderContribitions.forEach(function (c) {
          c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
        });
      }
    }, {
      key: "valid",
      value: function valid(graphic, defaultAttribute, fillCb, strokeCb) {
        var _graphic$attribute = graphic.attribute,
          _graphic$attribute$fi = _graphic$attribute.fill,
          fill = _graphic$attribute$fi === void 0 ? defaultAttribute.fill : _graphic$attribute$fi,
          background = _graphic$attribute.background,
          _graphic$attribute$st = _graphic$attribute.stroke,
          stroke = _graphic$attribute$st === void 0 ? defaultAttribute.stroke : _graphic$attribute$st,
          _graphic$attribute$op = _graphic$attribute.opacity,
          opacity = _graphic$attribute$op === void 0 ? defaultAttribute.opacity : _graphic$attribute$op,
          _graphic$attribute$fi2 = _graphic$attribute.fillOpacity,
          fillOpacity = _graphic$attribute$fi2 === void 0 ? defaultAttribute.fillOpacity : _graphic$attribute$fi2,
          _graphic$attribute$li = _graphic$attribute.lineWidth,
          lineWidth = _graphic$attribute$li === void 0 ? defaultAttribute.lineWidth : _graphic$attribute$li,
          _graphic$attribute$st2 = _graphic$attribute.strokeOpacity,
          strokeOpacity = _graphic$attribute$st2 === void 0 ? defaultAttribute.strokeOpacity : _graphic$attribute$st2,
          _graphic$attribute$vi = _graphic$attribute.visible,
          visible = _graphic$attribute$vi === void 0 ? defaultAttribute.visible : _graphic$attribute$vi,
          fVisible = fillVisible(opacity, fillOpacity, fill),
          sVisible = strokeVisible(opacity, strokeOpacity),
          doFill = runFill(fill, background),
          doStroke = runStroke(stroke, lineWidth);
        return !(!graphic.valid || !visible) && !(!doFill && !doStroke) && !!(fVisible || sVisible || fillCb || strokeCb || background) && {
          fVisible: fVisible,
          sVisible: sVisible,
          doFill: doFill,
          doStroke: doStroke
        };
      }
    }, {
      key: "transform",
      value: function transform(graphic, graphicAttribute, context) {
        var use3dMatrixIn3dMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
        var _graphic$attribute2 = graphic.attribute,
          _graphic$attribute2$x = _graphic$attribute2.x,
          x = _graphic$attribute2$x === void 0 ? graphicAttribute.x : _graphic$attribute2$x,
          _graphic$attribute2$y = _graphic$attribute2.y,
          y = _graphic$attribute2$y === void 0 ? graphicAttribute.y : _graphic$attribute2$y,
          _graphic$attribute2$z = _graphic$attribute2.z,
          z = _graphic$attribute2$z === void 0 ? graphicAttribute.z : _graphic$attribute2$z,
          _graphic$attribute2$s = _graphic$attribute2.scaleX,
          scaleX = _graphic$attribute2$s === void 0 ? graphicAttribute.scaleX : _graphic$attribute2$s,
          _graphic$attribute2$s2 = _graphic$attribute2.scaleY,
          scaleY = _graphic$attribute2$s2 === void 0 ? graphicAttribute.scaleY : _graphic$attribute2$s2,
          _graphic$attribute2$a = _graphic$attribute2.angle,
          angle = _graphic$attribute2$a === void 0 ? graphicAttribute.angle : _graphic$attribute2$a,
          postMatrix = _graphic$attribute2.postMatrix,
          lastModelMatrix = context.modelMatrix,
          camera = context.camera;
        result.x = x, result.y = y, result.z = z, result.lastModelMatrix = lastModelMatrix;
        var shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic)),
          onlyTranslate = shouldTransform3d ? graphic.transMatrix.onlyTranslate() && !postMatrix : 1 === scaleX && 1 === scaleY && 0 === angle && !postMatrix;
        if (shouldTransform3d) {
          var nextModelMatrix = mat4Allocate.allocate(),
            modelMatrix = mat4Allocate.allocate();
          getModelMatrix(modelMatrix, graphic, graphicAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), result.x = 0, result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, !0), mat4Allocate.free(modelMatrix);
        }
        if (onlyTranslate && !lastModelMatrix) {
          var point = graphic.getOffsetXY(graphicAttribute);
          result.x += point.x, result.y += point.y, result.z = z, context.setTransformForCurrent();
        } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, !0);else if (camera && context.project) {
          var _point = graphic.getOffsetXY(graphicAttribute);
          result.x += _point.x, result.y += _point.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);
        } else context.transformFromMatrix(graphic.transMatrix, !0), result.x = 0, result.y = 0, result.z = 0;
        return result;
      }
    }, {
      key: "transformUseContext2d",
      value: function transformUseContext2d(graphic, graphicAttribute, z, context) {
        var camera = context.camera;
        if (this.camera = camera, camera) {
          var bounds = graphic.AABBBounds,
            width = bounds.x2 - bounds.x1,
            height = bounds.y2 - bounds.y1,
            p1 = context.project(0, 0, z),
            p2 = context.project(width, 0, z),
            p3 = context.project(width, height, z),
            _p1 = {
              x: 0,
              y: 0
            },
            _p2 = {
              x: width,
              y: 0
            },
            _p3 = {
              x: width,
              y: height
            };
          context.camera = null;
          var denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y),
            m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom,
            m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom,
            m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom,
            m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom,
            dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom,
            dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
          context.setTransform(m11, m12, m21, m22, dx, dy, !0);
        }
      }
    }, {
      key: "restoreTransformUseContext2d",
      value: function restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
        this.camera && (context.camera = this.camera);
      }
    }, {
      key: "transformWithoutTranslate",
      value: function transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle) {
        var p = context.project(x, y, z);
        context.translate(p.x, p.y, !1), context.scale(scaleX, scaleY, !1), context.rotate(angle, !1), context.translate(-p.x, -p.y, !1), context.setTransformForCurrent();
      }
    }, {
      key: "_draw",
      value: function _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params) {
        var context = drawContext.context;
        if (!context) return;
        context.highPerformanceSave();
        var data = this.transform(graphic, defaultAttr, context, computed3dMatrix),
          x = data.x,
          y = data.y,
          z = data.z,
          lastModelMatrix = data.lastModelMatrix;
        this.z = z, drawPathProxy(graphic, context, x, y, drawContext, params) || (this.drawShape(graphic, context, x, y, drawContext, params), this.z = 0, context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
      }
    }]);
    return BaseRender;
  }();

  var parse = function () {
    var tokens = {
      linearGradient: /^(linear\-gradient)/i,
      radialGradient: /^(radial\-gradient)/i,
      conicGradient: /^(conic\-gradient)/i,
      sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
      extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
      positionKeywords: /^(left|center|right|top|bottom)/i,
      pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
      percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
      emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
      angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
      fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
      startCall: /^\(/,
      endCall: /^\)/,
      comma: /^,/,
      hexColor: /(^\#[0-9a-fA-F]+)/,
      literalColor: /^([a-zA-Z]+)/,
      rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
      rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
      number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
    };
    var input = "";
    function error(msg) {
      var err = new Error(input + ": " + msg);
      throw err.source = input, err;
    }
    function getAST() {
      var ast = matchListing(matchDefinition);
      return input.length > 0 && error("Invalid input not EOF"), ast;
    }
    function matchDefinition() {
      return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
    }
    function matchGradient(gradientType, pattern, orientationMatcher) {
      return function (pattern, callback) {
        var captures = scan(pattern);
        if (captures) {
          scan(tokens.startCall) || error("Missing (");
          var result = callback(captures);
          return scan(tokens.endCall) || error("Missing )"), result;
        }
      }(pattern, function (captures) {
        var orientation = orientationMatcher();
        return orientation && (scan(tokens.comma) || error("Missing comma before color stops")), {
          type: gradientType,
          orientation: orientation,
          colorStops: matchListing(matchColorStop)
        };
      });
    }
    function matchLinearOrientation() {
      return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
    }
    function matchConicalOrientation() {
      return match("angular", tokens.fromAngleValue, 1);
    }
    function matchListRadialOrientations() {
      var radialOrientations,
        lookaheadCache,
        radialOrientation = matchRadialOrientation();
      return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), radialOrientations;
    }
    function matchRadialOrientation() {
      var radialType = function () {
        var circle = match("shape", /^(circle)/i, 0);
        circle && (circle.style = matchLength() || matchExtentKeyword());
        return circle;
      }() || function () {
        var ellipse = match("shape", /^(ellipse)/i, 0);
        ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
        return ellipse;
      }();
      if (radialType) radialType.at = matchAtPosition();else {
        var extent = matchExtentKeyword();
        if (extent) {
          radialType = extent;
          var positionAt = matchAtPosition();
          positionAt && (radialType.at = positionAt);
        } else {
          var defaultPosition = matchPositioning();
          defaultPosition && (radialType = {
            type: "default-radial",
            at: defaultPosition
          });
        }
      }
      return radialType;
    }
    function matchExtentKeyword() {
      return match("extent-keyword", tokens.extentKeywords, 1);
    }
    function matchAtPosition() {
      if (match("position", /^at/, 0)) {
        var positioning = matchPositioning();
        return positioning || error("Missing positioning value"), positioning;
      }
    }
    function matchPositioning() {
      var location = {
        x: matchDistance(),
        y: matchDistance()
      };
      if (location.x || location.y) return {
        type: "position",
        value: location
      };
    }
    function matchListing(matcher) {
      var captures = matcher();
      var result = [];
      if (captures) for (result.push(captures); scan(tokens.comma);) captures = matcher(), captures ? result.push(captures) : error("One extra comma");
      return result;
    }
    function matchColorStop() {
      var color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
      return color || error("Expected color definition"), color.length = matchDistance(), color;
    }
    function matchDistance() {
      return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
    }
    function matchLength() {
      return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
    }
    function match(type, pattern, captureIndex) {
      var captures = scan(pattern);
      if (captures) return {
        type: type,
        value: captures[captureIndex]
      };
    }
    function scan(regexp) {
      var blankCaptures = /^[\n\r\t\s]+/.exec(input);
      blankCaptures && consume(blankCaptures[0].length);
      var captures = regexp.exec(input);
      return captures && consume(captures[0].length), captures;
    }
    function consume(size) {
      input = input.substr(size);
    }
    return function (code) {
      return input = code.toString(), getAST();
    };
  }();
  var GradientParser = /*#__PURE__*/function () {
    function GradientParser() {
      _classCallCheck(this, GradientParser);
    }
    _createClass(GradientParser, null, [{
      key: "IsGradient",
      value: function IsGradient(c) {
        return !("string" == typeof c && !c.includes("gradient"));
      }
    }, {
      key: "IsGradientStr",
      value: function IsGradientStr(c) {
        return "string" == typeof c && c.includes("gradient");
      }
    }, {
      key: "Parse",
      value: function Parse(c) {
        if (GradientParser.IsGradientStr(c)) try {
          var datum = parse(c)[0];
          if (datum) {
            if ("linear" === datum.type) return GradientParser.ParseLinear(datum);
            if ("radial" === datum.type) return GradientParser.ParseRadial(datum);
            if ("conic" === datum.type) return GradientParser.ParseConic(datum);
          }
        } catch (err) {
          return c;
        }
        return c;
      }
    }, {
      key: "ParseConic",
      value: function ParseConic(datum) {
        var orientation = datum.orientation,
          _datum$colorStops = datum.colorStops,
          colorStops = _datum$colorStops === void 0 ? [] : _datum$colorStops,
          halfPi = pi / 2,
          sa = parseFloat(orientation.value) / 180 * pi - halfPi;
        return {
          gradient: "conical",
          x: .5,
          y: .5,
          startAngle: sa,
          endAngle: sa + pi2,
          stops: colorStops.map(function (item) {
            return {
              color: item.value,
              offset: parseFloat(item.length.value) / 100
            };
          })
        };
      }
    }, {
      key: "ParseRadial",
      value: function ParseRadial(datum) {
        var _datum$colorStops2 = datum.colorStops,
          colorStops = _datum$colorStops2 === void 0 ? [] : _datum$colorStops2;
        return {
          gradient: "radial",
          x0: .5,
          y0: .5,
          x1: .5,
          y1: .5,
          r0: 0,
          r1: 1,
          stops: colorStops.map(function (item) {
            return {
              color: item.value,
              offset: parseFloat(item.length.value) / 100
            };
          })
        };
      }
    }, {
      key: "ParseLinear",
      value: function ParseLinear(datum) {
        var orientation = datum.orientation,
          _datum$colorStops3 = datum.colorStops,
          colorStops = _datum$colorStops3 === void 0 ? [] : _datum$colorStops3,
          halfPi = pi / 2;
        var angle = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
        for (; angle < 0;) angle += pi2;
        for (; angle > pi2;) angle -= pi2;
        var x0 = 0,
          y0 = 0,
          x1 = 0,
          y1 = 0;
        return angle < halfPi ? (x0 = 0, y0 = 1, x1 = Math.sin(angle), y1 = Math.cos(angle)) : angle < pi ? (x0 = 0, y0 = 0, x1 = Math.cos(angle - halfPi), y1 = Math.sin(angle - halfPi)) : angle < pi + halfPi ? (x0 = 1, y0 = 0, x1 = x0 - Math.sin(angle - pi), y1 = Math.cos(angle - pi)) : (x0 = 1, x1 = x0 - Math.cos(angle - halfPi - pi), y1 -= Math.sin(angle - halfPi - pi)), {
          gradient: "linear",
          x0: x0,
          y0: y0,
          x1: x1,
          y1: y1,
          stops: colorStops.map(function (item) {
            return {
              color: item.value,
              offset: parseFloat(item.length.value) / 100
            };
          })
        };
      }
    }]);
    return GradientParser;
  }();

  function getScaledStroke(context, width, dpr) {
    var strokeWidth = width;
    var _context$currentMatri = context.currentMatrix,
      a = _context$currentMatri.a,
      b = _context$currentMatri.b,
      c = _context$currentMatri.c,
      d = _context$currentMatri.d,
      scaleX = Math.sign(a) * Math.sqrt(a * a + b * b),
      scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
    return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, strokeWidth);
  }
  function createColor(context, c, params, offsetX, offsetY) {
    if (!c || !0 === c) return "black";
    var result, color;
    if (isArray$1(c)) for (var i = 0; i < c.length && (color = c[i], !color); i++);else color = c;
    return color = GradientParser.Parse(color), "string" == typeof color ? color : ("linear" === color.gradient ? result = createLinearGradient(context, color, params, offsetX, offsetY) : "conical" === color.gradient ? result = createConicGradient(context, color, params, offsetX, offsetY) : "radial" === color.gradient && (result = createRadialGradient(context, color, params, offsetX, offsetY)), result || "orange");
  }
  function createLinearGradient(context, color, params) {
    var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var _a, _b, _c, _d;
    var bounds = params.AABBBounds;
    if (!bounds) return;
    var w = bounds.x2 - bounds.x1,
      h = bounds.y2 - bounds.y1,
      x = bounds.x1 - offsetX,
      y = bounds.y1 - offsetY;
    if (params.attribute) {
      var _params$attribute = params.attribute,
        _params$attribute$sca = _params$attribute.scaleX,
        scaleX = _params$attribute$sca === void 0 ? 1 : _params$attribute$sca,
        _params$attribute$sca2 = _params$attribute.scaleY,
        scaleY = _params$attribute$sca2 === void 0 ? 1 : _params$attribute$sca2;
      if (scaleX * scaleY == 0) return;
      w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;
    }
    var canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
    return color.stops.forEach(function (stop) {
      canvasGradient.addColorStop(stop.offset, stop.color);
    }), canvasGradient;
  }
  function createRadialGradient(context, color, params) {
    var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var _a, _b, _c, _d, _e, _f;
    var bounds = params.AABBBounds;
    if (!bounds) return;
    var w = bounds.x2 - bounds.x1,
      h = bounds.y2 - bounds.y1,
      x = bounds.x1 - offsetX,
      y = bounds.y1 - offsetY;
    if (params.attribute) {
      var _params$attribute2 = params.attribute,
        _params$attribute2$sc = _params$attribute2.scaleX,
        scaleX = _params$attribute2$sc === void 0 ? 1 : _params$attribute2$sc,
        _params$attribute2$sc2 = _params$attribute2.scaleY,
        scaleY = _params$attribute2$sc2 === void 0 ? 1 : _params$attribute2$sc2;
      if (scaleX * scaleY == 0) return;
      x /= scaleX, y /= scaleY, w /= scaleX, h /= scaleY;
    }
    var canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : .5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : .5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : .5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : .5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : .5));
    return color.stops.forEach(function (stop) {
      canvasGradient.addColorStop(stop.offset, stop.color);
    }), canvasGradient;
  }
  function createConicGradient(context, color, params) {
    var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var _a, _b;
    var bounds = params.AABBBounds;
    if (!bounds) return;
    var w = bounds.x2 - bounds.x1,
      h = bounds.y2 - bounds.y1,
      x = bounds.x1 - offsetX,
      y = bounds.y1 - offsetY;
    if (params.attribute) {
      var _params$attribute3 = params.attribute,
        _params$attribute3$sc = _params$attribute3.scaleX,
        scaleX = _params$attribute3$sc === void 0 ? 1 : _params$attribute3$sc,
        _params$attribute3$sc2 = _params$attribute3.scaleY,
        scaleY = _params$attribute3$sc2 === void 0 ? 1 : _params$attribute3$sc2;
      if (scaleX * scaleY == 0) return;
      w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;
    }
    var canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
    return color.stops.forEach(function (stop) {
      canvasGradient.addColorStop(stop.offset, stop.color);
    }), canvasGradient.GetPattern(w + x, h + y, undefined);
  }

  var __decorate$1A = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$1c = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$P = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultBaseBackgroundRenderContribution = /*#__PURE__*/function () {
    function DefaultBaseBackgroundRenderContribution() {
      _classCallCheck(this, DefaultBaseBackgroundRenderContribution);
      this.time = exports.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
    }
    _createClass(DefaultBaseBackgroundRenderContribution, [{
      key: "drawShape",
      value: function drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a;
        var _graphic$attribute = graphic.attribute,
          background = _graphic$attribute.background,
          _graphic$attribute$ba = _graphic$attribute.backgroundOpacity,
          backgroundOpacity = _graphic$attribute$ba === void 0 ? null !== (_a = graphic.attribute.fillOpacity) && void 0 !== _a ? _a : graphicAttribute.backgroundOpacity : _graphic$attribute$ba,
          _graphic$attribute$op = _graphic$attribute.opacity,
          opacity = _graphic$attribute$op === void 0 ? graphicAttribute.opacity : _graphic$attribute$op,
          _graphic$attribute$ba2 = _graphic$attribute.backgroundMode,
          backgroundMode = _graphic$attribute$ba2 === void 0 ? graphicAttribute.backgroundMode : _graphic$attribute$ba2,
          _graphic$attribute$ba3 = _graphic$attribute.backgroundFit,
          backgroundFit = _graphic$attribute$ba3 === void 0 ? graphicAttribute.backgroundFit : _graphic$attribute$ba3;
        if (background) if (graphic.backgroundImg && graphic.resources) {
          var res = graphic.resources.get(background);
          if ("success" !== res.state || !res.data) return;
          if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
            var groupAttribute = getTheme(graphic.parent).group,
              _graphic$parent$attri = graphic.parent.attribute,
              _graphic$parent$attri2 = _graphic$parent$attri.scrollX,
              scrollX = _graphic$parent$attri2 === void 0 ? groupAttribute.scrollX : _graphic$parent$attri2,
              _graphic$parent$attri3 = _graphic$parent$attri.scrollY,
              scrollY = _graphic$parent$attri3 === void 0 ? groupAttribute.scrollY : _graphic$parent$attri3;
            context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
          }
          context.clip();
          var b = graphic.AABBBounds;
          context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
        } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, context.fillStyle = background, context.fill(), context.highPerformanceRestore();
      }
    }, {
      key: "doDrawImage",
      value: function doDrawImage(context, data, b, backgroundMode, backgroundFit) {
        if ("no-repeat" === backgroundMode) context.drawImage(data, b.x1, b.y1, b.width(), b.height());else {
          var targetW = b.width(),
            targetH = b.height();
          var w = targetW,
            h = targetH;
          if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
            var resW = data.width,
              resH = data.height;
            if ("repeat-x" === backgroundMode) {
              w = resW * (targetH / resH), h = targetH;
            } else if ("repeat-y" === backgroundMode) {
              h = resH * (targetW / resW), w = targetW;
            }
            var _dpr = context.dpr,
              canvas = canvasAllocate.allocate({
                width: w,
                height: h,
                dpr: _dpr
              }),
              ctx = canvas.getContext("2d");
            ctx && (ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, w, h), ctx.drawImage(data, 0, 0, w, h), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
          }
          var dpr = context.dpr,
            pattern = context.createPattern(data, backgroundMode);
          pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), context.fillStyle = pattern, context.translate(b.x1, b.y1), context.fillRect(0, 0, targetW, targetH), context.translate(-b.x1, -b.y1);
        }
      }
    }]);
    return DefaultBaseBackgroundRenderContribution;
  }();
  var defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
  exports.DefaultBaseInteractiveRenderContribution = /*#__PURE__*/function () {
    function DefaultBaseInteractiveRenderContribution(subRenderContribitions) {
      _classCallCheck(this, DefaultBaseInteractiveRenderContribution);
      this.subRenderContribitions = subRenderContribitions, this.time = exports.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
    }
    _createClass(DefaultBaseInteractiveRenderContribution, [{
      key: "drawShape",
      value: function drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), this._subRenderContribitions.forEach(function (c) {
          c.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
        });
      }
    }]);
    return DefaultBaseInteractiveRenderContribution;
  }();
  exports.DefaultBaseInteractiveRenderContribution = __decorate$1A([injectable(), __param$P(0, inject(ContributionProvider)), __param$P(0, named(InteractiveSubRenderContribution)), __metadata$1c("design:paramtypes", [Object])], exports.DefaultBaseInteractiveRenderContribution);

  var DefaultBaseTextureRenderContribution = /*#__PURE__*/function () {
    function DefaultBaseTextureRenderContribution() {
      _classCallCheck(this, DefaultBaseTextureRenderContribution);
      this.time = exports.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 10;
    }
    _createClass(DefaultBaseTextureRenderContribution, [{
      key: "createCommonPattern",
      value: function createCommonPattern(size, padding, color, targetContext, cb) {
        var r = (size - 2 * padding) / 2,
          dpr = targetContext.dpr,
          canvas = canvasAllocate.allocate({
            width: size,
            height: size,
            dpr: dpr
          }),
          ctx = canvas.getContext("2d");
        if (!ctx) return null;
        ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, size, size), cb(r, ctx);
        var pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
        return pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), canvasAllocate.free(canvas), pattern;
      }
    }, {
      key: "createCirclePattern",
      value: function createCirclePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, function (r, ctx) {
          ctx.fillStyle = color, ctx.arc(r, r, r, 0, pi2), ctx.fill();
        });
      }
    }, {
      key: "createDiamondPattern",
      value: function createDiamondPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, function (r, ctx) {
          var x = size / 2,
            y = x;
          ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
        });
      }
    }, {
      key: "createRectPattern",
      value: function createRectPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, function (r, ctx) {
          var x = padding,
            y = x;
          ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
        });
      }
    }, {
      key: "createVerticalLinePattern",
      value: function createVerticalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, function (r, ctx) {
          var x = padding;
          ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
        });
      }
    }, {
      key: "createHorizontalLinePattern",
      value: function createHorizontalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, function (r, ctx) {
          var y = padding;
          ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
        });
      }
    }, {
      key: "createBiasLRLinePattern",
      value: function createBiasLRLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, function (r, ctx) {
          ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
          var dx = size / 2,
            dy = -dx;
          ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), ctx.stroke();
        });
      }
    }, {
      key: "createBiasRLLinePattern",
      value: function createBiasRLLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, function (r, ctx) {
          ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
          var dx = size / 2,
            dy = dx;
          ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), ctx.lineTo(-dx, -dy + size), ctx.stroke();
        });
      }
    }, {
      key: "createGridPattern",
      value: function createGridPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, function (r, ctx) {
          var x = padding,
            y = x;
          ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
        });
      }
    }, {
      key: "initTextureMap",
      value: function initTextureMap(ctx, stage) {
        this.textureMap = new Map();
      }
    }, {
      key: "drawShape",
      value: function drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        this.textureMap || this.initTextureMap(context, graphic.stage);
        var _graphic$attribute = graphic.attribute,
          _graphic$attribute$te = _graphic$attribute.texture,
          texture = _graphic$attribute$te === void 0 ? graphicAttribute.texture : _graphic$attribute$te,
          _graphic$attribute$te2 = _graphic$attribute.textureColor,
          textureColor = _graphic$attribute$te2 === void 0 ? graphicAttribute.textureColor : _graphic$attribute$te2,
          _graphic$attribute$te3 = _graphic$attribute.textureSize,
          textureSize = _graphic$attribute$te3 === void 0 ? graphicAttribute.textureSize : _graphic$attribute$te3,
          _graphic$attribute$te4 = _graphic$attribute.texturePadding,
          texturePadding = _graphic$attribute$te4 === void 0 ? graphicAttribute.texturePadding : _graphic$attribute$te4;
        texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
      }
    }, {
      key: "drawTexture",
      value: function drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
        var pattern = this.textureMap.get(texture);
        if (!pattern) switch (texture) {
          case "circle":
            pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "diamond":
            pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
            break;
          case "rect":
            pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
            break;
          case "vertical-line":
            pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "horizontal-line":
            pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "bias-lr":
            pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "bias-rl":
            pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
            break;
          case "grid":
            pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
        }
        pattern && (context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = pattern, context.fill(), context.highPerformanceRestore());
      }
    }]);
    return DefaultBaseTextureRenderContribution;
  }();
  var defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

  var DefaultArcRenderContribution = /*#__PURE__*/function () {
    function DefaultArcRenderContribution() {
      _classCallCheck(this, DefaultArcRenderContribution);
      this.time = exports.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
    }
    _createClass(DefaultArcRenderContribution, [{
      key: "drawShape",
      value: function drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
        var _arc$attribute = arc.attribute,
          outerBorder = _arc$attribute.outerBorder,
          innerBorder = _arc$attribute.innerBorder,
          doOuterBorder = outerBorder && !1 !== outerBorder.visible,
          doInnerBorder = innerBorder && !1 !== innerBorder.visible;
        if (!doOuterBorder && !doInnerBorder) return;
        var _arc$attribute2 = arc.attribute,
          _arc$attribute2$inner = _arc$attribute2.innerPadding,
          innerPadding = _arc$attribute2$inner === void 0 ? arcAttribute.innerPadding : _arc$attribute2$inner,
          _arc$attribute2$outer = _arc$attribute2.outerPadding,
          outerPadding = _arc$attribute2$outer === void 0 ? arcAttribute.outerPadding : _arc$attribute2$outer,
          _arc$attribute2$start = _arc$attribute2.startAngle,
          startAngle = _arc$attribute2$start === void 0 ? arcAttribute.startAngle : _arc$attribute2$start,
          _arc$attribute2$endAn = _arc$attribute2.endAngle,
          endAngle = _arc$attribute2$endAn === void 0 ? arcAttribute.endAngle : _arc$attribute2$endAn,
          _arc$attribute2$opaci = _arc$attribute2.opacity,
          opacity = _arc$attribute2$opaci === void 0 ? arcAttribute.opacity : _arc$attribute2$opaci,
          _arc$attribute2$x = _arc$attribute2.x,
          originX = _arc$attribute2$x === void 0 ? arcAttribute.x : _arc$attribute2$x,
          _arc$attribute2$y = _arc$attribute2.y,
          originY = _arc$attribute2$y === void 0 ? arcAttribute.y : _arc$attribute2$y,
          _arc$attribute2$scale = _arc$attribute2.scaleX,
          scaleX = _arc$attribute2$scale === void 0 ? arcAttribute.scaleX : _arc$attribute2$scale,
          _arc$attribute2$scale2 = _arc$attribute2.scaleY,
          scaleY = _arc$attribute2$scale2 === void 0 ? arcAttribute.scaleY : _arc$attribute2$scale2;
        var _arc$attribute3 = arc.attribute,
          _arc$attribute3$inner = _arc$attribute3.innerRadius,
          innerRadius = _arc$attribute3$inner === void 0 ? arcAttribute.innerRadius : _arc$attribute3$inner,
          _arc$attribute3$outer = _arc$attribute3.outerRadius,
          outerRadius = _arc$attribute3$outer === void 0 ? arcAttribute.outerRadius : _arc$attribute3$outer;
        outerRadius += outerPadding, innerRadius -= innerPadding;
        var doStrokeOuter = !(!outerBorder || !outerBorder.stroke),
          doStrokeInner = !(!innerBorder || !innerBorder.stroke);
        if (doOuterBorder) {
          var _outerBorder$distance = outerBorder.distance,
            distance = _outerBorder$distance === void 0 ? arcAttribute.outerBorder.distance : _outerBorder$distance,
            d = getScaledStroke(context, distance, context.dpr),
            deltaAngle = distance / outerRadius;
          if (arc.setAttributes({
            outerRadius: outerRadius + d,
            innerRadius: innerRadius - d,
            startAngle: startAngle - deltaAngle,
            endAngle: endAngle + deltaAngle
          }), context.beginPath(), drawArcPath$1(arc, context, x, y, outerRadius + d, innerRadius - d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, outerBorder, arcAttribute.outerBorder);else if (doStrokeOuter) {
            var lastOpacity = arcAttribute.outerBorder.opacity;
            arcAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(arc, outerBorder, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute.outerBorder), arcAttribute.outerBorder.opacity = lastOpacity, context.stroke();
          }
        }
        if (doInnerBorder) {
          var _innerBorder$distance = innerBorder.distance,
            _distance = _innerBorder$distance === void 0 ? arcAttribute.innerBorder.distance : _innerBorder$distance,
            _d = getScaledStroke(context, _distance, context.dpr),
            _deltaAngle = _distance / outerRadius;
          if (arc.setAttributes({
            outerRadius: outerRadius - _d,
            innerRadius: innerRadius + _d,
            startAngle: startAngle + _deltaAngle,
            endAngle: endAngle - _deltaAngle
          }), context.beginPath(), drawArcPath$1(arc, context, x, y, outerRadius - _d, innerRadius + _d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, innerBorder, arcAttribute.innerBorder);else if (doStrokeInner) {
            var _lastOpacity = arcAttribute.innerBorder.opacity;
            arcAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(arc, innerBorder, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute.innerBorder), arcAttribute.innerBorder.opacity = _lastOpacity, context.stroke();
          }
        }
        arc.setAttributes({
          outerRadius: outerRadius,
          innerRadius: innerRadius,
          startAngle: startAngle,
          endAngle: endAngle
        });
      }
    }]);
    return DefaultArcRenderContribution;
  }();
  var defaultArcRenderContribution = new DefaultArcRenderContribution();
  var defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
  var defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

  var DefaultCircleRenderContribution = /*#__PURE__*/function () {
    function DefaultCircleRenderContribution() {
      _classCallCheck(this, DefaultCircleRenderContribution);
      this.time = exports.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
    }
    _createClass(DefaultCircleRenderContribution, [{
      key: "drawShape",
      value: function drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb) {
        var _circle$attribute = circle.attribute,
          outerBorder = _circle$attribute.outerBorder,
          innerBorder = _circle$attribute.innerBorder,
          doOuterBorder = outerBorder && !1 !== outerBorder.visible,
          doInnerBorder = innerBorder && !1 !== innerBorder.visible;
        if (!doOuterBorder && !doInnerBorder) return;
        var _circle$attribute2 = circle.attribute,
          _circle$attribute2$ra = _circle$attribute2.radius,
          radius = _circle$attribute2$ra === void 0 ? circleAttribute.radius : _circle$attribute2$ra,
          _circle$attribute2$st = _circle$attribute2.startAngle,
          startAngle = _circle$attribute2$st === void 0 ? circleAttribute.startAngle : _circle$attribute2$st,
          _circle$attribute2$en = _circle$attribute2.endAngle,
          endAngle = _circle$attribute2$en === void 0 ? circleAttribute.endAngle : _circle$attribute2$en,
          _circle$attribute2$op = _circle$attribute2.opacity,
          opacity = _circle$attribute2$op === void 0 ? circleAttribute.opacity : _circle$attribute2$op,
          _circle$attribute2$x = _circle$attribute2.x,
          originX = _circle$attribute2$x === void 0 ? circleAttribute.x : _circle$attribute2$x,
          _circle$attribute2$y = _circle$attribute2.y,
          originY = _circle$attribute2$y === void 0 ? circleAttribute.y : _circle$attribute2$y,
          _circle$attribute2$sc = _circle$attribute2.scaleX,
          scaleX = _circle$attribute2$sc === void 0 ? circleAttribute.scaleX : _circle$attribute2$sc,
          _circle$attribute2$sc2 = _circle$attribute2.scaleY,
          scaleY = _circle$attribute2$sc2 === void 0 ? circleAttribute.scaleY : _circle$attribute2$sc2,
          doStrokeOuter = !(!outerBorder || !outerBorder.stroke),
          doStrokeInner = !(!innerBorder || !innerBorder.stroke);
        if (doOuterBorder) {
          var _outerBorder$distance = outerBorder.distance,
            distance = _outerBorder$distance === void 0 ? circleAttribute.outerBorder.distance : _outerBorder$distance,
            dw = getScaledStroke(context, distance, context.dpr);
          if (context.beginPath(), context.arc(x, y, radius + dw, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute), strokeCb) strokeCb(context, outerBorder, circleAttribute.outerBorder);else if (doStrokeOuter) {
            var lastOpacity = circleAttribute.outerBorder.opacity;
            circleAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(circle, outerBorder, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute.outerBorder), circleAttribute.outerBorder.opacity = lastOpacity, context.stroke();
          }
        }
        if (doInnerBorder) {
          var _innerBorder$distance = innerBorder.distance,
            _distance = _innerBorder$distance === void 0 ? circleAttribute.innerBorder.distance : _innerBorder$distance,
            _dw = getScaledStroke(context, _distance, context.dpr);
          if (context.beginPath(), context.arc(x, y, radius - _dw, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute), strokeCb) strokeCb(context, innerBorder, circleAttribute.innerBorder);else if (doStrokeInner) {
            var _lastOpacity = circleAttribute.innerBorder.opacity;
            circleAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(circle, innerBorder, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute.innerBorder), circleAttribute.innerBorder.opacity = _lastOpacity, context.stroke();
          }
        }
      }
    }]);
    return DefaultCircleRenderContribution;
  }();
  var defaultCircleRenderContribution = new DefaultCircleRenderContribution();
  var defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution;
  var defaultCircleBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

  var DefaultGroupBackgroundRenderContribution = /*#__PURE__*/function (_DefaultBaseBackgroun) {
    _inherits(DefaultGroupBackgroundRenderContribution, _DefaultBaseBackgroun);
    var _super = _createSuper(DefaultGroupBackgroundRenderContribution);
    function DefaultGroupBackgroundRenderContribution() {
      var _this;
      _classCallCheck(this, DefaultGroupBackgroundRenderContribution);
      _this = _super.apply(this, arguments), _this.time = exports.BaseRenderContributionTime.beforeFillStroke;
      return _this;
    }
    _createClass(DefaultGroupBackgroundRenderContribution, [{
      key: "drawShape",
      value: function drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        var _graphic$attribute = graphic.attribute,
          background = _graphic$attribute.background,
          _graphic$attribute$ba = _graphic$attribute.backgroundMode,
          backgroundMode = _graphic$attribute$ba === void 0 ? graphicAttribute.backgroundMode : _graphic$attribute$ba,
          _graphic$attribute$ba2 = _graphic$attribute.backgroundFit,
          backgroundFit = _graphic$attribute$ba2 === void 0 ? graphicAttribute.backgroundFit : _graphic$attribute$ba2;
        if (background) if (graphic.backgroundImg && graphic.resources) {
          var res = graphic.resources.get(background);
          if ("success" !== res.state || !res.data) return;
          context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0);
          var b = graphic.AABBBounds;
          this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.highPerformanceRestore(), context.setTransformForCurrent();
        } else context.highPerformanceSave(), context.fillStyle = background, context.fill(), context.highPerformanceRestore();
      }
    }]);
    return DefaultGroupBackgroundRenderContribution;
  }(DefaultBaseBackgroundRenderContribution);
  var defaultGroupBackgroundRenderContribution = new DefaultGroupBackgroundRenderContribution();

  var halfPi = pi / 2;
  function createRectPath(path, x, y, width, height, rectCornerRadius) {
    var cornerRadius;
    if (width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), isNumber$1(rectCornerRadius, !0)) cornerRadius = [rectCornerRadius = abs(rectCornerRadius), rectCornerRadius, rectCornerRadius, rectCornerRadius];else if (Array.isArray(rectCornerRadius)) {
      var cornerRadiusArr = rectCornerRadius;
      var cr0, cr1;
      switch (cornerRadiusArr.length) {
        case 0:
          cornerRadius = [0, 0, 0, 0];
          break;
        case 1:
          cr0 = abs(cornerRadiusArr[0]), cornerRadius = [cr0, cr0, cr0, cr0];
          break;
        case 2:
        case 3:
          cr0 = abs(cornerRadiusArr[0]), cr1 = abs(cornerRadiusArr[1]), cornerRadius = [cr0, cr1, cr0, cr1];
          break;
        default:
          cornerRadius = cornerRadiusArr, cornerRadius[0] = abs(cornerRadius[0]), cornerRadius[1] = abs(cornerRadius[1]), cornerRadius[2] = abs(cornerRadius[2]), cornerRadius[3] = abs(cornerRadius[3]);
      }
    } else cornerRadius = [0, 0, 0, 0];
    if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12) return path.rect(x, y, width, height);
    var leftTop = [x, y],
      rightTop = [x + width, y],
      rightBottom = [x + width, y + height],
      leftBottom = [x, y + height],
      maxCornerRadius = Math.min(width / 2, height / 2),
      _cornerRadius = [Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3])],
      leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]],
      leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]],
      rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]],
      rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]],
      rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]],
      rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]],
      leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]],
      leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
    if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), !arrayEqual(rightTopPoint1, rightTopPoint2)) {
      var centerX = rightTopPoint1[0],
        centerY = rightTopPoint1[1] + _cornerRadius[1];
      path.arc(centerX, centerY, _cornerRadius[1], -halfPi, 0, !1);
    }
    if (path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
      var _centerX = rightBottomPoint2[0] - _cornerRadius[2],
        _centerY = rightBottomPoint2[1];
      path.arc(_centerX, _centerY, _cornerRadius[2], 0, halfPi, !1);
    }
    if (path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
      var _centerX2 = leftBottomPoint1[0],
        _centerY2 = leftBottomPoint1[1] - _cornerRadius[3];
      path.arc(_centerX2, _centerY2, _cornerRadius[3], halfPi, pi, !1);
    }
    if (path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !arrayEqual(leftTopPoint1, leftTopPoint2)) {
      var _centerX3 = leftTopPoint1[0],
        _centerY3 = leftTopPoint1[1] + _cornerRadius[0];
      path.arc(_centerX3, _centerY3, _cornerRadius[0], pi, pi + halfPi, !1);
    }
    return path.closePath(), path;
  }

  var DefaultImageBackgroundRenderContribution = /*#__PURE__*/function (_DefaultBaseBackgroun) {
    _inherits(DefaultImageBackgroundRenderContribution, _DefaultBaseBackgroun);
    var _super = _createSuper(DefaultImageBackgroundRenderContribution);
    function DefaultImageBackgroundRenderContribution() {
      var _this;
      _classCallCheck(this, DefaultImageBackgroundRenderContribution);
      _this = _super.apply(this, arguments), _this.time = exports.BaseRenderContributionTime.beforeFillStroke;
      return _this;
    }
    _createClass(DefaultImageBackgroundRenderContribution, [{
      key: "drawShape",
      value: function drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        var _graphic$attribute = graphic.attribute,
          background = _graphic$attribute.background,
          _graphic$attribute$ba = _graphic$attribute.backgroundMode,
          backgroundMode = _graphic$attribute$ba === void 0 ? graphicAttribute.backgroundMode : _graphic$attribute$ba,
          _graphic$attribute$ba2 = _graphic$attribute.backgroundFit,
          backgroundFit = _graphic$attribute$ba2 === void 0 ? graphicAttribute.backgroundFit : _graphic$attribute$ba2;
        if (background) if (graphic.backgroundImg) {
          var res = graphic.resources.get(background);
          if ("success" !== res.state || !res.data) return;
          if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
            var groupAttribute = getTheme(graphic.parent).group,
              _graphic$parent$attri = graphic.parent.attribute,
              _graphic$parent$attri2 = _graphic$parent$attri.scrollX,
              scrollX = _graphic$parent$attri2 === void 0 ? groupAttribute.scrollX : _graphic$parent$attri2,
              _graphic$parent$attri3 = _graphic$parent$attri.scrollY,
              scrollY = _graphic$parent$attri3 === void 0 ? groupAttribute.scrollY : _graphic$parent$attri3;
            context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
          }
          var b = graphic.AABBBounds;
          this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
        } else if (isObject$1(background)) {
          var stroke = background.stroke,
            fill = background.fill,
            _background$lineWidth = background.lineWidth,
            lineWidth = _background$lineWidth === void 0 ? 1 : _background$lineWidth,
            _background$cornerRad = background.cornerRadius,
            cornerRadius = _background$cornerRad === void 0 ? 0 : _background$cornerRad,
            _background$expandX = background.expandX,
            expandX = _background$expandX === void 0 ? 0 : _background$expandX,
            _background$expandY = background.expandY,
            expandY = _background$expandY === void 0 ? 0 : _background$expandY;
          if (!stroke && !fill) return;
          context.beginPath();
          var _getActualPosition = getActualPosition(graphic),
            _x = _getActualPosition.x,
            _y = _getActualPosition.y,
            width = _getActualPosition.width,
            height = _getActualPosition.height;
          cornerRadius ? createRectPath(context, _x - expandX, _y - expandY, width + 2 * expandX, height + 2 * expandY, cornerRadius) : context.rect(_x - expandX, _y - expandY, width + 2 * expandX, height + 2 * expandY), context.globalAlpha = 1, fill && (context.fillStyle = fill, context.fill()), stroke && lineWidth > 0 && (context.lineWidth = lineWidth, context.strokeStyle = stroke, context.stroke());
        } else {
          context.beginPath();
          var _b = graphic.AABBBounds;
          context.rect(x, y, _b.width(), _b.height()), context.fillStyle = background, context.globalAlpha = 1, context.fill();
        }
      }
    }]);
    return DefaultImageBackgroundRenderContribution;
  }(DefaultBaseBackgroundRenderContribution);
  function getActualPosition(graphic) {
    var boundsPadding = parsePadding(graphic.attribute.boundsPadding),
      bounds = graphic.AABBBounds;
    var x = bounds.x1,
      y = bounds.y1,
      width = bounds.width(),
      height = bounds.height();
    return isNumber$1(boundsPadding) ? (x += boundsPadding, y += boundsPadding, width -= 2 * boundsPadding, height -= 2 * boundsPadding) : (x += boundsPadding[3], y += boundsPadding[0], width -= boundsPadding[1] + boundsPadding[3], height -= boundsPadding[0] + boundsPadding[2]), {
      x: x,
      y: y,
      width: width,
      height: height
    };
  }
  var defaultImageBackgroundRenderContribution = new DefaultImageBackgroundRenderContribution();

  var __decorate$1z = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultRectRenderContribution = /*#__PURE__*/function () {
    function DefaultRectRenderContribution() {
      _classCallCheck(this, DefaultRectRenderContribution);
      this.time = exports.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
    }
    _createClass(DefaultRectRenderContribution, [{
      key: "drawShape",
      value: function drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
        var _rect$attribute = rect.attribute,
          outerBorder = _rect$attribute.outerBorder,
          innerBorder = _rect$attribute.innerBorder,
          doOuterBorder = outerBorder && !1 !== outerBorder.visible,
          doInnerBorder = innerBorder && !1 !== innerBorder.visible;
        if (!doOuterBorder && !doInnerBorder) return;
        var _rect$attribute2 = rect.attribute,
          _rect$attribute2$corn = _rect$attribute2.cornerRadius,
          cornerRadius = _rect$attribute2$corn === void 0 ? rectAttribute.cornerRadius : _rect$attribute2$corn,
          _rect$attribute2$opac = _rect$attribute2.opacity,
          opacity = _rect$attribute2$opac === void 0 ? rectAttribute.opacity : _rect$attribute2$opac,
          _rect$attribute2$x = _rect$attribute2.x,
          originX = _rect$attribute2$x === void 0 ? rectAttribute.x : _rect$attribute2$x,
          _rect$attribute2$y = _rect$attribute2.y,
          originY = _rect$attribute2$y === void 0 ? rectAttribute.y : _rect$attribute2$y,
          _rect$attribute2$scal = _rect$attribute2.scaleX,
          scaleX = _rect$attribute2$scal === void 0 ? rectAttribute.scaleX : _rect$attribute2$scal,
          _rect$attribute2$scal2 = _rect$attribute2.scaleY,
          scaleY = _rect$attribute2$scal2 === void 0 ? rectAttribute.scaleY : _rect$attribute2$scal2,
          x1 = _rect$attribute2.x1,
          y1 = _rect$attribute2.y1;
        var _rect$attribute3 = rect.attribute,
          width = _rect$attribute3.width,
          height = _rect$attribute3.height;
        width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0;
        var doStrokeOuter = !(!outerBorder || !outerBorder.stroke),
          doStrokeInner = !(!innerBorder || !innerBorder.stroke);
        if (doOuterBorder) {
          var _outerBorder$distance = outerBorder.distance,
            distance = _outerBorder$distance === void 0 ? rectAttribute.outerBorder.distance : _outerBorder$distance,
            d = getScaledStroke(context, distance, context.dpr),
            nextX = x - d,
            nextY = y - d,
            dw = 2 * d;
          if (0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(function (num) {
            return 0 === num;
          }) ? (context.beginPath(), context.rect(nextX, nextY, width + dw, height + dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width + dw, height + dw, cornerRadius)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, outerBorder, rectAttribute.outerBorder);else if (doStrokeOuter) {
            var lastOpacity = rectAttribute.outerBorder.opacity;
            rectAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(rect, outerBorder, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute.outerBorder), rectAttribute.outerBorder.opacity = lastOpacity, context.stroke();
          }
        }
        if (doInnerBorder) {
          var _innerBorder$distance = innerBorder.distance,
            _distance = _innerBorder$distance === void 0 ? rectAttribute.innerBorder.distance : _innerBorder$distance,
            _d = getScaledStroke(context, _distance, context.dpr),
            _nextX = x + _d,
            _nextY = y + _d,
            _dw = 2 * _d;
          if (0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(function (num) {
            return 0 === num;
          }) ? (context.beginPath(), context.rect(_nextX, _nextY, width - _dw, height - _dw)) : (context.beginPath(), createRectPath(context, _nextX, _nextY, width - _dw, height - _dw, cornerRadius)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, innerBorder, rectAttribute.innerBorder);else if (doStrokeInner) {
            var _lastOpacity = rectAttribute.innerBorder.opacity;
            rectAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(rect, innerBorder, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute.innerBorder), rectAttribute.innerBorder.opacity = _lastOpacity, context.stroke();
          }
        }
      }
    }]);
    return DefaultRectRenderContribution;
  }();
  exports.SplitRectBeforeRenderContribution = /*#__PURE__*/function () {
    function SplitRectBeforeRenderContribution() {
      _classCallCheck(this, SplitRectBeforeRenderContribution);
      this.time = exports.BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
    }
    _createClass(SplitRectBeforeRenderContribution, [{
      key: "drawShape",
      value: function drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
        var _group$attribute$stro = group.attribute.stroke,
          stroke = _group$attribute$stro === void 0 ? groupAttribute.stroke : _group$attribute$stro;
        Array.isArray(stroke) && stroke.some(function (s) {
          return !1 === s;
        }) && (doFillOrStroke.doStroke = !1);
      }
    }]);
    return SplitRectBeforeRenderContribution;
  }();
  exports.SplitRectBeforeRenderContribution = __decorate$1z([injectable()], exports.SplitRectBeforeRenderContribution);
  exports.SplitRectAfterRenderContribution = /*#__PURE__*/function () {
    function SplitRectAfterRenderContribution() {
      _classCallCheck(this, SplitRectAfterRenderContribution);
      this.time = exports.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
    }
    _createClass(SplitRectAfterRenderContribution, [{
      key: "drawShape",
      value: function drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
        var _rect$attribute4 = rect.attribute,
          _rect$attribute4$widt = _rect$attribute4.width,
          width = _rect$attribute4$widt === void 0 ? groupAttribute.width : _rect$attribute4$widt,
          _rect$attribute4$heig = _rect$attribute4.height,
          height = _rect$attribute4$heig === void 0 ? groupAttribute.height : _rect$attribute4$heig,
          _rect$attribute4$stro = _rect$attribute4.stroke,
          stroke = _rect$attribute4$stro === void 0 ? groupAttribute.stroke : _rect$attribute4$stro;
        if (Array.isArray(stroke) && stroke.some(function (s) {
          return !1 === s;
        })) {
          if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), context.beginPath(), context.moveTo(x, y), stroke[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), stroke[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), stroke[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke[3]) {
            var adjustY = stroke[0] ? y - context.lineWidth / 2 : y;
            context.lineTo(x, adjustY);
          } else context.moveTo(x, y);
          context.stroke();
        }
      }
    }]);
    return SplitRectAfterRenderContribution;
  }();
  exports.SplitRectAfterRenderContribution = __decorate$1z([injectable()], exports.SplitRectAfterRenderContribution);
  var defaultRectRenderContribution = new DefaultRectRenderContribution();
  var defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
  var defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

  var DefaultSymbolRenderContribution = /*#__PURE__*/function () {
    function DefaultSymbolRenderContribution() {
      _classCallCheck(this, DefaultSymbolRenderContribution);
      this.time = exports.BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
    }
    _createClass(DefaultSymbolRenderContribution, [{
      key: "drawShape",
      value: function drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
        var parsedPath = symbol.getParsedPath();
        if (!parsedPath) return;
        var _symbol$attribute = symbol.attribute,
          outerBorder = _symbol$attribute.outerBorder,
          innerBorder = _symbol$attribute.innerBorder,
          doOuterBorder = outerBorder && !1 !== outerBorder.visible,
          doInnerBorder = innerBorder && !1 !== innerBorder.visible;
        if (!doOuterBorder && !doInnerBorder) return;
        var _symbol$attribute2 = symbol.attribute,
          _symbol$attribute2$si = _symbol$attribute2.size,
          size = _symbol$attribute2$si === void 0 ? symbolAttribute.size : _symbol$attribute2$si,
          _symbol$attribute2$op = _symbol$attribute2.opacity,
          opacity = _symbol$attribute2$op === void 0 ? symbolAttribute.opacity : _symbol$attribute2$op,
          _symbol$attribute2$x = _symbol$attribute2.x,
          originX = _symbol$attribute2$x === void 0 ? symbolAttribute.x : _symbol$attribute2$x,
          _symbol$attribute2$y = _symbol$attribute2.y,
          originY = _symbol$attribute2$y === void 0 ? symbolAttribute.y : _symbol$attribute2$y,
          _symbol$attribute2$sc = _symbol$attribute2.scaleX,
          scaleX = _symbol$attribute2$sc === void 0 ? symbolAttribute.scaleX : _symbol$attribute2$sc,
          _symbol$attribute2$sc2 = _symbol$attribute2.scaleY,
          scaleY = _symbol$attribute2$sc2 === void 0 ? symbolAttribute.scaleY : _symbol$attribute2$sc2,
          doStrokeOuter = !(!outerBorder || !outerBorder.stroke),
          doStrokeInner = !(!innerBorder || !innerBorder.stroke);
        if (doOuterBorder) {
          var _outerBorder$distance = outerBorder.distance,
            distance = _outerBorder$distance === void 0 ? symbolAttribute.outerBorder.distance : _outerBorder$distance,
            d = getScaledStroke(context, distance, context.dpr);
          if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, outerBorder, symbolAttribute.outerBorder);else if (doStrokeOuter) {
            var lastOpacity = symbolAttribute.outerBorder.opacity;
            symbolAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(symbol, outerBorder, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute.outerBorder), symbolAttribute.outerBorder.opacity = lastOpacity, context.stroke();
          }
        }
        if (doInnerBorder) {
          var _innerBorder$distance = innerBorder.distance,
            _distance = _innerBorder$distance === void 0 ? symbolAttribute.innerBorder.distance : _innerBorder$distance,
            _d = getScaledStroke(context, _distance, context.dpr);
          if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, -_d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, innerBorder, symbolAttribute.innerBorder);else if (doStrokeInner) {
            var _lastOpacity = symbolAttribute.innerBorder.opacity;
            symbolAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(symbol, innerBorder, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute.innerBorder), symbolAttribute.innerBorder.opacity = _lastOpacity, context.stroke();
          }
        }
      }
    }]);
    return DefaultSymbolRenderContribution;
  }();
  var defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
  var defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
  var defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

  var DefaultAreaTextureRenderContribution = /*#__PURE__*/function (_DefaultBaseTextureRe) {
    _inherits(DefaultAreaTextureRenderContribution, _DefaultBaseTextureRe);
    var _super = _createSuper(DefaultAreaTextureRenderContribution);
    function DefaultAreaTextureRenderContribution() {
      var _this;
      _classCallCheck(this, DefaultAreaTextureRenderContribution);
      _this = _super.apply(this, arguments), _this.time = exports.BaseRenderContributionTime.afterFillStroke;
      return _this;
    }
    _createClass(DefaultAreaTextureRenderContribution, [{
      key: "drawShape",
      value: function drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a, _b, _c, _d;
        this.textureMap || this.initTextureMap(context, graphic.stage);
        var _ref = options || {},
          _ref$attribute = _ref.attribute,
          attribute = _ref$attribute === void 0 ? graphic.attribute : _ref$attribute,
          _attribute$texture = attribute.texture,
          texture = _attribute$texture === void 0 ? null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : getAttributeFromDefaultAttrList(graphicAttribute, "texture") : _attribute$texture,
          _attribute$textureCol = attribute.textureColor,
          textureColor = _attribute$textureCol === void 0 ? null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : getAttributeFromDefaultAttrList(graphicAttribute, "textureColor") : _attribute$textureCol,
          _attribute$textureSiz = attribute.textureSize,
          textureSize = _attribute$textureSiz === void 0 ? null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : getAttributeFromDefaultAttrList(graphicAttribute, "textureSize") : _attribute$textureSiz,
          _attribute$texturePad = attribute.texturePadding,
          texturePadding = _attribute$texturePad === void 0 ? null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : getAttributeFromDefaultAttrList(graphicAttribute, "texturePadding") : _attribute$texturePad;
        texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
      }
    }]);
    return DefaultAreaTextureRenderContribution;
  }(DefaultBaseTextureRenderContribution);

  var __decorate$1y = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$1b = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$O = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultCanvasArcRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasArcRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasArcRender);
    function DefaultCanvasArcRender(arcRenderContribitions) {
      var _this;
      _classCallCheck(this, DefaultCanvasArcRender);
      _this = _super.call(this), _this.arcRenderContribitions = arcRenderContribitions, _this.numberType = ARC_NUMBER_TYPE, _this.builtinContributions = [defaultArcRenderContribution, defaultArcBackgroundRenderContribution, defaultArcTextureRenderContribution], _this.init(arcRenderContribitions);
      return _this;
    }
    _createClass(DefaultCanvasArcRender, [{
      key: "drawArcTailCapPath",
      value: function drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
        var capAngle = _ea - _sa,
          data = arc.getParsedAngle(),
          startAngle = data.startAngle;
        var endAngle = data.endAngle;
        endAngle = _ea;
        var deltaAngle = abs(endAngle - startAngle),
          clockwise = endAngle > startAngle;
        var collapsedToLine = !1;
        if (outerRadius < innerRadius) {
          var temp = outerRadius;
          outerRadius = innerRadius, innerRadius = temp;
        }
        var cornerRadius = arc.getParsedCornerRadius(),
          _arc$getParsePadAngle = arc.getParsePadAngle(startAngle, endAngle);
          _arc$getParsePadAngle.outerDeltaAngle;
          var innerDeltaAngle = _arc$getParsePadAngle.innerDeltaAngle,
          outerStartAngle = _arc$getParsePadAngle.outerStartAngle,
          outerEndAngle = _arc$getParsePadAngle.outerEndAngle,
          innerEndAngle = _arc$getParsePadAngle.innerEndAngle,
          innerStartAngle = _arc$getParsePadAngle.innerStartAngle,
          outerCornerRadiusStart = cornerRadius,
          outerCornerRadiusEnd = cornerRadius,
          innerCornerRadiusEnd = cornerRadius,
          innerCornerRadiusStart = cornerRadius,
          maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart),
          maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
        var limitedOcr = maxOuterCornerRadius,
          limitedIcr = maxInnerCornerRadius;
        var xors = outerRadius * cos(outerStartAngle),
          yors = outerRadius * sin(outerStartAngle),
          xire = innerRadius * cos(innerEndAngle),
          yire = innerRadius * sin(innerEndAngle);
        var xore, yore, xirs, yirs;
        if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
          var oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
          if (oc) {
            var ax = xors - oc[0],
              ay = yors - oc[1],
              bx = xore - oc[0],
              by = yore - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
          }
        }
        if (limitedOcr > epsilon) {
          var cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
            cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
            t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
            t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
          if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);else {
            var a1 = endAngle - capAngle - .03,
              a2 = atan2(t1.y11, t1.x11);
            context.arc(cx, cy, outerRadius, a1, a2, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
          }
        } else context.moveTo(cx + xors, cy + yors);
        if (!(innerRadius > epsilon) || innerDeltaAngle < .001) context.lineTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
          var _cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
            _cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
            _t = cornerTangents(xire, yire, xore, yore, innerRadius, -_cornerRadiusEnd, Number(clockwise)),
            _t2 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -_cornerRadiusStart, Number(clockwise));
          if (context.lineTo(cx + _t.cx + _t.x01, cy + _t.cy + _t.y01), limitedIcr < maxInnerCornerRadius && _cornerRadiusStart === _cornerRadiusEnd) {
            var arcEndAngle = atan2(_t2.y01, _t2.x01);
            context.arc(cx + _t.cx, cy + _t.cy, limitedIcr, atan2(_t.y01, _t.x01), arcEndAngle, !clockwise);
          } else {
            _cornerRadiusEnd > 0 && context.arc(cx + _t.cx, cy + _t.cy, _cornerRadiusEnd, atan2(_t.y01, _t.x01), atan2(_t.y11, _t.x11), !clockwise);
            var _a = atan2(_t.cy + _t.y11, _t.cx + _t.x11),
              _a2 = endAngle - capAngle - .03;
            context.arc(cx, cy, innerRadius, _a, _a2, clockwise);
          }
        } else context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
        return collapsedToLine;
      }
    }, {
      key: "drawShape",
      value: function drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
        var arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc,
          _arc$attribute = arc.attribute,
          _arc$attribute$fill = _arc$attribute.fill,
          fill = _arc$attribute$fill === void 0 ? arcAttribute.fill : _arc$attribute$fill,
          _arc$attribute$stroke = _arc$attribute.stroke,
          stroke = _arc$attribute$stroke === void 0 ? arcAttribute.stroke : _arc$attribute$stroke,
          _arc$attribute$x = _arc$attribute.x,
          originX = _arc$attribute$x === void 0 ? arcAttribute.x : _arc$attribute$x,
          _arc$attribute$y = _arc$attribute.y,
          originY = _arc$attribute$y === void 0 ? arcAttribute.y : _arc$attribute$y,
          data = this.valid(arc, arcAttribute, fillCb, strokeCb);
        if (!data) return;
        var fVisible = data.fVisible,
          sVisible = data.sVisible,
          doFill = data.doFill,
          doStroke = data.doStroke,
          _arc$attribute2 = arc.attribute,
          _arc$attribute2$outer = _arc$attribute2.outerPadding,
          outerPadding = _arc$attribute2$outer === void 0 ? arcAttribute.outerPadding : _arc$attribute2$outer,
          _arc$attribute2$inner = _arc$attribute2.innerPadding,
          innerPadding = _arc$attribute2$inner === void 0 ? arcAttribute.innerPadding : _arc$attribute2$inner,
          _arc$attribute2$cap = _arc$attribute2.cap,
          cap = _arc$attribute2$cap === void 0 ? arcAttribute.cap : _arc$attribute2$cap,
          _arc$attribute2$force = _arc$attribute2.forceShowCap,
          forceShowCap = _arc$attribute2$force === void 0 ? arcAttribute.forceShowCap : _arc$attribute2$force;
        var _arc$attribute3 = arc.attribute,
          _arc$attribute3$outer = _arc$attribute3.outerRadius,
          outerRadius = _arc$attribute3$outer === void 0 ? arcAttribute.outerRadius : _arc$attribute3$outer,
          _arc$attribute3$inner = _arc$attribute3.innerRadius,
          innerRadius = _arc$attribute3$inner === void 0 ? arcAttribute.innerRadius : _arc$attribute3$inner;
        outerRadius += outerPadding, innerRadius -= innerPadding;
        var conicalOffset = 0;
        var tempChangeConicalColor = (isBoolean$1(cap) && cap || cap[0]) && "conical" === fill.gradient;
        if (tempChangeConicalColor) {
          var _arc$getParsedAngle = arc.getParsedAngle(),
            sc = _arc$getParsedAngle.sc,
            startAngle = _arc$getParsedAngle.startAngle,
            endAngle = _arc$getParsedAngle.endAngle;
          abs(endAngle - startAngle) < pi2 - epsilon && (conicalOffset = sc || 0, fill.startAngle -= conicalOffset, fill.endAngle -= conicalOffset);
        }
        var beforeRenderContribitionsRuned = !1;
        var _parseStroke = parseStroke(stroke),
          isFullStroke = _parseStroke.isFullStroke,
          arrayStroke = _parseStroke.stroke;
        if ((doFill || isFullStroke) && (context.beginPath(), drawArcPath$1(arc, context, x, y, outerRadius, innerRadius), beforeRenderContribitionsRuned = !0, context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.fill())), doStroke && isFullStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.stroke()))), !isFullStroke && doStroke) {
          context.beginPath();
          drawArcPath$1(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
          beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke());
        }
        if ((isBoolean$1(cap) && cap || cap[1]) && forceShowCap) {
          var _arc$getParsedAngle2 = arc.getParsedAngle(),
            sa = _arc$getParsedAngle2.startAngle,
            ea = _arc$getParsedAngle2.endAngle;
          if (abs(ea - sa) >= pi2 - epsilon) {
            context.beginPath();
            var capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius,
              _arc$attribute4 = arc.attribute,
              _arc$attribute4$endAn = _arc$attribute4.endAngle,
              _endAngle = _arc$attribute4$endAn === void 0 ? arcAttribute.endAngle : _arc$attribute4$endAn,
              _arc$attribute4$fill = _arc$attribute4.fill,
              _fill = _arc$attribute4$fill === void 0 ? arcAttribute.fill : _arc$attribute4$fill,
              _startAngle = _endAngle;
            if (this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, _startAngle, _startAngle + capAngle), beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), doFill) {
              var color = _fill;
              if ("conical" === color.gradient) {
                var lastColor = getConicGradientAt(0, 0, _endAngle, color);
                fillCb || fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = lastColor, context.fill());
              }
            }
            doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
          }
        }
        this.afterRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), tempChangeConicalColor && (fill.startAngle += conicalOffset, fill.endAngle += conicalOffset);
      }
    }, {
      key: "draw",
      value: function draw(arc, renderService, drawContext, params) {
        var arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc;
        this._draw(arc, arcAttribute, !1, drawContext, params);
      }
    }]);
    return DefaultCanvasArcRender;
  }(BaseRender);
  exports.DefaultCanvasArcRender = __decorate$1y([injectable(), __param$O(0, inject(ContributionProvider)), __param$O(0, named(ArcRenderContribution)), __metadata$1b("design:paramtypes", [Object])], exports.DefaultCanvasArcRender);

  var __decorate$1x = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$1a = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$N = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultCanvasCircleRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasCircleRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasCircleRender);
    function DefaultCanvasCircleRender(circleRenderContribitions) {
      var _this;
      _classCallCheck(this, DefaultCanvasCircleRender);
      _this = _super.call(this), _this.circleRenderContribitions = circleRenderContribitions, _this.numberType = CIRCLE_NUMBER_TYPE, _this.builtinContributions = [defaultCircleRenderContribution, defaultCircleBackgroundRenderContribution, defaultCircleTextureRenderContribution], _this.init(circleRenderContribitions);
      return _this;
    }
    _createClass(DefaultCanvasCircleRender, [{
      key: "drawShape",
      value: function drawShape(circle, context, x, y, drawContext, params, fillCb, strokeCb) {
        var circleAttribute = getTheme(circle, null == params ? void 0 : params.theme).circle,
          _circle$attribute = circle.attribute,
          _circle$attribute$rad = _circle$attribute.radius,
          radius = _circle$attribute$rad === void 0 ? circleAttribute.radius : _circle$attribute$rad,
          _circle$attribute$sta = _circle$attribute.startAngle,
          startAngle = _circle$attribute$sta === void 0 ? circleAttribute.startAngle : _circle$attribute$sta,
          _circle$attribute$end = _circle$attribute.endAngle,
          endAngle = _circle$attribute$end === void 0 ? circleAttribute.endAngle : _circle$attribute$end,
          _circle$attribute$x = _circle$attribute.x,
          originX = _circle$attribute$x === void 0 ? circleAttribute.x : _circle$attribute$x,
          _circle$attribute$y = _circle$attribute.y,
          originY = _circle$attribute$y === void 0 ? circleAttribute.y : _circle$attribute$y,
          data = this.valid(circle, circleAttribute, fillCb, strokeCb);
        if (!data) return;
        var fVisible = data.fVisible,
          sVisible = data.sVisible,
          doFill = data.doFill,
          doStroke = data.doStroke;
        context.beginPath(), context.arc(x, y, radius, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute), this.beforeRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb), doFill && (fillCb ? fillCb(context, circle.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), context.fill())), doStroke && (strokeCb ? strokeCb(context, circle.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), context.stroke())), this.afterRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
      }
    }, {
      key: "draw",
      value: function draw(circle, renderService, drawContext, params) {
        var circleAttribute = getTheme(circle, null == params ? void 0 : params.theme).circle;
        this._draw(circle, circleAttribute, !1, drawContext, params);
      }
    }]);
    return DefaultCanvasCircleRender;
  }(BaseRender);
  exports.DefaultCanvasCircleRender = __decorate$1x([injectable(), __param$N(0, inject(ContributionProvider)), __param$N(0, named(CircleRenderContribution)), __metadata$1a("design:paramtypes", [Object])], exports.DefaultCanvasCircleRender);

  function drawSegItem(ctx, curve, endPercent, params) {
    if (!curve.p1) return;
    var _ref = params || {},
      _ref$offsetX = _ref.offsetX,
      offsetX = _ref$offsetX === void 0 ? 0 : _ref$offsetX,
      _ref$offsetY = _ref.offsetY,
      offsetY = _ref$offsetY === void 0 ? 0 : _ref$offsetY,
      _ref$offsetZ = _ref.offsetZ,
      offsetZ = _ref$offsetZ === void 0 ? 0 : _ref$offsetZ;
    if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);else if (curve.p2 && curve.p3) {
      var _divideCubic = divideCubic(curve, endPercent),
        _divideCubic2 = _slicedToArray(_divideCubic, 1),
        curve1 = _divideCubic2[0];
      ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
    } else {
      var p = curve.getPointAt(endPercent);
      ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
    }
  }

  function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
    var _a;
    var _ref = params || {},
      _ref$offsetX = _ref.offsetX,
      offsetX = _ref$offsetX === void 0 ? 0 : _ref$offsetX,
      _ref$offsetY = _ref.offsetY,
      offsetY = _ref$offsetY === void 0 ? 0 : _ref$offsetY,
      _ref$offsetZ = _ref.offsetZ,
      offsetZ = _ref$offsetZ === void 0 ? 0 : _ref$offsetZ,
      _ref$mode = _ref.mode,
      mode = _ref$mode === void 0 ? "none" : _ref$mode,
      _ref$drawConnect = _ref.drawConnect,
      drawConnect = _ref$drawConnect === void 0 ? !1 : _ref$drawConnect;
      _ref.zeroX;
      _ref.zeroY;
    if (drawConnect && "none" === mode) return;
    if (!segPath) return;
    var needMoveTo = !0;
    var curves = segPath.curves;
    if (percent >= 1) {
      if (drawConnect) {
        var _lastCurve,
          _defined = !0;
        curves.forEach(function (curve, i) {
          var _a;
          var p0 = curve.p0;
          if (curve.originP1 !== curve.originP2) {
            if (_lastCurve && _lastCurve.originP1 === _lastCurve.originP2 && (p0 = _lastCurve.p0), curve.defined) _defined || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), _defined = !_defined);else {
              var originP1 = curve.originP1,
                originP2 = curve.originP2;
              var validP;
              if (originP1 && !1 !== originP1.defined ? validP = p0 : originP1 && !1 !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), _defined) {
                _defined = !_defined;
                var x = validP ? validP.x : curve.p0.x,
                  y = validP ? validP.y : curve.p0.y;
                path.moveTo(x + offsetX, y + offsetY, offsetZ);
              } else validP && (_defined = !_defined, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
            }
            _lastCurve = curve;
          } else _lastCurve = curve;
        });
      } else curves.forEach(function (curve) {
        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
      });
      return;
    }
    if (percent <= 0) return;
    var direction;
    "x" === clipRangeByDimension ? direction = exports.Direction.ROW : "y" === clipRangeByDimension ? direction = exports.Direction.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
    var totalDrawLength = percent * segPath.tryUpdateLength(direction);
    var drawedLengthUntilLast = 0,
      defined0 = !0,
      lastCurve = null;
    for (var i = 0, n = curves.length; i < n; i++) {
      var curve = curves[i],
        curCurveLength = curve.getLength(direction),
        _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
      if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
      if (drawConnect) {
        var p0 = curve.p0;
        if (curve.originP1 === curve.originP2) {
          lastCurve = curve;
          continue;
        }
        if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), defined0 = !defined0);else {
          var originP1 = curve.originP1,
            originP2 = curve.originP2;
          var validP = void 0;
          if (originP1 && !1 !== originP1.defined ? validP = p0 : originP1 && !1 !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), defined0) {
            defined0 = !defined0;
            var x = validP ? validP.x : curve.p0.x,
              y = validP ? validP.y : curve.p0.y;
            path.moveTo(x + offsetX, y + offsetY, offsetZ);
          } else validP && (defined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
        }
        lastCurve = curve;
      } else {
        if (!curve.defined) {
          needMoveTo = !0;
          continue;
        }
        needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, min(_p, 1), params), needMoveTo = !1;
      }
    }
  }
  function drawIncrementalSegments(path, lastSeg, segments, params) {
    var _ref2 = params || {},
      _ref2$offsetX = _ref2.offsetX,
      offsetX = _ref2$offsetX === void 0 ? 0 : _ref2$offsetX,
      _ref2$offsetY = _ref2.offsetY,
      offsetY = _ref2$offsetY === void 0 ? 0 : _ref2$offsetY,
      startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), segments.points.forEach(function (p) {
      !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
    });
  }
  function drawIncrementalAreaSegments(path, lastSeg, segments, params) {
    var _ref3 = params || {},
      _ref3$offsetX = _ref3.offsetX,
      offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX,
      _ref3$offsetY = _ref3.offsetY,
      offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY,
      points = segments.points,
      definedPointsList = [];
    for (var i = 0; i < points.length; i++) !1 === points[i].defined && (i);
    definedPointsList.push(points), definedPointsList.forEach(function (points, i) {
      var _a, _b, _c, _d;
      var startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points[0];
      path.moveTo(startP.x + offsetX, startP.y + offsetY), points.forEach(function (p) {
        !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
      });
      for (var _i = points.length - 1; _i >= 0; _i--) {
        var p = points[_i];
        path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
      }
      path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), path.closePath();
    });
  }

  var __decorate$1w = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  exports.DefaultCanvasLineRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasLineRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasLineRender);
    function DefaultCanvasLineRender() {
      var _this;
      _classCallCheck(this, DefaultCanvasLineRender);
      _this = _super.apply(this, arguments), _this.numberType = LINE_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasLineRender, [{
      key: "draw",
      value: function draw(line, renderService, drawContext, params) {
        var lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line;
        this._draw(line, lineAttribute, !1, drawContext, params);
      }
    }, {
      key: "drawSegmentItem",
      value: function drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
        var _a, _b, _c, _d, _e;
        if (!cache) return;
        context.beginPath();
        var z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
        drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
          offsetX: offsetX,
          offsetY: offsetY,
          offsetZ: z
        }), line.cache && !isArray$1(line.cache) && line.cache.curves.every(function (c) {
          return c.defined;
        }) && line.attribute.curveType && line.attribute.curveType.includes("Closed") && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);
        var _attribute$x = attribute.x,
          originX = _attribute$x === void 0 ? 0 : _attribute$x,
          _attribute$x2 = attribute.x,
          originY = _attribute$x2 === void 0 ? 0 : _attribute$x2;
        !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke()));
        var connectedType = attribute.connectedType,
          connectedX = attribute.connectedX,
          connectedY = attribute.connectedY,
          connectedStyle = attribute.connectedStyle;
        if (isArray$1(defaultAttribute) ? (connectedType = null !== (_b = null != connectedType ? connectedType : defaultAttribute[0].connectedType) && void 0 !== _b ? _b : defaultAttribute[1].connectedType, connectedX = null !== (_c = null != connectedX ? connectedX : defaultAttribute[0].connectedX) && void 0 !== _c ? _c : defaultAttribute[1].connectedX, connectedY = null !== (_d = null != connectedY ? connectedY : defaultAttribute[0].connectedY) && void 0 !== _d ? _d : defaultAttribute[1].connectedY, connectedStyle = null !== (_e = null != connectedStyle ? connectedStyle : defaultAttribute[0].connectedStyle) && void 0 !== _e ? _e : defaultAttribute[1].connectedStyle) : (connectedType = null != connectedType ? connectedType : defaultAttribute.connectedType, connectedX = null != connectedX ? connectedX : defaultAttribute.connectedX, connectedY = null != connectedY ? connectedY : defaultAttribute.connectedY, connectedStyle = null != connectedStyle ? connectedStyle : defaultAttribute.connectedStyle), "connect" !== connectedType && "zero" !== connectedType && (connectedType = "none"), "none" !== connectedType) {
          context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
            offsetX: offsetX,
            offsetY: offsetY,
            offsetZ: z,
            drawConnect: !0,
            mode: connectedType,
            zeroX: connectedX,
            zeroY: connectedY
          });
          var da = [];
          isArray$1(defaultAttribute) ? defaultAttribute.forEach(function (i) {
            return da.push(i);
          }) : da.push(defaultAttribute), da.push(attribute), !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, connectedStyle, originX - offsetX, originY - offsetY, da), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, connectedStyle, originX - offsetX, originY - offsetY, da), context.stroke()));
        }
        return !1;
      }
    }, {
      key: "drawLinearLineHighPerformance",
      value: function drawLinearLineHighPerformance(line, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params, fillCb, strokeCb) {
        var _a;
        context.beginPath();
        var z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
          points = line.attribute.points,
          startP = points[0];
        context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
        for (var i = 1; i < points.length; i++) {
          var p = points[i];
          context.lineTo(p.x + offsetX, p.y + offsetY, z);
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(line, line.attribute, lineAttribute);
        var _line$attribute = line.attribute,
          _line$attribute$x = _line$attribute.x,
          originX = _line$attribute$x === void 0 ? 0 : _line$attribute$x,
          _line$attribute$x2 = _line$attribute.x,
          originY = _line$attribute$x2 === void 0 ? 0 : _line$attribute$x2;
        !1 !== fill && (fillCb ? fillCb(context, line.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, line.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.stroke()));
      }
    }, {
      key: "drawShape",
      value: function drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _this2 = this;
        var lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line,
          _line$attribute2 = line.attribute,
          _line$attribute2$fill = _line$attribute2.fill,
          fill = _line$attribute2$fill === void 0 ? lineAttribute.fill : _line$attribute2$fill,
          _line$attribute2$stro = _line$attribute2.stroke,
          stroke = _line$attribute2$stro === void 0 ? lineAttribute.stroke : _line$attribute2$stro,
          _line$attribute2$fill2 = _line$attribute2.fillOpacity,
          fillOpacity = _line$attribute2$fill2 === void 0 ? lineAttribute.fillOpacity : _line$attribute2$fill2,
          _line$attribute2$stro2 = _line$attribute2.strokeOpacity,
          strokeOpacity = _line$attribute2$stro2 === void 0 ? lineAttribute.strokeOpacity : _line$attribute2$stro2,
          segments = _line$attribute2.segments,
          points = _line$attribute2.points,
          closePath = _line$attribute2.closePath;
        if (!this.valid(line, lineAttribute, fillCb, strokeCb)) return;
        var _line$attribute$curve = line.attribute.curveType,
          curveType = _line$attribute$curve === void 0 ? lineAttribute.curveType : _line$attribute$curve;
        closePath && "linear" === curveType && (curveType = "linearClosed");
        var _line$attribute3 = line.attribute,
          _line$attribute3$clip = _line$attribute3.clipRange,
          clipRange = _line$attribute3$clip === void 0 ? lineAttribute.clipRange : _line$attribute3$clip,
          _line$attribute3$clip2 = _line$attribute3.clipRangeByDimension,
          clipRangeByDimension = _line$attribute3$clip2 === void 0 ? lineAttribute.clipRangeByDimension : _line$attribute3$clip2;
        if (1 === clipRange && !segments && !points.some(function (p) {
          return !1 === p.defined;
        }) && "linear" === curveType) return this.drawLinearLineHighPerformance(line, context, !!fill, !!stroke, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params, fillCb, strokeCb);
        if (line.shouldUpdateShape()) {
          var _line$attribute4 = line.attribute,
            _points2 = _line$attribute4.points,
            _segments = _line$attribute4.segments,
            _points = _points2;
          if (_segments && _segments.length) {
            var startPoint, lastSeg;
            if (line.cache = _segments.map(function (seg, index) {
              if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastSeg = {
                endX: seg.points[0].x,
                endY: seg.points[0].y,
                curves: [{
                  defined: !1 !== seg.points[0].defined
                }]
              }), null;
              1 === index ? startPoint = {
                x: lastSeg.endX,
                y: lastSeg.endY,
                defined: lastSeg.curves[lastSeg.curves.length - 1].defined
              } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
              var data = calcLineCache$1(seg.points, curveType, {
                startPoint: startPoint
              });
              return lastSeg = data, data;
            }).filter(function (item) {
              return !!item;
            }), "linearClosed" === curveType) {
              var startP;
              for (var i = 0; i < line.cache.length; i++) {
                var cacheItem = line.cache[i];
                for (var _i = 0; _i < cacheItem.curves.length; _i++) if (cacheItem.curves[_i].defined) {
                  startP = cacheItem.curves[_i].p0;
                  break;
                }
                if (startP) break;
              }
              line.cache[line.cache.length - 1] && line.cache[line.cache.length - 1].lineTo(startP.x, startP.y, !0);
            }
          } else {
            if (!_points2 || !_points2.length) return line.cache = null, void line.clearUpdateShapeTag();
            line.cache = calcLineCache$1(_points, curveType);
          }
          line.clearUpdateShapeTag();
        }
        if (Array.isArray(line.cache)) {
          var _segments2 = line.attribute.segments.filter(function (item) {
            return item.points.length;
          });
          if (1 === _segments2[0].points.length && _segments2.shift(), 1 === clipRange) {
            var skip = !1;
            line.cache.forEach(function (cache, index) {
              skip || (skip = _this2.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, _segments2[index], [lineAttribute, line.attribute], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb));
            });
          } else {
            var totalLength = line.cache.reduce(function (l, c) {
                return l + c.getLength();
              }, 0),
              totalDrawLength = clipRange * totalLength;
            var drawedLengthUntilLast = 0,
              _skip = !1;
            line.cache.forEach(function (cache, index) {
              if (_skip) return;
              var curSegLength = cache.getLength(),
                _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
              drawedLengthUntilLast += curSegLength, _cr > 0 && (_skip = _this2.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, _segments2[index], [lineAttribute, line.attribute], min(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb));
            });
          }
        } else this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
      }
    }]);
    return DefaultCanvasLineRender;
  }(BaseRender);
  exports.DefaultCanvasLineRender = __decorate$1w([injectable()], exports.DefaultCanvasLineRender);

  function drawAreaSegments(path, segPath, percent, params) {
    var _a;
    var _ref = params || {},
      _ref$drawConnect = _ref.drawConnect,
      drawConnect = _ref$drawConnect === void 0 ? !1 : _ref$drawConnect,
      _ref$mode = _ref.mode,
      mode = _ref$mode === void 0 ? "none" : _ref$mode;
    if (drawConnect && "none" === mode) return;
    var top = segPath.top,
      bottom = segPath.bottom;
    if (top.curves.length !== bottom.curves.length) return;
    if (percent >= 1) {
      var _topList = [],
        _bottomList = [];
      var _lastDefined = !0;
      if (drawConnect) {
        var lastCurve,
          _lastBottomCurve,
          _defined = !0;
        var n = top.curves.length;
        top.curves.forEach(function (curve, i) {
          var bototmCurve = bottom.curves[n - i - 1];
          var currentTopCurve = curve,
            currentBottomCurve = bototmCurve;
          if (curve.originP1 === curve.originP2) return lastCurve = curve, void (_lastBottomCurve = bototmCurve);
          if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (currentTopCurve = lastCurve, currentBottomCurve = _lastBottomCurve), curve.defined) _defined || (_topList.push(currentTopCurve), _bottomList.push(currentBottomCurve), drawAreaConnectBlock(path, _topList, _bottomList, params), _topList.length = 0, _bottomList.length = 0, _defined = !_defined);else {
            var originP1 = curve.originP1,
              originP2 = curve.originP2;
            var validTopCurve, validBottomCurve;
            originP1 && !1 !== originP1.defined ? (validTopCurve = currentTopCurve, validBottomCurve = currentBottomCurve) : originP1 && !1 !== originP2.defined && (validTopCurve = curve, validBottomCurve = bototmCurve), _defined ? (_defined = !_defined, _topList.push(validTopCurve || curve), _bottomList.push(validBottomCurve || bototmCurve)) : validTopCurve && (_defined = !_defined, _topList.push(validTopCurve || curve), _bottomList.push(validBottomCurve || bototmCurve), drawAreaConnectBlock(path, _topList, _bottomList, params), _topList.length = 0, _bottomList.length = 0);
          }
          lastCurve = curve;
        }), drawAreaConnectBlock(path, _topList, _bottomList, params);
      } else {
        for (var i = 0, _n = top.curves.length; i < _n; i++) {
          var topCurve = top.curves[i];
          _lastDefined !== topCurve.defined ? (_lastDefined ? (drawAreaBlock(path, _topList, _bottomList, params), _topList.length = 0, _bottomList.length = 0) : (_topList.push(topCurve), _bottomList.push(bottom.curves[_n - i - 1])), _lastDefined = !_lastDefined) : _lastDefined && (_topList.push(topCurve), _bottomList.push(bottom.curves[_n - i - 1]));
        }
        drawAreaBlock(path, _topList, _bottomList, params);
      }
      return;
    }
    if (percent <= 0) return;
    var _ref2 = params || {},
      direction = _ref2.direction;
    var topCurves = top.curves,
      endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1,
      xTotalLength = abs(endP.x - topCurves[0].p0.x),
      yTotalLength = abs(endP.y - topCurves[0].p0.y);
    direction = null != direction ? direction : xTotalLength > yTotalLength ? exports.Direction.ROW : exports.Direction.COLUMN, Number.isFinite(xTotalLength) || (direction = exports.Direction.COLUMN), Number.isFinite(yTotalLength) || (direction = exports.Direction.ROW);
    var totalDrawLength = percent * (direction === exports.Direction.ROW ? xTotalLength : yTotalLength);
    var drawedLengthUntilLast = 0,
      lastDefined = !0;
    var topList = [],
      bottomList = [];
    var lastTopCurve,
      lastBottomCurve,
      defined0 = !0;
    for (var _i = 0, _n2 = top.curves.length; _i < _n2; _i++) {
      var _topCurve = top.curves[_i],
        curCurveLength = _topCurve.getLength(direction),
        _percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
      if (_percent < 0) break;
      if (drawedLengthUntilLast += curCurveLength, drawConnect) {
        var bototmCurve = bottom.curves[_n2 - _i - 1];
        var currentTopCurve = _topCurve,
          currentBottomCurve = bototmCurve;
        if (_topCurve.originP1 === _topCurve.originP2) {
          lastTopCurve = _topCurve, lastBottomCurve = bototmCurve;
          continue;
        }
        if (lastTopCurve && lastTopCurve.originP1 === lastTopCurve.originP2 && (currentTopCurve = lastTopCurve, currentBottomCurve = lastBottomCurve), _topCurve.defined) defined0 || (topList.push(currentTopCurve), bottomList.push(currentBottomCurve), drawAreaConnectBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0, defined0 = !defined0);else {
          var originP1 = _topCurve.originP1,
            originP2 = _topCurve.originP2;
          var validTopCurve = void 0,
            validBottomCurve = void 0;
          originP1 && !1 !== originP1.defined ? (validTopCurve = currentTopCurve, validBottomCurve = currentBottomCurve) : originP1 && !1 !== originP2.defined && (validTopCurve = _topCurve, validBottomCurve = bototmCurve), defined0 ? (defined0 = !defined0, topList.push(validTopCurve || _topCurve), bottomList.push(validBottomCurve || bototmCurve)) : validTopCurve && (defined0 = !defined0, topList.push(validTopCurve || _topCurve), bottomList.push(validBottomCurve || bototmCurve), drawAreaConnectBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0);
        }
        lastTopCurve = _topCurve;
      } else {
        var tc = null,
          bc = null;
        lastDefined !== _topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0) : (tc = _topCurve, bc = bottom.curves[_n2 - _i - 1]), lastDefined = !lastDefined) : lastDefined && (tc = _topCurve, bc = bottom.curves[_n2 - _i - 1]), tc && bc && (_percent < 1 && (tc = tc.p2 && tc.p3 ? divideCubic(tc, _percent)[0] : divideLinear(tc, _percent)[0], bc = bc.p2 && bc.p3 ? divideCubic(bc, 1 - _percent)[1] : divideLinear(bc, 1 - _percent)[1]), tc.defined = lastDefined, bc.defined = lastDefined, topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
      }
    }
    drawConnect ? drawAreaConnectBlock(path, topList, bottomList, params) : drawAreaBlock(path, topList, bottomList, params);
  }
  function drawAreaConnectBlock(path, topList, bottomList, params) {
    if (topList.length < 2) return;
    var _ref3 = params || {},
      _ref3$offsetX = _ref3.offsetX,
      offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX,
      _ref3$offsetY = _ref3.offsetY,
      offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY,
      _ref3$offsetZ = _ref3.offsetZ,
      offsetZ = _ref3$offsetZ === void 0 ? 0 : _ref3$offsetZ;
      _ref3.mode;
    var curve = topList[0];
    path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), curve = topList[topList.length - 1];
    var end = curve.p3 || curve.p1;
    path.lineTo(end.x + offsetX, end.y + offsetY, offsetZ), curve = bottomList[bottomList.length - 1], path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), curve = bottomList[0], end = curve.p3 || curve.p1, path.lineTo(end.x + offsetX, end.y + offsetY, offsetZ), path.closePath();
  }
  function drawAreaBlock(path, topList, bottomList, params) {
    var _ref4 = params || {},
      _ref4$offsetX = _ref4.offsetX,
      offsetX = _ref4$offsetX === void 0 ? 0 : _ref4$offsetX,
      _ref4$offsetY = _ref4.offsetY,
      offsetY = _ref4$offsetY === void 0 ? 0 : _ref4$offsetY,
      _ref4$offsetZ = _ref4.offsetZ,
      offsetZ = _ref4$offsetZ === void 0 ? 0 : _ref4$offsetZ;
    var needMoveTo = !0;
    topList.forEach(function (curve) {
      curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
    }), needMoveTo = !0;
    for (var i = bottomList.length - 1; i >= 0; i--) {
      var curve = bottomList[i];
      curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
    }
    path.closePath();
  }

  var defaultAreaTextureRenderContribution = new DefaultAreaTextureRenderContribution();
  var defaultAreaBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

  var __decorate$1v = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$19 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$M = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  function calcLineCache(points, curveType, params) {
    switch (curveType) {
      case "linear":
      default:
        return genLinearSegments(points, params);
      case "basis":
        return genBasisSegments(points, params);
      case "monotoneX":
        return genMonotoneXSegments(points, params);
      case "monotoneY":
        return genMonotoneYSegments(points, params);
      case "step":
        return genStepSegments(points, .5, params);
      case "stepBefore":
        return genStepSegments(points, 0, params);
      case "stepAfter":
        return genStepSegments(points, 1, params);
      case "linearClosed":
        return genLinearClosedSegments(points, params);
    }
  }
  exports.DefaultCanvasAreaRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasAreaRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasAreaRender);
    function DefaultCanvasAreaRender(areaRenderContribitions) {
      var _this;
      _classCallCheck(this, DefaultCanvasAreaRender);
      _this = _super.call(this), _this.areaRenderContribitions = areaRenderContribitions, _this.numberType = AREA_NUMBER_TYPE, _this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution], _this.init(areaRenderContribitions);
      return _this;
    }
    _createClass(DefaultCanvasAreaRender, [{
      key: "drawLinearAreaHighPerformance",
      value: function drawLinearAreaHighPerformance(area, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, areaAttribute, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c, _d, _e;
        var points = area.attribute.points;
        if (points.length < 2) return;
        context.beginPath();
        var z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
          startP = points[0];
        context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
        for (var i = 1; i < points.length; i++) {
          var p = points[i];
          context.lineTo(p.x + offsetX, p.y + offsetY, z);
        }
        for (var _i = points.length - 1; _i >= 0; _i--) {
          var _p = points[_i];
          context.lineTo((null !== (_b = _p.x1) && void 0 !== _b ? _b : _p.x) + offsetX, (null !== (_c = _p.y1) && void 0 !== _c ? _c : _p.y) + offsetY, z);
        }
        context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(area, area.attribute, areaAttribute), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, areaAttribute, drawContext, fillCb, null, {
          attribute: area.attribute
        });
        var _area$attribute = area.attribute,
          _area$attribute$x = _area$attribute.x,
          originX = _area$attribute$x === void 0 ? 0 : _area$attribute$x,
          _area$attribute$x2 = _area$attribute.x,
          originY = _area$attribute$x2 === void 0 ? 0 : _area$attribute$x2;
        if (!1 !== fill && (fillCb ? fillCb(context, area.attribute, areaAttribute) : fillOpacity && (context.setCommonStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, areaAttribute, drawContext, fillCb, null, {
          attribute: area.attribute
        }), stroke) {
          var _area$attribute$strok = area.attribute.stroke,
            _stroke = _area$attribute$strok === void 0 ? areaAttribute && areaAttribute.stroke : _area$attribute$strok;
          if (isArray$1(_stroke) && (_stroke[0] || _stroke[2]) && !1 === _stroke[1]) if (context.beginPath(), _stroke[0]) {
            context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
            for (var _i2 = 1; _i2 < points.length; _i2++) {
              var _p2 = points[_i2];
              context.lineTo(_p2.x + offsetX, _p2.y + offsetY, z);
            }
          } else if (_stroke[2]) {
            var endP = points[points.length - 1];
            context.moveTo(endP.x + offsetX, endP.y + offsetY, z);
            for (var _i3 = points.length - 2; _i3 >= 0; _i3--) {
              var _p3 = points[_i3];
              context.lineTo((null !== (_d = _p3.x1) && void 0 !== _d ? _d : _p3.x) + offsetX, (null !== (_e = _p3.y1) && void 0 !== _e ? _e : _p3.y) + offsetY, z);
            }
          }
          strokeCb ? strokeCb(context, area.attribute, areaAttribute) : (context.setStrokeStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.stroke());
        }
      }
    }, {
      key: "drawShape",
      value: function drawShape(area, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _this2 = this;
        var _a, _b, _c, _d, _e, _f;
        var areaAttribute = getTheme(area, null == params ? void 0 : params.theme).area,
          _area$attribute2 = area.attribute,
          _area$attribute2$fill = _area$attribute2.fill,
          fill = _area$attribute2$fill === void 0 ? areaAttribute.fill : _area$attribute2$fill,
          _area$attribute2$stro = _area$attribute2.stroke;
          _area$attribute2$stro === void 0 ? areaAttribute.stroke : _area$attribute2$stro;
          var _area$attribute2$fill2 = _area$attribute2.fillOpacity,
          fillOpacity = _area$attribute2$fill2 === void 0 ? areaAttribute.fillOpacity : _area$attribute2$fill2,
          _area$attribute2$z = _area$attribute2.z,
          z = _area$attribute2$z === void 0 ? areaAttribute.z : _area$attribute2$z,
          _area$attribute2$stro2 = _area$attribute2.strokeOpacity,
          strokeOpacity = _area$attribute2$stro2 === void 0 ? areaAttribute.strokeOpacity : _area$attribute2$stro2,
          data = this.valid(area, areaAttribute, fillCb, strokeCb);
        if (!data) return;
        var doFill = data.doFill,
          doStroke = data.doStroke,
          _area$attribute3 = area.attribute,
          _area$attribute3$clip = _area$attribute3.clipRange,
          clipRange = _area$attribute3$clip === void 0 ? areaAttribute.clipRange : _area$attribute3$clip,
          closePath = _area$attribute3.closePath,
          points = _area$attribute3.points,
          segments = _area$attribute3.segments;
        var _area$attribute$curve = area.attribute.curveType,
          curveType = _area$attribute$curve === void 0 ? areaAttribute.curveType : _area$attribute$curve;
        if (closePath && "linear" === curveType && (curveType = "linearClosed"), 1 === clipRange && !segments && !points.some(function (p) {
          return !1 === p.defined;
        }) && "linear" === curveType) return this.drawLinearAreaHighPerformance(area, context, !!fill, doStroke, fillOpacity, strokeOpacity, x, y, areaAttribute, drawContext, params, fillCb, strokeCb);
        if (area.shouldUpdateShape()) {
          if (segments && segments.length) {
            var startPoint, lastTopSeg;
            var topCaches = segments.map(function (seg, index) {
              if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastTopSeg = {
                endX: seg.points[0].x,
                endY: seg.points[0].y
              }), null;
              1 === index ? startPoint = {
                x: lastTopSeg.endX,
                y: lastTopSeg.endY
              } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY);
              var data = calcLineCache(seg.points, curveType, {
                startPoint: startPoint
              });
              return lastTopSeg = data, data;
            }).filter(function (item) {
              return !!item;
            });
            var lastBottomSeg;
            var bottomCaches = [];
            for (var i = segments.length - 1; i >= 0; i--) {
              var _points = segments[i].points,
                bottomPoints = [];
              for (var _i4 = _points.length - 1; _i4 >= 0; _i4--) bottomPoints.push({
                x: null !== (_a = _points[_i4].x1) && void 0 !== _a ? _a : _points[_i4].x,
                y: null !== (_b = _points[_i4].y1) && void 0 !== _b ? _b : _points[_i4].y
              });
              if (0 !== i) {
                var lastSegmentPoints = segments[i - 1].points,
                  endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
                endPoint && bottomPoints.push({
                  x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,
                  y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y
                });
              }
              bottomPoints.length > 1 && (lastBottomSeg = calcLineCache(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType), bottomCaches.unshift(lastBottomSeg));
            }
            area.cacheArea = bottomCaches.map(function (item, index) {
              return {
                top: topCaches[index],
                bottom: item
              };
            });
          } else {
            if (!points || !points.length) return area.cacheArea = null, void area.clearUpdateShapeTag();
            {
              var topPoints = points,
                _bottomPoints = [];
              for (var _i5 = points.length - 1; _i5 >= 0; _i5--) _bottomPoints.push({
                x: null !== (_e = points[_i5].x1) && void 0 !== _e ? _e : points[_i5].x,
                y: null !== (_f = points[_i5].y1) && void 0 !== _f ? _f : points[_i5].y
              });
              var topCache = calcLineCache(topPoints, curveType),
                bottomCache = calcLineCache(_bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType);
              area.cacheArea = {
                top: topCache,
                bottom: bottomCache
              };
            }
          }
          area.clearUpdateShapeTag();
        }
        if (Array.isArray(area.cacheArea)) {
          var _segments = area.attribute.segments.filter(function (item) {
            return item.points.length;
          });
          if (1 === _segments[0].points.length && _segments.shift(), 1 === clipRange) {
            var skip = !1;
            area.cacheArea.forEach(function (cache, index) {
              skip || (skip = _this2.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, _segments[index], [areaAttribute, area.attribute], clipRange, x, y, z, area, drawContext, fillCb, strokeCb));
            });
          } else {
            var totalLength = area.cacheArea.reduce(function (l, c) {
                return l + c.top.getLength();
              }, 0),
              totalDrawLength = clipRange * totalLength;
            var drawedLengthUntilLast = 0,
              _skip = !1;
            area.cacheArea.forEach(function (cache, index) {
              if (_skip) return;
              var curSegLength = cache.top.getLength(),
                _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
              drawedLengthUntilLast += curSegLength, _cr > 0 && (_skip = _this2.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, _segments[index], [areaAttribute, area.attribute], min(_cr, 1), x, y, z, area, drawContext, fillCb, strokeCb));
            });
          }
        } else this.drawSegmentItem(context, area.cacheArea, doFill, fillOpacity, doStroke, strokeOpacity, area.attribute, areaAttribute, clipRange, x, y, z, area, drawContext, fillCb, strokeCb);
      }
    }, {
      key: "draw",
      value: function draw(area, renderService, drawContext, params) {
        var areaAttribute = getTheme(area, null == params ? void 0 : params.theme).area;
        this._draw(area, areaAttribute, !1, drawContext, params);
      }
    }, {
      key: "drawSegmentItem",
      value: function drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
        var ret = !1;
        return ret = ret || this._drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, !1, fillCb, strokeCb), ret = ret || this._drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, !0, fillCb, strokeCb), ret;
      }
    }, {
      key: "_drawSegmentItem",
      value: function _drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, connect, fillCb, strokeCb) {
        var _a, _b, _c, _d;
        if (!(cache && cache.top && cache.bottom && cache.top.curves && cache.top.curves.length && cache.bottom.curves && cache.bottom.curves.length)) return;
        var connectedType = attribute.connectedType,
          connectedX = attribute.connectedX,
          connectedY = attribute.connectedY,
          connectedStyle = attribute.connectedStyle;
        var da = [];
        if (connect && (isArray$1(defaultAttribute) ? (connectedType = null !== (_a = null != connectedType ? connectedType : defaultAttribute[0].connectedType) && void 0 !== _a ? _a : defaultAttribute[1].connectedType, connectedX = null !== (_b = null != connectedX ? connectedX : defaultAttribute[0].connectedX) && void 0 !== _b ? _b : defaultAttribute[1].connectedX, connectedY = null !== (_c = null != connectedY ? connectedY : defaultAttribute[0].connectedY) && void 0 !== _c ? _c : defaultAttribute[1].connectedY, connectedStyle = null !== (_d = null != connectedStyle ? connectedStyle : defaultAttribute[0].connectedStyle) && void 0 !== _d ? _d : defaultAttribute[1].connectedStyle) : (connectedType = null != connectedType ? connectedType : defaultAttribute.connectedType, connectedX = null != connectedX ? connectedX : defaultAttribute.connectedX, connectedY = null != connectedY ? connectedY : defaultAttribute.connectedY, connectedStyle = null != connectedStyle ? connectedStyle : defaultAttribute.connectedStyle), "connect" !== connectedType && "zero" !== connectedType && (connectedType = "none"), isArray$1(defaultAttribute) ? defaultAttribute.forEach(function (i) {
          return da.push(i);
        }) : da.push(defaultAttribute), da.push(attribute)), connect && "none" === connectedType) return !1;
        context.beginPath();
        var _area$attribute4 = area.attribute,
          points = _area$attribute4.points,
          segments = _area$attribute4.segments;
        var endP,
          startP,
          direction = exports.Direction.ROW;
        if (segments) {
          var endSeg = segments[segments.length - 1];
          startP = segments[0].points[0], endP = endSeg.points[endSeg.points.length - 1];
        } else startP = points[0], endP = points[points.length - 1];
        var xTotalLength = abs(endP.x - startP.x),
          yTotalLength = abs(endP.y - startP.y);
        direction = Number.isFinite(xTotalLength + yTotalLength) ? xTotalLength > yTotalLength ? exports.Direction.ROW : exports.Direction.COLUMN : exports.Direction.ROW, drawAreaSegments(context.camera ? context : context.nativeContext, cache, clipRange, {
          offsetX: offsetX,
          offsetY: offsetY,
          offsetZ: offsetZ,
          direction: direction,
          drawConnect: connect,
          mode: connectedType,
          zeroX: connectedX,
          zeroY: connectedY
        }), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, drawContext, fillCb, null, {
          attribute: attribute
        }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute);
        var _attribute$x = attribute.x,
          originX = _attribute$x === void 0 ? 0 : _attribute$x,
          _attribute$x2 = attribute.x,
          originY = _attribute$x2 === void 0 ? 0 : _attribute$x2;
        if (!1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area, connect ? connectedStyle : attribute, originX - offsetX, originY - offsetY, connect ? da : defaultAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, drawContext, fillCb, null, {
          attribute: attribute
        }), !1 !== stroke) if (strokeCb) strokeCb(context, attribute, defaultAttribute);else {
          var _attribute$stroke = attribute.stroke,
            _stroke2 = _attribute$stroke === void 0 ? defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke : _attribute$stroke;
          isArray$1(_stroke2) && (_stroke2[0] || _stroke2[2]) && !1 === _stroke2[1] && (context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, _stroke2[0] ? cache.top : cache.bottom, clipRange, direction === exports.Direction.ROW ? "x" : "y", {
            offsetX: offsetX,
            offsetY: offsetY,
            offsetZ: offsetZ,
            drawConnect: connect,
            mode: connectedType,
            zeroX: connectedX,
            zeroY: connectedY
          })), context.setStrokeStyle(area, connect ? connectedStyle : attribute, originX - offsetX, originY - offsetY, connect ? da : defaultAttribute), context.stroke();
        }
        return !1;
      }
    }]);
    return DefaultCanvasAreaRender;
  }(BaseRender);
  exports.DefaultCanvasAreaRender = __decorate$1v([injectable(), __param$M(0, inject(ContributionProvider)), __param$M(0, named(AreaRenderContribution)), __metadata$19("design:paramtypes", [Object])], exports.DefaultCanvasAreaRender);

  var defaultPathTextureRenderContribution = defaultBaseTextureRenderContribution;
  var defaultPathBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

  var __decorate$1u = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$18 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$L = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultCanvasPathRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasPathRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasPathRender);
    function DefaultCanvasPathRender(pathRenderContribitions) {
      var _this;
      _classCallCheck(this, DefaultCanvasPathRender);
      _this = _super.call(this), _this.pathRenderContribitions = pathRenderContribitions, _this.numberType = PATH_NUMBER_TYPE, _this.builtinContributions = [defaultPathBackgroundRenderContribution, defaultPathTextureRenderContribution], _this.init(pathRenderContribitions);
      return _this;
    }
    _createClass(DefaultCanvasPathRender, [{
      key: "drawShape",
      value: function drawShape(path, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c;
        var pathAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(path, null == params ? void 0 : params.theme).path,
          _path$attribute = path.attribute,
          _path$attribute$x = _path$attribute.x,
          originX = _path$attribute$x === void 0 ? pathAttribute.x : _path$attribute$x,
          _path$attribute$y = _path$attribute.y,
          originY = _path$attribute$y === void 0 ? pathAttribute.y : _path$attribute$y,
          z = null !== (_b = this.z) && void 0 !== _b ? _b : 0,
          data = this.valid(path, pathAttribute, fillCb, strokeCb);
        if (!data) return;
        var fVisible = data.fVisible,
          sVisible = data.sVisible,
          doFill = data.doFill,
          doStroke = data.doStroke;
        if (context.beginPath(), path.pathShape) renderCommandList(path.pathShape.commandList, context, x, y, 1, 1, z);else {
          var path2D = null !== (_c = path.attribute.path) && void 0 !== _c ? _c : pathAttribute.path;
          renderCommandList(path2D.commandList, context, x, y, 1, 1, z);
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(path, path.attribute, pathAttribute), this.beforeRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb), doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.stroke())), doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.fill())), this.afterRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
      }
    }, {
      key: "draw",
      value: function draw(path, renderService, drawContext, params) {
        var pathAttribute = getTheme(path, null == params ? void 0 : params.theme).path;
        this.tempTheme = pathAttribute, this._draw(path, pathAttribute, !1, drawContext, params), this.tempTheme = null;
      }
    }]);
    return DefaultCanvasPathRender;
  }(BaseRender);
  exports.DefaultCanvasPathRender = __decorate$1u([injectable(), __param$L(0, inject(ContributionProvider)), __param$L(0, named(PathRenderContribution)), __metadata$18("design:paramtypes", [Object])], exports.DefaultCanvasPathRender);

  var __decorate$1t = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$17 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$K = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultCanvasRectRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasRectRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasRectRender);
    function DefaultCanvasRectRender(rectRenderContribitions) {
      var _this;
      _classCallCheck(this, DefaultCanvasRectRender);
      _this = _super.call(this), _this.rectRenderContribitions = rectRenderContribitions, _this.type = "rect", _this.numberType = RECT_NUMBER_TYPE, _this.builtinContributions = [defaultRectRenderContribution, defaultRectBackgroundRenderContribution, defaultRectTextureRenderContribution], _this.init(rectRenderContribitions);
      return _this;
    }
    _createClass(DefaultCanvasRectRender, [{
      key: "drawShape",
      value: function drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        var rectAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(rect, null == params ? void 0 : params.theme).rect,
          _rect$attribute = rect.attribute,
          _rect$attribute$fill = _rect$attribute.fill,
          fill = _rect$attribute$fill === void 0 ? rectAttribute.fill : _rect$attribute$fill,
          background = _rect$attribute.background,
          _rect$attribute$strok = _rect$attribute.stroke,
          stroke = _rect$attribute$strok === void 0 ? rectAttribute.stroke : _rect$attribute$strok,
          _rect$attribute$corne = _rect$attribute.cornerRadius,
          cornerRadius = _rect$attribute$corne === void 0 ? rectAttribute.cornerRadius : _rect$attribute$corne,
          _rect$attribute$opaci = _rect$attribute.opacity,
          opacity = _rect$attribute$opaci === void 0 ? rectAttribute.opacity : _rect$attribute$opaci,
          _rect$attribute$fillO = _rect$attribute.fillOpacity,
          fillOpacity = _rect$attribute$fillO === void 0 ? rectAttribute.fillOpacity : _rect$attribute$fillO,
          _rect$attribute$lineW = _rect$attribute.lineWidth,
          lineWidth = _rect$attribute$lineW === void 0 ? rectAttribute.lineWidth : _rect$attribute$lineW,
          _rect$attribute$strok2 = _rect$attribute.strokeOpacity,
          strokeOpacity = _rect$attribute$strok2 === void 0 ? rectAttribute.strokeOpacity : _rect$attribute$strok2,
          _rect$attribute$visib = _rect$attribute.visible,
          visible = _rect$attribute$visib === void 0 ? rectAttribute.visible : _rect$attribute$visib,
          x1 = _rect$attribute.x1,
          y1 = _rect$attribute.y1,
          _rect$attribute$x = _rect$attribute.x,
          originX = _rect$attribute$x === void 0 ? rectAttribute.x : _rect$attribute$x,
          _rect$attribute$y = _rect$attribute.y,
          originY = _rect$attribute$y === void 0 ? rectAttribute.y : _rect$attribute$y;
        var _rect$attribute2 = rect.attribute,
          width = _rect$attribute2.width,
          height = _rect$attribute2.height;
        width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
        var fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
          sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height),
          doFill = runFill(fill, background),
          doStroke = runStroke(stroke, lineWidth);
        if (!rect.valid || !visible) return;
        if (!doFill && !doStroke) return;
        if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
        0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(function (num) {
          return 0 === num;
        }) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius));
        var doFillOrStroke = {
          doFill: doFill,
          doStroke: doStroke
        };
        context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), this.beforeRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke), doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.stroke())), this.afterRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
      }
    }, {
      key: "draw",
      value: function draw(rect, renderService, drawContext, params) {
        var rectAttribute = getTheme(rect, null == params ? void 0 : params.theme).rect;
        this.tempTheme = rectAttribute, this._draw(rect, rectAttribute, !1, drawContext, params), this.tempTheme = null;
      }
    }]);
    return DefaultCanvasRectRender;
  }(BaseRender);
  exports.DefaultCanvasRectRender = __decorate$1t([injectable(), __param$K(0, inject(ContributionProvider)), __param$K(0, named(RectRenderContribution)), __metadata$17("design:paramtypes", [Object])], exports.DefaultCanvasRectRender);

  var __decorate$1s = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$16 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$J = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultCanvasSymbolRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasSymbolRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasSymbolRender);
    function DefaultCanvasSymbolRender(symbolRenderContribitions) {
      var _this;
      _classCallCheck(this, DefaultCanvasSymbolRender);
      _this = _super.call(this), _this.symbolRenderContribitions = symbolRenderContribitions, _this.numberType = SYMBOL_NUMBER_TYPE, _this.builtinContributions = [defaultSymbolRenderContribution, defaultSymbolBackgroundRenderContribution, defaultSymbolTextureRenderContribution], _this.init(symbolRenderContribitions);
      return _this;
    }
    _createClass(DefaultCanvasSymbolRender, [{
      key: "drawShape",
      value: function drawShape(symbol, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        var symbolAttribute = getTheme(symbol, null == params ? void 0 : params.theme).symbol,
          _symbol$attribute = symbol.attribute,
          _symbol$attribute$siz = _symbol$attribute.size,
          size = _symbol$attribute$siz === void 0 ? symbolAttribute.size : _symbol$attribute$siz,
          _symbol$attribute$x = _symbol$attribute.x,
          originX = _symbol$attribute$x === void 0 ? symbolAttribute.x : _symbol$attribute$x,
          _symbol$attribute$y = _symbol$attribute.y,
          originY = _symbol$attribute$y === void 0 ? symbolAttribute.y : _symbol$attribute$y,
          _symbol$attribute$sca = _symbol$attribute.scaleX,
          scaleX = _symbol$attribute$sca === void 0 ? symbolAttribute.scaleX : _symbol$attribute$sca,
          _symbol$attribute$sca2 = _symbol$attribute.scaleY,
          scaleY = _symbol$attribute$sca2 === void 0 ? symbolAttribute.scaleY : _symbol$attribute$sca2,
          data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
        if (!data) return;
        var fVisible = data.fVisible,
          sVisible = data.sVisible,
          doFill = data.doFill,
          doStroke = data.doStroke,
          parsedPath = symbol.getParsedPath();
        if (!parsedPath) return;
        var _symbol$attribute$kee = symbol.attribute.keepDirIn3d,
          keepDirIn3d = _symbol$attribute$kee === void 0 ? symbolAttribute.keepDirIn3d : _symbol$attribute$kee,
          z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
        if (context.beginPath(), keepDirIn3d && context.camera && context.project) {
          var p = context.project(x, y, z),
            camera = context.camera;
          context.camera = null, !1 === parsedPath.draw(context, isArray$1(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX, p.x, p.y, void 0, function (p, a) {
            var _a, _b, _c;
            if (symbol._parsedPath.svgCache) {
              var obj = Object.assign({}, a);
              obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : symbol.attribute.fill, obj.opacity = null !== (_b = a.fill) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, a = obj;
            }
            a.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a, originX - x, originY - y, symbolAttribute), context.fill())), a.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : (context.setStrokeStyle(symbol, a, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
          }) && context.closePath(), context.camera = camera;
        } else !1 === parsedPath.draw(context, size, x, y, z, function (p, a) {
          var _a, _b, _c;
          if (symbol._parsedPath.svgCache) {
            var obj = Object.assign({}, a);
            obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : symbol.attribute.fill, obj.opacity = null !== (_b = a.opacity) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, a = obj;
          }
          a.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a, originX - x, originY - y, symbolAttribute), context.fill())), a.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : (context.setStrokeStyle(symbol, a, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
        }) && context.closePath();
        context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), this.beforeRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb), doFill && !parsedPath.isSvg && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), context.fill())), doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke())), this.afterRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
      }
    }, {
      key: "draw",
      value: function draw(symbol, renderService, drawContext, params) {
        var symbolAttribute = getTheme(symbol, null == params ? void 0 : params.theme).symbol;
        this._draw(symbol, symbolAttribute, !1, drawContext, params);
      }
    }]);
    return DefaultCanvasSymbolRender;
  }(BaseRender);
  exports.DefaultCanvasSymbolRender = __decorate$1s([injectable(), __param$J(0, inject(ContributionProvider)), __param$J(0, named(SymbolRenderContribution)), __metadata$16("design:paramtypes", [Object])], exports.DefaultCanvasSymbolRender);

  var DefaultBoundsAllocate = /*#__PURE__*/function () {
    function DefaultBoundsAllocate() {
      _classCallCheck(this, DefaultBoundsAllocate);
      this.pools = [];
      for (var i = 0; i < 10; i++) this.pools.push(new AABBBounds());
    }
    _createClass(DefaultBoundsAllocate, [{
      key: "allocate",
      value: function allocate(x1, y1, x2, y2) {
        if (!this.pools.length) return new AABBBounds().setValue(x1, y1, x2, y2);
        var b = this.pools.pop();
        return b.x1 = x1, b.y1 = y1, b.x2 = x2, b.y2 = y2, b;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(b) {
        if (!this.pools.length) return new AABBBounds(b);
        var _b = this.pools.pop();
        return _b.x1 = b.x1, _b.y1 = b.y1, _b.x2 = b.x2, _b.y2 = b.y2, _b;
      }
    }, {
      key: "free",
      value: function free(b) {
        this.pools.push(b);
      }
    }, {
      key: "length",
      get: function get() {
        return this.pools.length;
      }
    }, {
      key: "release",
      value: function release() {
        this.pools = [];
      }
    }]);
    return DefaultBoundsAllocate;
  }();
  var boundsAllocate = new DefaultBoundsAllocate();

  var DefaultTextBackgroundRenderContribution = /*#__PURE__*/function (_DefaultBaseBackgroun) {
    _inherits(DefaultTextBackgroundRenderContribution, _DefaultBaseBackgroun);
    var _super = _createSuper(DefaultTextBackgroundRenderContribution);
    function DefaultTextBackgroundRenderContribution() {
      var _this;
      _classCallCheck(this, DefaultTextBackgroundRenderContribution);
      _this = _super.apply(this, arguments), _this.time = exports.BaseRenderContributionTime.beforeFillStroke;
      return _this;
    }
    _createClass(DefaultTextBackgroundRenderContribution, [{
      key: "drawShape",
      value: function drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var _graphic$attribute = graphic.attribute,
          _graphic$attribute$ba = _graphic$attribute.backgroundMode,
          backgroundMode = _graphic$attribute$ba === void 0 ? graphicAttribute.backgroundMode : _graphic$attribute$ba,
          _graphic$attribute$ba2 = _graphic$attribute.backgroundFit,
          backgroundFit = _graphic$attribute$ba2 === void 0 ? graphicAttribute.backgroundFit : _graphic$attribute$ba2;
        var b,
          background = graphic.attribute.background;
        if (!background) return;
        var shouldReCalBounds = isObject$1(background) && background.background,
          onlyTranslate = graphic.transMatrix.onlyTranslate();
        if (shouldReCalBounds) {
          var _b = graphic.AABBBounds,
            _x = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0),
            _y = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0),
            w = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(),
            h = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
          if (b = boundsAllocate.allocate(_x, _y, _x + w, _y + h), background = background.background, !onlyTranslate) {
            var _w = b.width(),
              _h2 = b.height();
            b.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), _w, _h2);
          }
        } else b = graphic.AABBBounds, onlyTranslate || (b = getTextBounds(Object.assign(Object.assign({}, graphic.attribute), {
          angle: 0,
          scaleX: 1,
          scaleY: 1,
          x: 0,
          y: 0,
          dx: 0,
          dy: 0
        })).clone());
        if (graphic.backgroundImg && graphic.resources) {
          var res = graphic.resources.get(background);
          if ("success" !== res.state || !res.data) return;
          context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.highPerformanceRestore(), context.setTransformForCurrent();
        } else {
          var backgroundCornerRadius = graphic.attribute.backgroundCornerRadius;
          context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = background, backgroundCornerRadius ? (createRectPath(context, b.x1, b.y1, b.width(), b.height(), backgroundCornerRadius), context.fill()) : context.fillRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore();
        }
        shouldReCalBounds && boundsAllocate.free(b);
      }
    }]);
    return DefaultTextBackgroundRenderContribution;
  }(DefaultBaseBackgroundRenderContribution);
  var defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

  var __decorate$1r = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$15 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$I = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultCanvasTextRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasTextRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasTextRender);
    function DefaultCanvasTextRender(textRenderContribitions) {
      var _this;
      _classCallCheck(this, DefaultCanvasTextRender);
      _this = _super.call(this), _this.textRenderContribitions = textRenderContribitions, _this.numberType = TEXT_NUMBER_TYPE, _this.builtinContributions = [defaultTextBackgroundRenderContribution], _this.init(textRenderContribitions);
      return _this;
    }
    _createClass(DefaultCanvasTextRender, [{
      key: "drawShape",
      value: function drawShape(text, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _this2 = this;
        var _a, _b, _c;
        var textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
          _text$attribute = text.attribute;
          _text$attribute.text;
          var _text$attribute$under = _text$attribute.underline,
          underline = _text$attribute$under === void 0 ? textAttribute.underline : _text$attribute$under,
          _text$attribute$lineT = _text$attribute.lineThrough,
          lineThrough = _text$attribute$lineT === void 0 ? textAttribute.lineThrough : _text$attribute$lineT,
          _text$attribute$keepD = _text$attribute.keepDirIn3d,
          keepDirIn3d = _text$attribute$keepD === void 0 ? textAttribute.keepDirIn3d : _text$attribute$keepD,
          _text$attribute$direc = _text$attribute.direction,
          direction = _text$attribute$direc === void 0 ? textAttribute.direction : _text$attribute$direc,
          _text$attribute$white = _text$attribute.whiteSpace;
          _text$attribute$white === void 0 ? textAttribute.whiteSpace : _text$attribute$white;
          var _text$attribute$fontS = _text$attribute.fontSize,
          fontSize = _text$attribute$fontS === void 0 ? textAttribute.fontSize : _text$attribute$fontS,
          _text$attribute$verti = _text$attribute.verticalMode,
          verticalMode = _text$attribute$verti === void 0 ? textAttribute.verticalMode : _text$attribute$verti,
          _text$attribute$x = _text$attribute.x,
          originX = _text$attribute$x === void 0 ? textAttribute.x : _text$attribute$x,
          _text$attribute$y = _text$attribute.y,
          originY = _text$attribute$y === void 0 ? textAttribute.y : _text$attribute$y;
        var _text$attribute2 = text.attribute,
          _text$attribute2$text = _text$attribute2.textAlign,
          textAlign = _text$attribute2$text === void 0 ? textAttribute.textAlign : _text$attribute2$text,
          _text$attribute2$text2 = _text$attribute2.textBaseline,
          textBaseline = _text$attribute2$text2 === void 0 ? textAttribute.textBaseline : _text$attribute2$text2;
        if (!verticalMode && "vertical" === direction) {
          var t = textAlign;
          textAlign = null !== (_a = text.getBaselineMapAlign()[textBaseline]) && void 0 !== _a ? _a : "left", textBaseline = null !== (_b = text.getAlignMapBaseline()[t]) && void 0 !== _b ? _b : "top";
        }
        var lineHeight = null !== (_c = calculateLineHeight(text.attribute.lineHeight, fontSize)) && void 0 !== _c ? _c : fontSize,
          data = this.valid(text, textAttribute, fillCb, strokeCb);
        if (!data) return;
        var fVisible = data.fVisible,
          sVisible = data.sVisible,
          doFill = data.doFill,
          doStroke = data.doStroke,
          transform3dMatrixToContextMatrix = !keepDirIn3d,
          z = this.z || 0;
        context.beginPath(), context.setShadowBlendStyle && context.setShadowBlendStyle(text, text.attribute, textAttribute), this.beforeRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb), transform3dMatrixToContextMatrix && this.transformUseContext2d(text, textAttribute, z, context);
        var drawText = function drawText(t, offsetX, offsetY, direction) {
          var _x = x + offsetX;
          var _y = y + offsetY;
          if (direction) {
            context.highPerformanceSave(), _x += fontSize;
            var matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
            matrix.rotateByCenter(Math.PI / 2, _x, _y), context.transformFromMatrix(matrix, !0), matrixAllocate.free(matrix);
          }
          doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.strokeText(t, _x, _y, z))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.fillText(t, _x, _y, z), _this2.drawUnderLine(underline, lineThrough, text, _x, _y, z, textAttribute, context))), direction && (context.highPerformanceRestore(), context.setTransformForCurrent());
        };
        if (text.isMultiLine) {
          if (context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z), "horizontal" === direction) {
            var multilineLayout = text.multilineLayout;
            if (!multilineLayout) return void context.highPerformanceRestore();
            var _multilineLayout$bbox = multilineLayout.bbox,
              xOffset = _multilineLayout$bbox.xOffset,
              yOffset = _multilineLayout$bbox.yOffset;
            doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(function (line) {
              context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
            }))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(function (line) {
              context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z), _this2.drawMultiUnderLine(underline, lineThrough, text, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y - textDrawOffsetY("bottom", fontSize) - .05 * fontSize, z, line.width, textAttribute, context);
            })));
          } else {
            text.tryUpdateAABBBounds();
            var cache = text.cache,
              verticalList = cache.verticalList;
            context.textAlign = "left", context.textBaseline = "top";
            var totalHeight = lineHeight * verticalList.length;
            var totalW = 0;
            verticalList.forEach(function (verticalData) {
              var _w = verticalData.reduce(function (a, b) {
                return a + (b.width || 0);
              }, 0);
              totalW = max(_w, totalW);
            });
            var offsetY = 0,
              offsetX = 0;
            "bottom" === textBaseline ? offsetX = -totalHeight : "middle" === textBaseline && (offsetX = -totalHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), verticalList.forEach(function (verticalData, i) {
              var currentW = verticalData.reduce(function (a, b) {
                  return a + (b.width || 0);
                }, 0),
                dw = totalW - currentW;
              var currentOffsetY = offsetY;
              "center" === textAlign ? currentOffsetY += dw / 2 : "right" === textAlign && (currentOffsetY += dw), verticalData.forEach(function (item) {
                var text = item.text,
                  width = item.width,
                  direction = item.direction;
                drawText(text, totalHeight - (i + 1) * lineHeight + offsetX, currentOffsetY, direction), currentOffsetY += width;
              });
            });
          }
        } else if ("horizontal" === direction) {
          context.setTextStyle(text.attribute, textAttribute, z);
          var _t = text.clipedText;
          var dy = 0;
          lineHeight !== fontSize && ("top" === textBaseline ? dy = (lineHeight - fontSize) / 2 : "middle" === textBaseline || "bottom" === textBaseline && (dy = -(lineHeight - fontSize) / 2)), drawText(_t, 0, dy, 0);
        } else {
          text.tryUpdateAABBBounds();
          var _cache = text.cache;
          if (_cache) {
            context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z);
            var _verticalList = _cache.verticalList;
            var _offsetY = 0;
            var _totalW = _verticalList[0].reduce(function (a, b) {
              return a + (b.width || 0);
            }, 0);
            var _offsetX = 0;
            "bottom" === textBaseline ? _offsetX = -lineHeight : "middle" === textBaseline && (_offsetX = -lineHeight / 2), "center" === textAlign ? _offsetY -= _totalW / 2 : "right" === textAlign && (_offsetY -= _totalW), context.textAlign = "left", context.textBaseline = "top", _verticalList[0].forEach(function (item) {
              var text = item.text,
                width = item.width,
                direction = item.direction;
              drawText(text, _offsetX, _offsetY, direction), _offsetY += width;
            });
          }
        }
        transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text, textAttribute, z, context), this.afterRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb);
      }
    }, {
      key: "draw",
      value: function draw(text, renderService, drawContext, params) {
        var textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
          _text$attribute$keepD2 = text.attribute.keepDirIn3d,
          keepDirIn3d = _text$attribute$keepD2 === void 0 ? textAttribute.keepDirIn3d : _text$attribute$keepD2,
          computed3dMatrix = !keepDirIn3d;
        this._draw(text, textAttribute, computed3dMatrix, drawContext, params);
      }
    }, {
      key: "drawUnderLine",
      value: function drawUnderLine(underline, lineThrough, text, x, y, z, textAttribute, context) {
        if (lineThrough + underline <= 0) return;
        var _text$attribute3 = text.attribute,
          _text$attribute3$text = _text$attribute3.textAlign,
          textAlign = _text$attribute3$text === void 0 ? textAttribute.textAlign : _text$attribute3$text,
          _text$attribute3$text2 = _text$attribute3.textBaseline,
          textBaseline = _text$attribute3$text2 === void 0 ? textAttribute.textBaseline : _text$attribute3$text2,
          _text$attribute3$font = _text$attribute3.fontSize,
          fontSize = _text$attribute3$font === void 0 ? textAttribute.fontSize : _text$attribute3$font,
          _text$attribute3$fill = _text$attribute3.fill,
          fill = _text$attribute3$fill === void 0 ? textAttribute.fill : _text$attribute3$fill,
          _text$attribute3$opac = _text$attribute3.opacity,
          opacity = _text$attribute3$opac === void 0 ? textAttribute.opacity : _text$attribute3$opac,
          _text$attribute3$unde = _text$attribute3.underlineOffset,
          underlineOffset = _text$attribute3$unde === void 0 ? textAttribute.underlineOffset : _text$attribute3$unde,
          _text$attribute3$unde2 = _text$attribute3.underlineDash,
          underlineDash = _text$attribute3$unde2 === void 0 ? textAttribute.underlineDash : _text$attribute3$unde2,
          _text$attribute3$fill2 = _text$attribute3.fillOpacity,
          fillOpacity = _text$attribute3$fill2 === void 0 ? textAttribute.fillOpacity : _text$attribute3$fill2,
          w = text.clipedWidth,
          offsetX = textDrawOffsetX(textAlign, w),
          offsetY = textLayoutOffsetY(textBaseline, fontSize, fontSize),
          attribute = {
            lineWidth: 0,
            stroke: fill,
            opacity: opacity,
            strokeOpacity: fillOpacity
          };
        if (underline) {
          attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, x, y, textAttribute), context.setLineDash(underlineDash), context.beginPath();
          var dy = y + offsetY + fontSize + underlineOffset;
          context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();
        }
        if (lineThrough) {
          attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, x, y, textAttribute), context.beginPath();
          var _dy = y + offsetY + fontSize / 2;
          context.moveTo(x + offsetX, _dy, z), context.lineTo(x + offsetX + w, _dy, z), context.stroke();
        }
      }
    }, {
      key: "drawMultiUnderLine",
      value: function drawMultiUnderLine(underline, lineThrough, text, x, y, z, w, textAttribute, context) {
        if (lineThrough + underline <= 0) return;
        var _text$attribute4 = text.attribute,
          _text$attribute4$font = _text$attribute4.fontSize,
          fontSize = _text$attribute4$font === void 0 ? textAttribute.fontSize : _text$attribute4$font,
          _text$attribute4$fill = _text$attribute4.fill,
          fill = _text$attribute4$fill === void 0 ? textAttribute.fill : _text$attribute4$fill,
          _text$attribute4$opac = _text$attribute4.opacity,
          opacity = _text$attribute4$opac === void 0 ? textAttribute.opacity : _text$attribute4$opac,
          _text$attribute4$unde = _text$attribute4.underlineOffset,
          underlineOffset = _text$attribute4$unde === void 0 ? textAttribute.underlineOffset : _text$attribute4$unde,
          _text$attribute4$unde2 = _text$attribute4.underlineDash,
          underlineDash = _text$attribute4$unde2 === void 0 ? textAttribute.underlineDash : _text$attribute4$unde2,
          _text$attribute4$fill2 = _text$attribute4.fillOpacity,
          fillOpacity = _text$attribute4$fill2 === void 0 ? textAttribute.fillOpacity : _text$attribute4$fill2,
          offsetY = textLayoutOffsetY("alphabetic", fontSize, fontSize),
          attribute = {
            lineWidth: 0,
            stroke: fill,
            opacity: opacity,
            strokeOpacity: fillOpacity
          };
        var deltaY = -3;
        if (underline) {
          attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, x, y, textAttribute), context.setLineDash(underlineDash), context.beginPath();
          var dy = y + offsetY + fontSize + deltaY + underlineOffset;
          context.moveTo(x + 0, dy, z), context.lineTo(x + 0 + w, dy, z), context.stroke();
        }
        if (deltaY = -1, lineThrough) {
          attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, x, y, textAttribute), context.beginPath();
          var _dy2 = y + offsetY + fontSize / 2 + deltaY;
          context.moveTo(x + 0, _dy2, z), context.lineTo(x + 0 + w, _dy2, z), context.stroke();
        }
      }
    }]);
    return DefaultCanvasTextRender;
  }(BaseRender);
  exports.DefaultCanvasTextRender = __decorate$1r([injectable(), __param$I(0, inject(ContributionProvider)), __param$I(0, named(TextRenderContribution)), __metadata$15("design:paramtypes", [Object])], exports.DefaultCanvasTextRender);

  var __decorate$1q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  exports.AbstractGraphicRender = /*#__PURE__*/_createClass(function AbstractGraphicRender() {
    _classCallCheck(this, AbstractGraphicRender);
  });
  exports.AbstractGraphicRender = __decorate$1q([injectable()], exports.AbstractGraphicRender);

  function drawPolygon(path, points, x, y) {
    path.moveTo(points[0].x + x, points[0].y + y);
    for (var i = 1; i < points.length; i++) path.lineTo(points[i].x + x, points[i].y + y);
  }
  function drawRoundedPolygon(path, points, x, y, cornerRadius) {
    var closePath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !0;
    var _a;
    if (points.length < 3) return void drawPolygon(path, points, x, y);
    var startI = 0,
      endI = points.length - 1;
    closePath || (startI += 1, endI -= 1, path.moveTo(points[0].x + x, points[0].y + y));
    for (var i = startI; i <= endI; i++) {
      var p1 = points[0 === i ? endI : (i - 1) % points.length],
        angularPoint = points[i % points.length],
        p2 = points[(i + 1) % points.length],
        dx1 = angularPoint.x - p1.x,
        dy1 = angularPoint.y - p1.y,
        dx2 = angularPoint.x - p2.x,
        dy2 = angularPoint.y - p2.y,
        angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2,
        tan = Math.abs(Math.tan(angle));
      var radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[i % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius,
        segment = radius / tan;
      var length1 = getLength(dx1, dy1),
        length2 = getLength(dx2, dy2),
        length = Math.min(length1, length2);
      segment > length && (segment = length, radius = length * tan);
      var p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1),
        p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2),
        dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x,
        dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y,
        L = getLength(dx, dy),
        circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);
      var startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
      var endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
      var sweepAngle = endAngle - startAngle;
      sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), path.lineTo(p2Cross.x + x, p2Cross.y + y);
    }
    closePath || path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);
  }
  function getLength(dx, dy) {
    return Math.sqrt(dx * dx + dy * dy);
  }
  function getProportionPoint(point, segment, length, dx, dy) {
    var factor = segment / length;
    return {
      x: point.x - dx * factor,
      y: point.y - dy * factor
    };
  }

  var defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
  var defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

  var __decorate$1p = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$14 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$H = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultCanvasPolygonRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasPolygonRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasPolygonRender);
    function DefaultCanvasPolygonRender(polygonRenderContribitions) {
      var _this;
      _classCallCheck(this, DefaultCanvasPolygonRender);
      _this = _super.call(this), _this.polygonRenderContribitions = polygonRenderContribitions, _this.numberType = POLYGON_NUMBER_TYPE, _this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution], _this.init(polygonRenderContribitions);
      return _this;
    }
    _createClass(DefaultCanvasPolygonRender, [{
      key: "drawShape",
      value: function drawShape(polygon, context, x, y, drawContext, params, fillCb, strokeCb) {
        var polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon,
          _polygon$attribute = polygon.attribute,
          _polygon$attribute$po = _polygon$attribute.points,
          points = _polygon$attribute$po === void 0 ? polygonAttribute.points : _polygon$attribute$po,
          _polygon$attribute$co = _polygon$attribute.cornerRadius,
          cornerRadius = _polygon$attribute$co === void 0 ? polygonAttribute.cornerRadius : _polygon$attribute$co,
          _polygon$attribute$x = _polygon$attribute.x,
          originX = _polygon$attribute$x === void 0 ? polygonAttribute.x : _polygon$attribute$x,
          _polygon$attribute$y = _polygon$attribute.y,
          originY = _polygon$attribute$y === void 0 ? polygonAttribute.y : _polygon$attribute$y,
          _polygon$attribute$cl = _polygon$attribute.closePath,
          closePath = _polygon$attribute$cl === void 0 ? polygonAttribute.closePath : _polygon$attribute$cl,
          data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
        if (!data) return;
        var fVisible = data.fVisible,
          sVisible = data.sVisible,
          doFill = data.doFill,
          doStroke = data.doStroke;
        context.beginPath(), cornerRadius <= 0 || isArray$1(cornerRadius) && cornerRadius.every(function (num) {
          return 0 === num;
        }) ? drawPolygon(context.camera ? context : context.nativeContext, points, x, y) : drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius, closePath), closePath && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute), this.beforeRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb), doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fVisible && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.fill())), doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : sVisible && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.stroke())), this.afterRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
      }
    }, {
      key: "draw",
      value: function draw(polygon, renderService, drawContext, params) {
        var polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon;
        this._draw(polygon, polygonAttribute, !1, drawContext, params);
      }
    }]);
    return DefaultCanvasPolygonRender;
  }(BaseRender);
  exports.DefaultCanvasPolygonRender = __decorate$1p([injectable(), __param$H(0, inject(ContributionProvider)), __param$H(0, named(PolygonRenderContribution)), __metadata$14("design:paramtypes", [Object])], exports.DefaultCanvasPolygonRender);

  var __decorate$1o = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$13 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$G = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
  exports.DefaultCanvasImageRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasImageRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasImageRender);
    function DefaultCanvasImageRender(imageRenderContribitions) {
      var _this;
      _classCallCheck(this, DefaultCanvasImageRender);
      _this = _super.call(this), _this.imageRenderContribitions = imageRenderContribitions, _this.numberType = IMAGE_NUMBER_TYPE, _this.builtinContributions = [defaultImageBackgroundRenderContribution], _this.init(imageRenderContribitions);
      return _this;
    }
    _createClass(DefaultCanvasImageRender, [{
      key: "drawShape",
      value: function drawShape(image, context, x, y, drawContext, params, fillCb) {
        var imageAttribute = getTheme(image).image,
          _image$attribute = image.attribute,
          _image$attribute$widt = _image$attribute.width,
          width = _image$attribute$widt === void 0 ? imageAttribute.width : _image$attribute$widt,
          _image$attribute$heig = _image$attribute.height,
          height = _image$attribute$heig === void 0 ? imageAttribute.height : _image$attribute$heig,
          _image$attribute$repe = _image$attribute.repeatX,
          repeatX = _image$attribute$repe === void 0 ? imageAttribute.repeatX : _image$attribute$repe,
          _image$attribute$repe2 = _image$attribute.repeatY,
          repeatY = _image$attribute$repe2 === void 0 ? imageAttribute.repeatY : _image$attribute$repe2,
          _image$attribute$corn = _image$attribute.cornerRadius,
          cornerRadius = _image$attribute$corn === void 0 ? imageAttribute.cornerRadius : _image$attribute$corn,
          url = _image$attribute.image,
          data = this.valid(image, imageAttribute, fillCb);
        if (!data) return;
        var fVisible = data.fVisible;
          data.sVisible;
          var doFill = data.doFill;
          data.doStroke;
        if (context.setShadowBlendStyle && context.setShadowBlendStyle(image, imageAttribute), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), doFill) if (fillCb) fillCb(context, image.attribute, imageAttribute);else if (fVisible) {
          if (!url || !image.resources) return;
          var res = image.resources.get(url);
          if ("success" !== res.state) return;
          var needRestore = !1;
          0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(function (num) {
            return 0 === num;
          }) || (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius), context.save(), context.clip(), needRestore = !0), context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
          var repeat = 0;
          if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), repeat) {
            var pattern = context.createPattern(res.data, repeatStr[repeat]);
            context.fillStyle = pattern, context.translate(x, y, !0), context.fillRect(0, 0, width, height), context.translate(-x, -y, !0);
          } else context.drawImage(res.data, x, y, width, height);
          needRestore && context.restore();
        }
        this.afterRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb);
      }
    }, {
      key: "draw",
      value: function draw(image, renderService, drawContext) {
        var url = image.attribute.image;
        if (!url || !image.resources) return;
        var res = image.resources.get(url);
        if ("loading" === res.state && isString$1(url)) return void ResourceLoader.improveImageLoading(url);
        if ("success" !== res.state) return;
        var context = renderService.drawParams.context;
        if (!context) return;
        var imageAttribute = getTheme(image).image;
        this._draw(image, imageAttribute, !1, drawContext);
      }
    }]);
    return DefaultCanvasImageRender;
  }(BaseRender);
  exports.DefaultCanvasImageRender = __decorate$1o([injectable(), __param$G(0, inject(ContributionProvider)), __param$G(0, named(ImageRenderContribution)), __metadata$13("design:paramtypes", [Object])], exports.DefaultCanvasImageRender);

  var IncrementalDrawContribution = Symbol["for"]("IncrementalDrawContribution");
  var ArcRender = Symbol["for"]("ArcRender");
  var Arc3dRender = Symbol["for"]("Arc3dRender");
  var AreaRender = Symbol["for"]("AreaRender");
  var CircleRender = Symbol["for"]("CircleRender");
  var GraphicRender = Symbol["for"]("GraphicRender");
  var GroupRender = Symbol["for"]("GroupRender");
  var LineRender = Symbol["for"]("LineRender");
  var PathRender = Symbol["for"]("PathRender");
  var PolygonRender = Symbol["for"]("PolygonRender");
  var RectRender = Symbol["for"]("RectRender");
  var Rect3DRender = Symbol["for"]("Rect3DRender");
  var SymbolRender = Symbol["for"]("SymbolRender");
  var TextRender = Symbol["for"]("TextRender");
  var RichTextRender = Symbol["for"]("RichTextRender");
  var Pyramid3dRender = Symbol["for"]("Pyramid3dRender");
  var GlyphRender = Symbol["for"]("GlyphRender");
  var ImageRender = Symbol["for"]("ImageRender");
  var RenderSelector = Symbol["for"]("RenderSelector");
  var DrawContribution = Symbol["for"]("DrawContribution");

  var __decorate$1n = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$12 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var DrawItemInterceptor = Symbol["for"]("DrawItemInterceptor");
  var tempDirtyBounds = new AABBBounds();
  var ShadowRootDrawItemInterceptorContribution = /*#__PURE__*/function () {
    function ShadowRootDrawItemInterceptorContribution() {
      _classCallCheck(this, ShadowRootDrawItemInterceptorContribution);
      this.order = 1;
    }
    _createClass(ShadowRootDrawItemInterceptorContribution, [{
      key: "afterDrawItem",
      value: function afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx) && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
      }
    }, {
      key: "beforeDrawItem",
      value: function beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return graphic.attribute.shadowRootIdx < 0 && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
      }
    }, {
      key: "drawItem",
      value: function drawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.shadowRoot) return !1;
        var context = drawContext.context;
        if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, !0), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
          tempDirtyBounds.copy(drawContribution.dirtyBounds);
          var m = graphic.globalTransMatrix.getInverse();
          drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m);
        }
        return drawContribution.renderGroup(graphic.shadowRoot, drawContext, graphic.parent.globalTransMatrix), context.highPerformanceRestore(), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && drawContribution.dirtyBounds.copy(tempDirtyBounds), !0;
      }
    }]);
    return ShadowRootDrawItemInterceptorContribution;
  }();
  var DebugDrawItemInterceptorContribution = /*#__PURE__*/function () {
    function DebugDrawItemInterceptorContribution() {
      _classCallCheck(this, DebugDrawItemInterceptorContribution);
      this.order = 1;
    }
    _createClass(DebugDrawItemInterceptorContribution, [{
      key: "afterDrawItem",
      value: function afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return graphic.attribute._debug_bounds && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
      }
    }, {
      key: "drawItem",
      value: function drawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.attribute._debug_bounds) return !1;
        var context = drawContext.context;
        context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, !0);
        var b = graphic.AABBBounds;
        return !0 !== graphic.attribute._debug_bounds && graphic.attribute._debug_bounds(context, graphic), context.strokeRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), !0;
      }
    }]);
    return DebugDrawItemInterceptorContribution;
  }();
  exports.CommonDrawItemInterceptorContribution = /*#__PURE__*/function () {
    function CommonDrawItemInterceptorContribution() {
      _classCallCheck(this, CommonDrawItemInterceptorContribution);
      this.order = 1, this.interceptors = [new ShadowRootDrawItemInterceptorContribution(), new Canvas3DDrawItemInterceptor(), new InteractiveDrawItemInterceptorContribution(), new DebugDrawItemInterceptorContribution()];
    }
    _createClass(CommonDrawItemInterceptorContribution, [{
      key: "afterDrawItem",
      value: function afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        for (var i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].afterDrawItem && this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
        return !1;
      }
    }, {
      key: "beforeDrawItem",
      value: function beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return !1;
        for (var i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].beforeDrawItem && this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
        return !1;
      }
    }]);
    return CommonDrawItemInterceptorContribution;
  }();
  exports.CommonDrawItemInterceptorContribution = __decorate$1n([injectable(), __metadata$12("design:paramtypes", [])], exports.CommonDrawItemInterceptorContribution);
  var InteractiveDrawItemInterceptorContribution = /*#__PURE__*/function () {
    function InteractiveDrawItemInterceptorContribution() {
      _classCallCheck(this, InteractiveDrawItemInterceptorContribution);
      this.order = 1;
    }
    _createClass(InteractiveDrawItemInterceptorContribution, [{
      key: "beforeDrawItem",
      value: function beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        return !this.processing && (graphic.baseGraphic ? this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) : this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params));
      }
    }, {
      key: "beforeSetInteractive",
      value: function beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params) {
        var interactiveGraphic = graphic.interactiveGraphic;
        if (graphic.attribute.globalZIndex) {
          interactiveGraphic || (interactiveGraphic = graphic.clone(), graphic.interactiveGraphic = interactiveGraphic, interactiveGraphic.baseGraphic = graphic), interactiveGraphic.setAttributes({
            globalZIndex: 0,
            zIndex: graphic.attribute.globalZIndex
          }, !1, {
            skipUpdateCallback: !0
          }), drawContext.stage.tryInitInteractiveLayer();
          var interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
          if (interactiveLayer) {
            this.getShadowRoot(interactiveLayer).add(interactiveGraphic);
          }
          return !0;
        }
        if (interactiveGraphic) {
          drawContext.stage.tryInitInteractiveLayer();
          var _interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
          if (_interactiveLayer) {
            this.getShadowRoot(_interactiveLayer).removeChild(interactiveGraphic);
          }
          graphic.interactiveGraphic = null, interactiveGraphic.baseGraphic = null;
        }
        return !1;
      }
    }, {
      key: "beforeDrawInteractive",
      value: function beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) {
        var baseGraphic = graphic.baseGraphic;
        if (baseGraphic) {
          this.processing = !0;
          var context = drawContext.context;
          return context.highPerformanceSave(), context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, !0), baseGraphic.isContainer ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix) : drawContribution.renderItem(baseGraphic, drawContext), context.highPerformanceRestore(), this.processing = !1, !0;
        }
        return !1;
      }
    }, {
      key: "getShadowRoot",
      value: function getShadowRoot(interactiveLayer) {
        var _a;
        var group = interactiveLayer.getElementById("_interactive_group");
        return group || (group = graphicCreator.CreateGraphic("group", {}), group.id = "_interactive_group", interactiveLayer.add(group)), null !== (_a = group.shadowRoot) && void 0 !== _a ? _a : group.attachShadow();
      }
    }]);
    return InteractiveDrawItemInterceptorContribution;
  }();
  var Canvas3DDrawItemInterceptor = /*#__PURE__*/function () {
    function Canvas3DDrawItemInterceptor() {
      _classCallCheck(this, Canvas3DDrawItemInterceptor);
      this.order = 1;
    }
    _createClass(Canvas3DDrawItemInterceptor, [{
      key: "beforeDrawItem",
      value: function beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.in3dMode || drawContext.in3dInterceptor) return !1;
        drawContext.in3dInterceptor = !0;
        var _renderService$drawPa = renderService.drawParams,
          context = _renderService$drawPa.context,
          stage = _renderService$drawPa.stage;
        context.canvas;
        context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
        var m = context.currentMatrix;
        m.a /= context.dpr, m.b /= context.dpr, m.c /= context.dpr, m.d /= context.dpr, m.e /= context.dpr, m.f /= context.dpr;
        var matrix = mat4Allocate.allocate();
        mat3Tomat4(matrix, m);
        var lastModelMatrix = context.modelMatrix;
        if (lastModelMatrix) {
          if (matrix) {
            var _m = mat4Allocate.allocate();
            context.modelMatrix = multiplyMat4Mat4(_m, lastModelMatrix, matrix);
          }
        } else context.modelMatrix = matrix;
        if (context.setTransform(1, 0, 0, 1, 0, 0, !0), graphic.isContainer) {
          var isPie = !1,
            is3d = !1;
          if (graphic.forEachChildren(function (c) {
            return isPie = c.numberType === ARC3D_NUMBER_TYPE, !isPie;
          }), graphic.forEachChildren(function (c) {
            return is3d = !!c.findFace, !is3d;
          }), isPie) {
            var children = graphic.getChildren(),
              sortedChildren = _toConsumableArray(children);
            sortedChildren.sort(function (a, b) {
              var _a, _b, _c, _d;
              var angle1 = ((null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0) + (null !== (_b = a.attribute.endAngle) && void 0 !== _b ? _b : 0)) / 2,
                angle2 = ((null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0) + (null !== (_d = b.attribute.endAngle) && void 0 !== _d ? _d : 0)) / 2;
              for (; angle1 < 0;) angle1 += pi2;
              for (; angle2 < 0;) angle2 += pi2;
              return angle2 - angle1;
            }), sortedChildren.forEach(function (c) {
              c._next = null, c._prev = null;
            }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach(function (c) {
              graphic.appendChild(c);
            });
            var _m2 = graphic.parent.globalTransMatrix;
            drawContext.hack_pieFace = "outside", drawContribution.renderGroup(graphic, drawContext, _m2), drawContext.hack_pieFace = "inside", drawContribution.renderGroup(graphic, drawContext, _m2), drawContext.hack_pieFace = "top", drawContribution.renderGroup(graphic, drawContext, _m2), graphic.removeAllChild(), children.forEach(function (c) {
              c._next = null, c._prev = null;
            }), children.forEach(function (c) {
              graphic.appendChild(c);
            });
          } else if (is3d) {
            var _children = graphic.getChildren(),
              zChildren = _children.map(function (g) {
                return {
                  ave_z: g.findFace().vertices.map(function (v) {
                    var _a;
                    return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
                  }).reduce(function (a, b) {
                    return a + b;
                  }, 0),
                  g: g
                };
              });
            zChildren.sort(function (a, b) {
              return b.ave_z - a.ave_z;
            }), graphic.removeAllChild(), zChildren.forEach(function (i) {
              i.g._next = null, i.g._prev = null;
            }), graphic.update(), zChildren.forEach(function (i) {
              graphic.add(i.g);
            }), drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, !0), graphic.removeAllChild(), _children.forEach(function (g) {
              g._next = null, g._prev = null;
            }), graphic.update(), _children.forEach(function (g) {
              graphic.add(g);
            });
          } else drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix);
        } else drawContribution.renderItem(graphic, drawContext);
        return context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = !1, !0;
      }
    }, {
      key: "initCanvasCtx",
      value: function initCanvasCtx(context) {
        context.setTransformForCurrent();
      }
    }]);
    return Canvas3DDrawItemInterceptor;
  }();

  var __decorate$1m = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$11 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$F = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var RenderService = Symbol["for"]("RenderService");
  var BeforeRenderConstribution = Symbol["for"]("BeforeRenderConstribution");
  exports.DefaultRenderService = /*#__PURE__*/function () {
    function DefaultRenderService(drawContribution) {
      _classCallCheck(this, DefaultRenderService);
      this.drawContribution = drawContribution;
    }
    _createClass(DefaultRenderService, [{
      key: "prepare",
      value: function prepare(updateBounds) {
        var _this = this;
        updateBounds && this.renderTreeRoots.forEach(function (g) {
          _this._prepare(g, updateBounds);
        });
      }
    }, {
      key: "_prepare",
      value: function _prepare(g, updateBounds) {
        var _this2 = this;
        g.forEachChildren(function (g) {
          _this2._prepare(g, updateBounds);
        }), g.update({
          bounds: updateBounds,
          trans: !0
        });
      }
    }, {
      key: "prepareRenderList",
      value: function prepareRenderList() {}
    }, {
      key: "beforeDraw",
      value: function beforeDraw(params) {}
    }, {
      key: "draw",
      value: function draw(params) {
        this.drawContribution.draw(this, Object.assign({}, this.drawParams));
      }
    }, {
      key: "afterDraw",
      value: function afterDraw(params) {
        this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
      }
    }, {
      key: "render",
      value: function render(groups, params) {
        this.renderTreeRoots = groups, this.drawParams = params;
        var updateBounds = params.updateBounds;
        this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params), this.draw(params), this.afterDraw(params);
      }
    }]);
    return DefaultRenderService;
  }();
  exports.DefaultRenderService = __decorate$1m([injectable(), __param$F(0, inject(DrawContribution)), __metadata$11("design:paramtypes", [Object])], exports.DefaultRenderService);

  var renderModule$1 = new ContainerModule(function (bind) {
    bind(RenderService).to(exports.DefaultRenderService).inSingletonScope();
  });

  var GraphicPicker = Symbol["for"]("GraphicPicker");
  var PickerService = Symbol["for"]("PickerService");
  var BoundsPicker = Symbol["for"]("BoundsPicker");
  var GlobalPickerService = Symbol["for"]("GlobalPickerService");

  var __decorate$1l = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var PickItemInterceptor = Symbol["for"]("PickItemInterceptor");
  exports.ShadowRootPickItemInterceptorContribution = /*#__PURE__*/function () {
    function ShadowRootPickItemInterceptorContribution() {
      _classCallCheck(this, ShadowRootPickItemInterceptorContribution);
      this.order = 1;
    }
    _createClass(ShadowRootPickItemInterceptorContribution, [{
      key: "afterPickItem",
      value: function afterPickItem(graphic, pickerService, point, pickParams, params) {
        return graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
      }
    }, {
      key: "beforePickItem",
      value: function beforePickItem(graphic, pickerService, point, pickParams, params) {
        return graphic.attribute.shadowRootIdx < 0 ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
      }
    }, {
      key: "_pickItem",
      value: function _pickItem(graphic, pickerService, point, pickParams, params) {
        if (!graphic.shadowRoot) return null;
        var _ref = params || {},
          parentMatrix = _ref.parentMatrix;
        if (!parentMatrix) return null;
        var context = pickerService.pickContext;
        context.highPerformanceSave();
        var g = graphic.shadowRoot,
          currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix),
          newPoint = new Point(currentGroupMatrix.a * point.x + currentGroupMatrix.c * point.y + currentGroupMatrix.e, currentGroupMatrix.b * point.x + currentGroupMatrix.d * point.y + currentGroupMatrix.f),
          result = pickerService.pickGroup(g, newPoint, currentGroupMatrix, pickParams);
        return context.highPerformanceRestore(), result;
      }
    }]);
    return ShadowRootPickItemInterceptorContribution;
  }();
  exports.ShadowRootPickItemInterceptorContribution = __decorate$1l([injectable()], exports.ShadowRootPickItemInterceptorContribution);
  exports.InteractivePickItemInterceptorContribution = /*#__PURE__*/function () {
    function InteractivePickItemInterceptorContribution() {
      _classCallCheck(this, InteractivePickItemInterceptorContribution);
      this.order = 1;
    }
    _createClass(InteractivePickItemInterceptorContribution, [{
      key: "beforePickItem",
      value: function beforePickItem(graphic, pickerService, point, pickParams, params) {
        var originGraphic = graphic.baseGraphic;
        if (originGraphic && originGraphic.parent) {
          var newPoint = new Point(point.x, point.y),
            context = pickerService.pickContext;
          context.highPerformanceSave();
          var parentMatrix = originGraphic.parent.globalTransMatrix;
          parentMatrix.transformPoint(newPoint, newPoint);
          var result = originGraphic.isContainer ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams) : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
          return context.highPerformanceRestore(), result;
        }
        return null;
      }
    }]);
    return InteractivePickItemInterceptorContribution;
  }();
  exports.InteractivePickItemInterceptorContribution = __decorate$1l([injectable()], exports.InteractivePickItemInterceptorContribution);
  exports.Canvas3DPickItemInterceptor = /*#__PURE__*/function () {
    function Canvas3DPickItemInterceptor() {
      _classCallCheck(this, Canvas3DPickItemInterceptor);
      this.order = 1;
    }
    _createClass(Canvas3DPickItemInterceptor, [{
      key: "beforePickItem",
      value: function beforePickItem(graphic, pickerService, point, pickParams, params) {
        if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;
        var context = pickerService.pickContext,
          stage = graphic.stage;
        if (!context || !stage) return null;
        if (pickParams.in3dInterceptor = !0, context.save(), this.initCanvasCtx(context), context.camera = stage.camera, graphic.isContainer) {
          var result,
            isPie = !1,
            is3d = !1;
          if (graphic.forEachChildren(function (c) {
            return isPie = c.numberType === ARC3D_NUMBER_TYPE, !isPie;
          }), graphic.forEachChildren(function (c) {
            return is3d = !!c.findFace, !is3d;
          }), isPie) {
            var children = graphic.getChildren(),
              sortedChildren = _toConsumableArray(children);
            sortedChildren.sort(function (a, b) {
              var _a, _b, _c, _d;
              var angle1 = (null !== (_b = null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0 + a.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2,
                angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
              for (; angle1 < 0;) angle1 += pi2;
              for (; angle2 < 0;) angle2 += pi2;
              return angle2 - angle1;
            }), sortedChildren.forEach(function (c) {
              c._next = null, c._prev = null;
            }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach(function (c) {
              graphic.appendChild(c);
            }), pickParams.hack_pieFace = "outside", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), result.graphic || (pickParams.hack_pieFace = "inside", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams)), result.graphic || (pickParams.hack_pieFace = "top", result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams)), graphic.removeAllChild(), children.forEach(function (c) {
              c._next = null, c._prev = null;
            }), children.forEach(function (c) {
              graphic.appendChild(c);
            });
          } else if (is3d) {
            var _children = graphic.getChildren(),
              zChildren = _children.map(function (g) {
                return {
                  ave_z: g.findFace().vertices.map(function (v) {
                    var _a;
                    return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
                  }).reduce(function (a, b) {
                    return a + b;
                  }, 0),
                  g: g
                };
              });
            zChildren.sort(function (a, b) {
              return b.ave_z - a.ave_z;
            }), graphic.removeAllChild(), zChildren.forEach(function (i) {
              i.g._next = null, i.g._prev = null;
            }), graphic.update(), zChildren.forEach(function (i) {
              graphic.add(i.g);
            }), result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), graphic.removeAllChild(), _children.forEach(function (g) {
              g._next = null, g._prev = null;
            }), graphic.update(), _children.forEach(function (g) {
              graphic.add(g);
            });
          } else result = pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);
          return context.camera = null, pickParams.in3dInterceptor = !1, context.restore(), result;
        }
        return context.restore(), null;
      }
    }, {
      key: "initCanvasCtx",
      value: function initCanvasCtx(context) {
        context.setTransformForCurrent();
      }
    }]);
    return Canvas3DPickItemInterceptor;
  }();
  exports.Canvas3DPickItemInterceptor = __decorate$1l([injectable()], exports.Canvas3DPickItemInterceptor);

  var pickModule = new ContainerModule(function (bind, unbind, isBound) {
    isBound(PickerService) || (bind(GlobalPickerService).toSelf(), bind(PickerService).toService(GlobalPickerService)), bind(exports.Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(exports.Canvas3DPickItemInterceptor), bind(exports.ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(exports.ShadowRootPickItemInterceptorContribution), bind(exports.InteractivePickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(exports.InteractivePickItemInterceptorContribution), bindContributionProvider(bind, PickItemInterceptor);
  });

  var graphicModule = new ContainerModule(function (bind) {
    bind(GraphicService).to(exports.DefaultGraphicService).inSingletonScope(), bind(GraphicCreator$1).toConstantValue(graphicCreator);
  });

  var AutoEnablePlugins = Symbol["for"]("AutoEnablePlugins");
  var PluginService = Symbol["for"]("PluginService");

  var __decorate$1k = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$10 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$E = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultPluginService = /*#__PURE__*/function () {
    function DefaultPluginService(autoEnablePlugins) {
      _classCallCheck(this, DefaultPluginService);
      this.autoEnablePlugins = autoEnablePlugins, this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = !1;
    }
    _createClass(DefaultPluginService, [{
      key: "active",
      value: function active(stage, params) {
        var _this = this;
        this.stage = stage, this.actived = !0;
        var pluginList = params.pluginList;
        pluginList && container.isBound(AutoEnablePlugins) && this.autoEnablePlugins.getContributions().forEach(function (p) {
          pluginList.includes(p.name) && _this.register(p);
        });
      }
    }, {
      key: "findPluginsByName",
      value: function findPluginsByName(name) {
        var arr = [];
        return this.onStartupFinishedPlugin.forEach(function (plugin) {
          plugin.name === name && arr.push(plugin);
        }), this.onRegisterPlugin.forEach(function (plugin) {
          plugin.name === name && arr.push(plugin);
        }), arr;
      }
    }, {
      key: "register",
      value: function register(plugin) {
        "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : "onRegister" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), plugin.activate(this));
      }
    }, {
      key: "unRegister",
      value: function unRegister(plugin) {
        "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1) : "onRegister" === plugin.activeEvent && this.onRegisterPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1), plugin.deactivate(this);
      }
    }, {
      key: "release",
      value: function release() {
        var _this2 = this;
        this.onStartupFinishedPlugin.forEach(function (plugin) {
          plugin.deactivate(_this2);
        }), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach(function (plugin) {
          plugin.deactivate(_this2);
        }), this.onRegisterPlugin = [];
      }
    }]);
    return DefaultPluginService;
  }();
  DefaultPluginService = __decorate$1k([injectable(), __param$E(0, inject(ContributionProvider)), __param$E(0, named(AutoEnablePlugins)), __metadata$10("design:paramtypes", [Object])], DefaultPluginService);

  var pluginModule = new ContainerModule(function (bind) {
    bind(PluginService).to(DefaultPluginService), bindContributionProviderNoSingletonScope(bind, AutoEnablePlugins);
  });

  var envModules = new ContainerModule(function (bind) {
    bindContributionProvider(bind, EnvContribution);
  });

  var textMeasureModules = new ContainerModule(function (bind) {
    bind(TextMeasureContribution).to(exports.DefaultTextMeasureContribution).inSingletonScope(), bindContributionProvider(bind, TextMeasureContribution);
  });

  var __decorate$1j = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$$ = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var CanvasLayerHandlerContribution = /*#__PURE__*/function () {
    function CanvasLayerHandlerContribution() {
      _classCallCheck(this, CanvasLayerHandlerContribution);
      this.type = "static", this.offscreen = !1, this.global = application.global;
    }
    _createClass(CanvasLayerHandlerContribution, [{
      key: "setDpr",
      value: function setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
    }, {
      key: "init",
      value: function init(layer, window, params) {
        if (this.layer = layer, this.window = window, params.main) this.main = !0, this.context = window.getContext(), this.canvas = this.context.getCanvas();else {
          var nativeCanvas;
          this.main = !1, params.canvasId && (nativeCanvas = this.global.getElementById(params.canvasId)), nativeCanvas || (nativeCanvas = this.global.createCanvas({
            width: window.width,
            height: window.height
          })), nativeCanvas.style && (nativeCanvas.style["pointer-events"] = "none");
          var windowCanvas = window.getContext().getCanvas().nativeCanvas,
            canvas = wrapCanvas({
              nativeCanvas: nativeCanvas,
              width: window.width,
              height: window.height,
              dpr: window.dpr,
              id: params.canvasId,
              canvasControled: !0,
              container: window.getContainer(),
              x: windowCanvas.offsetLeft,
              y: windowCanvas.offsetTop
            });
          canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();
        }
      }
    }, {
      key: "resize",
      value: function resize(w, h) {
        this.canvas.resize(w, h);
      }
    }, {
      key: "resizeView",
      value: function resizeView(w, h) {}
    }, {
      key: "render",
      value: function render(group, params, userParams) {
        var _a;
        if (!this.main) {
          var windowCanvas = this.window.getContext().getCanvas().nativeCanvas;
          !windowCanvas || this.canvas.x === windowCanvas.offsetLeft && this.canvas.y === windowCanvas.offsetTop || (this.canvas.x = windowCanvas.offsetLeft, this.canvas.y = windowCanvas.offsetTop, this.canvas.applyPosition());
        }
        params.renderService.render(group, Object.assign(Object.assign({
          context: this.context,
          clear: null !== (_a = params.background) && void 0 !== _a ? _a : "#ffffff"
        }, params), userParams));
      }
    }, {
      key: "merge",
      value: function merge(layerHandlers) {
        var _this = this;
        layerHandlers.forEach(function (l) {
          var canvas = l.getContext().canvas.nativeCanvas;
          _this.context.drawImage(canvas, 0, 0);
        });
      }
    }, {
      key: "prepare",
      value: function prepare(dirtyBounds, params) {}
    }, {
      key: "drawTo",
      value: function drawTo(target, group, params) {
        var _a;
        var context = target.getContext();
        params.renderService.render(group, Object.assign(Object.assign({
          context: context
        }, params), {
          clear: params.clear ? null !== (_a = params.background) && void 0 !== _a ? _a : "#fff" : void 0
        }));
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.context;
      }
    }, {
      key: "release",
      value: function release() {
        this.canvas.release();
      }
    }]);
    return CanvasLayerHandlerContribution;
  }();
  CanvasLayerHandlerContribution = __decorate$1j([injectable(), __metadata$$("design:paramtypes", [])], CanvasLayerHandlerContribution);

  var __decorate$1i = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$_ = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var EmptyLayerHandlerContribution = /*#__PURE__*/function () {
    function EmptyLayerHandlerContribution() {
      _classCallCheck(this, EmptyLayerHandlerContribution);
      this.offscreen = !1, this.type = "virtual", this.global = application.global;
    }
    _createClass(EmptyLayerHandlerContribution, [{
      key: "setDpr",
      value: function setDpr(dpr) {}
    }, {
      key: "init",
      value: function init(layer, window, params) {
        if (this.layer = layer, this.window = window, params.main) throw new Error("virtual layer不能作为main layer");
        this.main = !1, this.canvas = null, this.context = null;
      }
    }, {
      key: "resize",
      value: function resize(w, h) {}
    }, {
      key: "resizeView",
      value: function resizeView(w, h) {}
    }, {
      key: "render",
      value: function render(group, params, userParams) {
        this.mainHandler.render(group, params, Object.assign(Object.assign({}, userParams), {
          clear: !1
        }));
      }
    }, {
      key: "merge",
      value: function merge(layerHandlers) {}
    }, {
      key: "prepare",
      value: function prepare(dirtyBounds, params) {}
    }, {
      key: "drawTo",
      value: function drawTo(target, group, params) {
        var _a;
        var context = target.getContext();
        params.renderService.render(group, Object.assign(Object.assign({
          context: context
        }, params), {
          clear: params.clear ? null !== (_a = params.background) && void 0 !== _a ? _a : "#fff" : void 0
        }));
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return null;
      }
    }, {
      key: "release",
      value: function release() {}
    }]);
    return EmptyLayerHandlerContribution;
  }();
  EmptyLayerHandlerContribution = __decorate$1i([injectable(), __metadata$_("design:paramtypes", [])], EmptyLayerHandlerContribution);

  var __decorate$1h = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$Z = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var OffscreenLayerHandlerContribution = /*#__PURE__*/function () {
    function OffscreenLayerHandlerContribution() {
      _classCallCheck(this, OffscreenLayerHandlerContribution);
      this.offscreen = !0, this.type = "dynamic", this.global = application.global;
    }
    _createClass(OffscreenLayerHandlerContribution, [{
      key: "setDpr",
      value: function setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
    }, {
      key: "init",
      value: function init(layer, window, params) {
        this.layer = layer;
        var nativeCanvas = this.global.createOffscreenCanvas({
            width: params.width,
            height: params.height,
            dpr: window.dpr
          }),
          canvas = wrapCanvas({
            nativeCanvas: nativeCanvas,
            width: params.width,
            height: params.height,
            dpr: window.dpr,
            canvasControled: !0
          });
        this.canvas = canvas, this.context = canvas.getContext();
      }
    }, {
      key: "resize",
      value: function resize(w, h) {
        this.canvas.resize(w, h);
      }
    }, {
      key: "resizeView",
      value: function resizeView(w, h) {
        this.canvas.resize(w, h);
      }
    }, {
      key: "render",
      value: function render(group, params) {
        var _a;
        params.renderService.render(group, Object.assign(Object.assign({
          context: this.context,
          viewBox: params.stage.window.getViewBox(),
          transMatrix: params.stage.window.getViewBoxTransform()
        }, params), {
          clear: null !== (_a = params.background) && void 0 !== _a ? _a : "#ffffff"
        }));
      }
    }, {
      key: "prepare",
      value: function prepare(dirtyBounds, params) {}
    }, {
      key: "release",
      value: function release() {
        this.canvas.release();
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.context;
      }
    }, {
      key: "drawTo",
      value: function drawTo(target, group, params) {
        var context = target.getContext(),
          targetDpr = target.dpr,
          viewBox = params.viewBox,
          x = viewBox.x1,
          y = viewBox.y1,
          width = viewBox.width(),
          height = viewBox.height();
        context.nativeContext.save(), context.nativeContext.setTransform(targetDpr, 0, 0, targetDpr, 0, 0), params.clear && context.clearRect(x, y, width, height), context.drawImage(this.canvas.nativeCanvas, 0, 0, this.canvas.width, this.canvas.height, x, y, width, height), context.nativeContext.restore();
      }
    }, {
      key: "merge",
      value: function merge(layerHandlers) {}
    }]);
    return OffscreenLayerHandlerContribution;
  }();
  OffscreenLayerHandlerContribution = __decorate$1h([injectable(), __metadata$Z("design:paramtypes", [])], OffscreenLayerHandlerContribution);

  var layerHandlerModules = new ContainerModule(function (bind) {
    bind(CanvasLayerHandlerContribution).toSelf(), bind(OffscreenLayerHandlerContribution).toSelf(), bind(EmptyLayerHandlerContribution).toSelf(), bind(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution), bind(DynamicLayerHandlerContribution).toService(OffscreenLayerHandlerContribution), bind(VirtualLayerHandlerContribution).toService(EmptyLayerHandlerContribution);
  });

  function load$1(container) {
    container.load(envModules), container.load(textMeasureModules), container.load(layerHandlerModules);
  }

  var __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function foreach(graphic, defaultZIndex, cb) {
    var reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var sort3d = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    var childMap = {},
      zIdxArray = [];
    var needSort = !1;
    if (sort3d) needSort = !0;else {
      var lastZIndex;
      graphic.forEachChildren(function (item, i) {
        var _item$attribute$zInde = item.attribute.zIndex,
          zIndex = _item$attribute$zInde === void 0 ? defaultZIndex : _item$attribute$zInde;
        if (0 === i) lastZIndex = zIndex;else if (lastZIndex !== zIndex) return needSort = !0, !0;
        return !1;
      }, reverse);
    }
    if (needSort) {
      graphic.forEachChildren(function (item) {
        var _item$attribute$zInde2 = item.attribute.zIndex,
          zIndex = _item$attribute$zInde2 === void 0 ? defaultZIndex : _item$attribute$zInde2;
        childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
      }, reverse), zIdxArray.sort(function (a, b) {
        return reverse ? b - a : a - b;
      });
      var skip = !1;
      for (var i = 0; i < zIdxArray.length && !skip; i++) {
        var idx = zIdxArray[i],
          children = childMap[idx];
        sort3d && children.sort(function (a, b) {
          var _a, _b;
          return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a.attribute.z) && void 0 !== _b ? _b : 0));
        });
        for (var _i = 0; _i < children.length; _i++) if (cb(children[_i], _i)) {
          skip = !0;
          break;
        }
      }
    } else graphic.forEachChildren(cb, reverse);
  }
  function foreachAsync(graphic, defaultZIndex, cb) {
    var reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    return __awaiter$3(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return graphic.forEachChildrenAsync(cb, reverse);
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
  }
  function findNextGraphic(graphic, id, defaultZIndex) {
    var reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    var childMap = {},
      zIdxArray = [];
    var needSort = !1;
    graphic.forEachChildren(function (item, i) {
      var _item$attribute$zInde3 = item.attribute.zIndex,
        zIndex = _item$attribute$zInde3 === void 0 ? defaultZIndex : _item$attribute$zInde3;
      if (0 === i) ;else if (undefined !== zIndex) return needSort = !0, !0;
      return !1;
    }, reverse);
    var result = null,
      next = !1;
    if (needSort) {
      graphic.forEachChildren(function (item) {
        var _item$attribute$zInde4 = item.attribute.zIndex,
          zIndex = _item$attribute$zInde4 === void 0 ? defaultZIndex : _item$attribute$zInde4;
        childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
      }, reverse), zIdxArray.sort(function (a, b) {
        return reverse ? b - a : a - b;
      });
      var skip = !1;
      for (var i = 0; i < zIdxArray.length && !skip; i++) {
        var idx = zIdxArray[i],
          children = childMap[idx];
        for (var _i2 = 0; _i2 < children.length; _i2++) {
          if (next) {
            skip = !0, result = children[_i2];
            break;
          }
          children[_i2]._uid !== id || (next = !0);
        }
      }
    } else graphic.forEachChildren(function (item) {
      return next ? (result = item, !0) : (item._uid === id && (next = !0), !1);
    }, reverse);
    return result;
  }

  var __decorate$1g = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$Y = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$D = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultDrawContribution = /*#__PURE__*/function () {
    function DefaultDrawContribution(contributions, drawItemInterceptorContributions) {
      _classCallCheck(this, DefaultDrawContribution);
      this.contributions = contributions, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.currentRenderMap = new Map(), this.defaultRenderMap = new Map(), this.styleRenderMap = new Map(), this.dirtyBounds = new Bounds(), this.backupDirtyBounds = new Bounds(), this.global = application.global, this.layerService = application.layerService, this.init();
    }
    _createClass(DefaultDrawContribution, [{
      key: "init",
      value: function init() {
        var _this = this;
        this.contributions.forEach(function (item) {
          if (item.style) {
            var map = _this.styleRenderMap.get(item.style) || new Map();
            map.set(item.numberType, item), _this.styleRenderMap.set(item.style, map);
          } else _this.defaultRenderMap.set(item.numberType, item);
        }), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort(function (a, b) {
          return a.order - b.order;
        });
      }
    }, {
      key: "prepareForDraw",
      value: function prepareForDraw(renderService, drawContext) {
        drawContext.updateBounds ? this.useDirtyBounds = !0 : this.useDirtyBounds = !drawContext.stage.params.optimize.disableCheckGraphicWidthOutRange;
      }
    }, {
      key: "draw",
      value: function draw(renderService, drawContext) {
        var _this2 = this;
        this.prepareForDraw(renderService, drawContext), drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, this.currentRenderService = renderService;
        var context = drawContext.context,
          stage = drawContext.stage,
          viewBox = drawContext.viewBox,
          transMatrix = drawContext.transMatrix;
        if (!context) return;
        var dirtyBounds = this.dirtyBounds.setValue(0, 0, viewBox.width(), viewBox.height());
        if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
          var b = getRectIntersect(dirtyBounds, stage.dirtyBounds, !1);
          dirtyBounds.x1 = Math.floor(b.x1), dirtyBounds.y1 = Math.floor(b.y1), dirtyBounds.x2 = Math.ceil(b.x2), dirtyBounds.y2 = Math.ceil(b.y2);
        }
        var d = context.dpr % 1;
        (d || .5 !== d) && (dirtyBounds.x1 = Math.floor(dirtyBounds.x1 * context.dpr) / context.dpr, dirtyBounds.y1 = Math.floor(dirtyBounds.y1 * context.dpr) / context.dpr, dirtyBounds.x2 = Math.ceil(dirtyBounds.x2 * context.dpr) / context.dpr, dirtyBounds.y2 = Math.ceil(dirtyBounds.y2 * context.dpr) / context.dpr), this.backupDirtyBounds.copy(dirtyBounds), context.inuse = !0, context.setClearMatrix(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), context.clearMatrix(), context.setTransformForCurrent(!0), context.translate(viewBox.x1, viewBox.y1, !0), context.beginPath(), context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), context.clip(), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), context.save(), renderService.renderTreeRoots.sort(function (a, b) {
          var _a, _b;
          return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
        }).forEach(function (group) {
          group.isContainer ? _this2.renderGroup(group, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)) : _this2.renderItem(group, drawContext);
        }), context.restore(), context.draw(), context.setClearMatrix(1, 0, 0, 1, 0, 0), context.inuse = !1;
      }
    }, {
      key: "doRegister",
      value: function doRegister() {
        throw new Error("暂不支持");
      }
    }, {
      key: "_findNextGraphic",
      value: function _findNextGraphic(group) {
        var parent = group.parent,
          id = group._uid;
        for (; parent;) {
          var g = findNextGraphic(parent, id, DefaultAttribute.zIndex);
          if (g) return g;
          id = parent._uid, parent = parent.parent;
        }
        return null;
      }
    }, {
      key: "renderGroup",
      value: function renderGroup(group, drawContext, parentMatrix, skipSort) {
        var _this3 = this;
        if (drawContext["break"] || !1 === group.attribute.visibleAll) return;
        if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid)) return drawContext["break"] = !0, void this._increaseRender(group, drawContext);
        if (this.useDirtyBounds && !isRectIntersect(group.AABBBounds, this.dirtyBounds, !1)) return;
        var tempBounds,
          nextM = parentMatrix;
        if (this.useDirtyBounds) {
          tempBounds = boundsAllocate.allocateByObj(this.dirtyBounds);
          var gm = group.transMatrix;
          nextM = matrixAllocate.allocateByObj(parentMatrix).multiply(gm.a, gm.b, gm.c, gm.d, gm.e, gm.f), this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(nextM.getInverse());
        }
        this.renderItem(group, drawContext, {
          drawingCb: function drawingCb() {
            var _a;
            skipSort ? group.forEachChildren(function (item) {
              drawContext["break"] || (item.isContainer ? _this3.renderGroup(item, drawContext, nextM) : _this3.renderItem(item, drawContext));
            }) : foreach(group, DefaultAttribute.zIndex, function (item) {
              drawContext["break"] || (item.isContainer ? _this3.renderGroup(item, drawContext, nextM) : _this3.renderItem(item, drawContext));
            }, !1, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));
          }
        }), this.useDirtyBounds && (this.dirtyBounds.copy(tempBounds), boundsAllocate.free(tempBounds), matrixAllocate.free(nextM));
      }
    }, {
      key: "_increaseRender",
      value: function _increaseRender(group, drawContext) {
        var layer = drawContext.layer,
          stage = drawContext.stage,
          subLayers = layer.subLayers;
        var incrementalLayer = subLayers.get(group._uid);
        incrementalLayer || (incrementalLayer = {
          layer: this.layerService.createLayer(stage),
          zIndex: subLayers.size,
          group: group
        }, subLayers.set(group._uid, incrementalLayer));
        var incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(),
          idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
        idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
          drawContribution: idc,
          clear: "transparent",
          layer: incrementalLayer.layer,
          context: incrementalContext,
          startAtId: group._uid,
          "break": !1
        })), incrementalLayer.drawContribution = idc;
        var nextGraphic = this._findNextGraphic(group);
        if (nextGraphic) if (nextGraphic.isContainer && nextGraphic.incremental) this._increaseRender(nextGraphic, drawContext);else {
          var afterLayer = subLayers.get(nextGraphic._uid);
          afterLayer || (afterLayer = {
            layer: this.layerService.createLayer(stage),
            zIndex: subLayers.size
          }, subLayers.set(nextGraphic._uid, afterLayer));
          var afterContext = afterLayer.layer.getNativeHandler().getContext();
          this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
            drawContribution: idc,
            clear: "transparent",
            layer: afterLayer.layer,
            context: afterContext,
            startAtId: nextGraphic._uid,
            "break": !1
          }));
        }
      }
    }, {
      key: "getRenderContribution",
      value: function getRenderContribution(graphic) {
        var renderer;
        return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType, graphic)), renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;
      }
    }, {
      key: "renderItem",
      value: function renderItem(graphic, drawContext, params) {
        if (this.InterceptorContributions.length) for (var i = 0; i < this.InterceptorContributions.length; i++) {
          var drawContribution = this.InterceptorContributions[i];
          if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params)) return;
        }
        var renderer = this.getRenderContribution(graphic);
        if (!renderer) return;
        var tempBounds,
          retrans = !1;
        if (graphic.parent) {
          var _graphic$parent$attri = graphic.parent.attribute,
            _graphic$parent$attri2 = _graphic$parent$attri.scrollX,
            scrollX = _graphic$parent$attri2 === void 0 ? 0 : _graphic$parent$attri2,
            _graphic$parent$attri3 = _graphic$parent$attri.scrollY,
            scrollY = _graphic$parent$attri3 === void 0 ? 0 : _graphic$parent$attri3;
          if (retrans = !(!scrollX && !scrollY), retrans) {
            tempBounds = this.dirtyBounds.clone();
            var m = graphic.globalTransMatrix.getInverse();
            this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(m), this.dirtyBounds.translate(-scrollX, -scrollY);
          }
        }
        if (this.useDirtyBounds && !graphic.isContainer && !isRectIntersect(graphic.AABBBounds, this.dirtyBounds, !1)) return void (retrans && this.dirtyBounds.copy(tempBounds));
        var skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;
        if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params && (params.skipDraw = skipDraw), skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params) : renderer.draw(graphic, this.currentRenderService, drawContext, params), retrans && this.dirtyBounds.copy(tempBounds), this.InterceptorContributions.length) for (var _i = 0; _i < this.InterceptorContributions.length; _i++) {
          var _drawContribution = this.InterceptorContributions[_i];
          if (_drawContribution.afterDrawItem && _drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) return;
        }
      }
    }, {
      key: "selectRenderByType",
      value: function selectRenderByType(type) {
        return Logger.getInstance().warn("未知错误，不应该走到这里"), null;
      }
    }, {
      key: "selectRenderByNumberType",
      value: function selectRenderByNumberType(type, graphic) {
        var data;
        if (graphic.attribute.renderStyle) {
          var currentRenderMap = this.styleRenderMap.get(graphic.attribute.renderStyle);
          data = currentRenderMap && currentRenderMap.get(type);
        }
        return data || this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
      }
    }, {
      key: "clearScreen",
      value: function clearScreen(renderService, context, drawContext) {
        var _a, _b;
        var clear = drawContext.clear,
          viewBox = drawContext.viewBox,
          width = viewBox.width(),
          height = viewBox.height();
        if (clear) {
          context.clearRect(0, 0, width, height);
          var stage = null === (_a = renderService.drawParams) || void 0 === _a ? void 0 : _a.stage;
          if (stage && (context.globalAlpha = null !== (_b = stage.attribute.opacity) && void 0 !== _b ? _b : 1), stage && stage.backgroundImg && stage.resources) {
            var res = stage.resources.get(clear);
            res && "success" === res.state && res.data && context.drawImage(res.data, 0, 0, width, height);
          } else context.fillStyle = createColor(context, clear, {
            AABBBounds: {
              x1: 0,
              y1: 0,
              x2: 0 + width,
              y2: 0 + height
            }
          }, 0, 0), context.fillRect(0, 0, width, height);
        }
      }
    }, {
      key: "afterDraw",
      value: function afterDraw(renderService, drawParams) {}
    }]);
    return DefaultDrawContribution;
  }();
  DefaultDrawContribution = __decorate$1g([injectable(), __param$D(0, multiInject(GraphicRender)), __param$D(1, inject(ContributionProvider)), __param$D(1, named(DrawItemInterceptor)), __metadata$Y("design:paramtypes", [Array, Object])], DefaultDrawContribution);

  var __decorate$1f = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$X = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$C = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasGroupRender = /*#__PURE__*/function () {
    function DefaultCanvasGroupRender(groupRenderContribitions) {
      _classCallCheck(this, DefaultCanvasGroupRender);
      this.groupRenderContribitions = groupRenderContribitions, this.numberType = GROUP_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasGroupRender, [{
      key: "drawShape",
      value: function drawShape(group, context, x, y, drawContext, params, fillCb, strokeCb) {
        var groupAttribute = getTheme(group, null == params ? void 0 : params.theme).group,
          _group$attribute = group.attribute,
          _group$attribute$fill = _group$attribute.fill,
          fill = _group$attribute$fill === void 0 ? groupAttribute.fill : _group$attribute$fill,
          background = _group$attribute.background,
          _group$attribute$stro = _group$attribute.stroke,
          stroke = _group$attribute$stro === void 0 ? groupAttribute.stroke : _group$attribute$stro,
          _group$attribute$opac = _group$attribute.opacity,
          opacity = _group$attribute$opac === void 0 ? groupAttribute.opacity : _group$attribute$opac,
          _group$attribute$widt = _group$attribute.width,
          width = _group$attribute$widt === void 0 ? groupAttribute.width : _group$attribute$widt,
          _group$attribute$heig = _group$attribute.height,
          height = _group$attribute$heig === void 0 ? groupAttribute.height : _group$attribute$heig,
          _group$attribute$clip = _group$attribute.clip,
          clip = _group$attribute$clip === void 0 ? groupAttribute.clip : _group$attribute$clip,
          _group$attribute$fill2 = _group$attribute.fillOpacity,
          fillOpacity = _group$attribute$fill2 === void 0 ? groupAttribute.fillOpacity : _group$attribute$fill2,
          _group$attribute$stro2 = _group$attribute.strokeOpacity,
          strokeOpacity = _group$attribute$stro2 === void 0 ? groupAttribute.strokeOpacity : _group$attribute$stro2,
          _group$attribute$corn = _group$attribute.cornerRadius,
          cornerRadius = _group$attribute$corn === void 0 ? groupAttribute.cornerRadius : _group$attribute$corn,
          _group$attribute$path = _group$attribute.path,
          path = _group$attribute$path === void 0 ? groupAttribute.path : _group$attribute$path,
          _group$attribute$line = _group$attribute.lineWidth,
          lineWidth = _group$attribute$line === void 0 ? groupAttribute.lineWidth : _group$attribute$line,
          _group$attribute$visi = _group$attribute.visible,
          visible = _group$attribute$visi === void 0 ? groupAttribute.visible : _group$attribute$visi,
          fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
          sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height),
          doFill = runFill(fill, background),
          doStroke = runStroke(stroke, lineWidth);
        if (!group.valid || !visible) return;
        if (!clip) {
          if (!doFill && !doStroke) return;
          if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
        }
        if (path && path.length && drawContext.drawContribution) {
          var disableFill = context.disableFill,
            disableStroke = context.disableStroke,
            disableBeginPath = context.disableBeginPath;
          context.disableFill = !0, context.disableStroke = !0, context.disableBeginPath = !0, path.forEach(function (g) {
            drawContext.drawContribution.getRenderContribution(g).draw(g, drawContext.renderService, drawContext, params);
          }), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;
        } else 0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(function (num) {
          return 0 === num;
        }) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius));
        this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution));
        var doFillOrStroke = {
          doFill: doFill,
          doStroke: doStroke
        };
        this._groupRenderContribitions.forEach(function (c) {
          c.time === exports.BaseRenderContributionTime.beforeFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
        }), clip && context.clip(), context.setShadowBlendStyle && context.setShadowBlendStyle(group, group.attribute, groupAttribute), doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, x, y, groupAttribute), context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, x, y, groupAttribute), context.stroke())), this._groupRenderContribitions.forEach(function (c) {
          c.time === exports.BaseRenderContributionTime.afterFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb);
        });
      }
    }, {
      key: "draw",
      value: function draw(group, renderService, drawContext, params) {
        var context = drawContext.context;
        if (!context) return;
        var clip = group.attribute.clip;
        clip ? context.save() : context.highPerformanceSave();
        var groupAttribute = getTheme(group, null == params ? void 0 : params.theme).group,
          lastModelMatrix = context.modelMatrix;
        if (context.camera) {
          var nextModelMatrix = mat4Allocate.allocate(),
            modelMatrix = mat4Allocate.allocate();
          getModelMatrix(modelMatrix, group, groupAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, !0);
        } else context.transformFromMatrix(group.transMatrix, !0);
        context.beginPath(), params.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params, function () {
          return !1;
        }, function () {
          return !1;
        }) : this.drawShape(group, context, 0, 0, drawContext);
        var _group$attribute2 = group.attribute,
          _group$attribute2$scr = _group$attribute2.scrollX,
          scrollX = _group$attribute2$scr === void 0 ? groupAttribute.scrollX : _group$attribute2$scr,
          _group$attribute2$scr2 = _group$attribute2.scrollY,
          scrollY = _group$attribute2$scr2 === void 0 ? groupAttribute.scrollY : _group$attribute2$scr2;
        var p;
        (scrollX || scrollY) && context.translate(scrollX, scrollY), params && params.drawingCb && (p = params.drawingCb()), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, p && p.then ? p.then(function () {
          clip ? context.restore() : context.highPerformanceRestore();
        }) : clip ? context.restore() : context.highPerformanceRestore();
      }
    }]);
    return DefaultCanvasGroupRender;
  }();
  DefaultCanvasGroupRender = __decorate$1f([injectable(), __param$C(0, inject(ContributionProvider)), __param$C(0, named(GroupRenderContribution)), __metadata$X("design:paramtypes", [Object])], DefaultCanvasGroupRender);

  var __decorate$1e = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultIncrementalCanvasLineRender = /*#__PURE__*/function (_DefaultCanvasLineRen) {
    _inherits(DefaultIncrementalCanvasLineRender, _DefaultCanvasLineRen);
    var _super = _createSuper(DefaultIncrementalCanvasLineRender);
    function DefaultIncrementalCanvasLineRender() {
      var _this;
      _classCallCheck(this, DefaultIncrementalCanvasLineRender);
      _this = _super.apply(this, arguments), _this.numberType = LINE_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultIncrementalCanvasLineRender, [{
      key: "drawShape",
      value: function drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
        if (line.incremental && drawContext.multiGraphicOptions) {
          var _drawContext$multiGra = drawContext.multiGraphicOptions,
            startAtIdx = _drawContext$multiGra.startAtIdx,
            length = _drawContext$multiGra.length,
            _line$attribute$segme = line.attribute.segments,
            segments = _line$attribute$segme === void 0 ? [] : _line$attribute$segme;
          if (startAtIdx > segments.length) return;
          var lineAttribute = getTheme(line).line,
            _line$attribute = line.attribute,
            _line$attribute$fill = _line$attribute.fill,
            fill = _line$attribute$fill === void 0 ? lineAttribute.fill : _line$attribute$fill,
            _line$attribute$strok = _line$attribute.stroke,
            stroke = _line$attribute$strok === void 0 ? lineAttribute.stroke : _line$attribute$strok,
            _line$attribute$opaci = _line$attribute.opacity,
            opacity = _line$attribute$opaci === void 0 ? lineAttribute.opacity : _line$attribute$opaci,
            _line$attribute$fillO = _line$attribute.fillOpacity,
            fillOpacity = _line$attribute$fillO === void 0 ? lineAttribute.fillOpacity : _line$attribute$fillO,
            _line$attribute$strok2 = _line$attribute.strokeOpacity,
            strokeOpacity = _line$attribute$strok2 === void 0 ? lineAttribute.strokeOpacity : _line$attribute$strok2,
            _line$attribute$lineW = _line$attribute.lineWidth,
            lineWidth = _line$attribute$lineW === void 0 ? lineAttribute.lineWidth : _line$attribute$lineW,
            _line$attribute$visib = _line$attribute.visible,
            visible = _line$attribute$visib === void 0 ? lineAttribute.visible : _line$attribute$visib,
            fVisible = fillVisible(opacity, fillOpacity, fill),
            sVisible = strokeVisible(opacity, strokeOpacity),
            doFill = runFill(fill),
            doStroke = runStroke(stroke, lineWidth);
          if (!line.valid || !visible) return;
          if (!doFill && !doStroke) return;
          if (!(fVisible || sVisible || fillCb || strokeCb)) return;
          var _context = drawContext.context;
          for (var i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(line, _context, segments[i - 1], segments[i], line.attribute.segments[i], [lineAttribute, line.attribute], x, y);
        } else _get(_getPrototypeOf(DefaultIncrementalCanvasLineRender.prototype), "drawShape", this).call(this, line, context, x, y, drawContext, params, fillCb, strokeCb);
      }
    }, {
      key: "drawIncreaseSegment",
      value: function drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
        seg && (context.beginPath(), drawIncrementalSegments(context.nativeContext, lastSeg, seg, {
          offsetX: offsetX,
          offsetY: offsetY
        }), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute), context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
      }
    }]);
    return DefaultIncrementalCanvasLineRender;
  }(exports.DefaultCanvasLineRender);
  DefaultIncrementalCanvasLineRender = __decorate$1e([injectable()], DefaultIncrementalCanvasLineRender);

  var __decorate$1d = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultIncrementalCanvasAreaRender = /*#__PURE__*/function (_DefaultCanvasAreaRen) {
    _inherits(DefaultIncrementalCanvasAreaRender, _DefaultCanvasAreaRen);
    var _super = _createSuper(DefaultIncrementalCanvasAreaRender);
    function DefaultIncrementalCanvasAreaRender() {
      var _this;
      _classCallCheck(this, DefaultIncrementalCanvasAreaRender);
      _this = _super.apply(this, arguments), _this.numberType = AREA_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultIncrementalCanvasAreaRender, [{
      key: "drawShape",
      value: function drawShape(area, context, x, y, drawContext, params, fillCb) {
        if (area.incremental && drawContext.multiGraphicOptions) {
          var _drawContext$multiGra = drawContext.multiGraphicOptions,
            startAtIdx = _drawContext$multiGra.startAtIdx,
            length = _drawContext$multiGra.length,
            _area$attribute$segme = area.attribute.segments,
            segments = _area$attribute$segme === void 0 ? [] : _area$attribute$segme;
          if (startAtIdx > segments.length) return;
          var areaAttribute = getTheme(area).area,
            _area$attribute = area.attribute,
            _area$attribute$fill = _area$attribute.fill,
            fill = _area$attribute$fill === void 0 ? areaAttribute.fill : _area$attribute$fill,
            _area$attribute$fillO = _area$attribute.fillOpacity,
            fillOpacity = _area$attribute$fillO === void 0 ? areaAttribute.fillOpacity : _area$attribute$fillO,
            _area$attribute$opaci = _area$attribute.opacity,
            opacity = _area$attribute$opaci === void 0 ? areaAttribute.opacity : _area$attribute$opaci,
            _area$attribute$visib = _area$attribute.visible,
            visible = _area$attribute$visib === void 0 ? areaAttribute.visible : _area$attribute$visib,
            fVisible = fillVisible(opacity, fillOpacity, fill),
            doFill = runFill(fill);
          if (!area.valid || !visible) return;
          if (!doFill) return;
          if (!fVisible && !fillCb) return;
          for (var i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(area, context, segments[i - 1], segments[i], area.attribute.segments[i], [areaAttribute, area.attribute], x, y);
        } else _get(_getPrototypeOf(DefaultIncrementalCanvasAreaRender.prototype), "drawShape", this).call(this, area, context, x, y, drawContext, params, fillCb);
      }
    }, {
      key: "drawIncreaseSegment",
      value: function drawIncreaseSegment(area, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
        seg && (context.beginPath(), drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
          offsetX: offsetX,
          offsetY: offsetY
        }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute), context.setCommonStyle(area, attribute, offsetX, offsetY, defaultAttribute), context.fill());
      }
    }]);
    return DefaultIncrementalCanvasAreaRender;
  }(exports.DefaultCanvasAreaRender);
  DefaultIncrementalCanvasAreaRender = __decorate$1d([injectable()], DefaultIncrementalCanvasAreaRender);

  var STATUS,
    __decorate$1c = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$W = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$B = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    },
    __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
  !function (STATUS) {
    STATUS[STATUS.NORMAL = 0] = "NORMAL", STATUS[STATUS.STOP = 1] = "STOP";
  }(STATUS || (STATUS = {}));
  var DefaultIncrementalDrawContribution = /*#__PURE__*/function (_DefaultDrawContribut) {
    _inherits(DefaultIncrementalDrawContribution, _DefaultDrawContribut);
    var _super = _createSuper(DefaultIncrementalDrawContribution);
    function DefaultIncrementalDrawContribution(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
      var _this;
      _classCallCheck(this, DefaultIncrementalDrawContribution);
      _this = _super.call(this, contributions, drawItemInterceptorContributions), _this.contributions = contributions, _this.lineRender = lineRender, _this.areaRender = areaRender, _this.drawItemInterceptorContributions = drawItemInterceptorContributions, _this.rendering = !1, _this.currFrameStartAt = 0, _this.currentIdx = 0, _this.status = STATUS.NORMAL, _this.checkingForDrawPromise = null, _this.hooks = {
        completeDraw: new SyncHook([])
      }, _this.defaultRenderMap.set(_this.lineRender.numberType, _this.lineRender), _this.defaultRenderMap.set(_this.areaRender.numberType, _this.areaRender);
      return _this;
    }
    _createClass(DefaultIncrementalDrawContribution, [{
      key: "draw",
      value: function draw(renderService, drawContext) {
        return __awaiter$2(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var _this2 = this;
          var skipDraw, context, viewBox;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!this.checkingForDrawPromise) {
                  _context.next = 2;
                  break;
                }
                return _context.abrupt("return");
              case 2:
                this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
                _context.next = 5;
                return this.checkingForDrawPromise;
              case 5:
                skipDraw = _context.sent;
                if (!(this.checkingForDrawPromise = null, skipDraw)) {
                  _context.next = 8;
                  break;
                }
                return _context.abrupt("return");
              case 8:
                this.currentRenderService = renderService;
                context = drawContext.context, viewBox = drawContext.viewBox;
                context && (context.inuse = !0, context.clearMatrix(), context.setTransformForCurrent(!0), context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), context.translate(viewBox.x1, viewBox.y1, !0), context.save(), renderService.renderTreeRoots.sort(function (a, b) {
                  var _a, _b;
                  return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
                }).forEach(function (group) {
                  _this2.renderGroup(group, drawContext);
                }), this.hooks.completeDraw.tap("top-draw", function () {
                  context.restore(), context.restore(), context.draw(), context.inuse = !1, _this2.rendering = !1;
                }));
              case 11:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
      }
    }, {
      key: "_increaseRender",
      value: function _increaseRender(group, drawContext) {
        return __awaiter$2(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                this.rendering = !0;
                _context2.next = 3;
                return this._renderIncrementalGroup(group, drawContext);
              case 3:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
      }
    }, {
      key: "_renderIncrementalGroup",
      value: function _renderIncrementalGroup(group, drawContext) {
        return __awaiter$2(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var _this3 = this;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                this.count = group.count;
                _context4.next = 3;
                return new Promise(function (resolve) {
                  _this3.renderItem(group, drawContext, {
                    drawingCb: function drawingCb() {
                      return __awaiter$2(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                        var _this4 = this;
                        var graphic;
                        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                          while (1) switch (_context3.prev = _context3.next) {
                            case 0:
                              if (!(2 !== group.count)) {
                                _context3.next = 6;
                                break;
                              }
                              _context3.next = 3;
                              return foreachAsync(group, DefaultAttribute.zIndex, function (item, i) {
                                if (_this4.status === STATUS.STOP) return !0;
                                if (item.isContainer) return !1;
                                if (i < _this4.currentIdx) return !1;
                                var frameTail = _this4.currFrameStartAt + group.incremental;
                                return i < frameTail && (_this4.currentIdx = i + 1, _this4.renderItem(item, drawContext)), i === frameTail - 1 && (_this4.currFrameStartAt = _this4.currentIdx, _this4.waitToNextFrame());
                              });
                            case 3:
                              resolve(!1);
                              _context3.next = 21;
                              break;
                            case 6:
                              graphic = group.getChildAt(0);
                              if (!(graphic.incremental && graphic.attribute.segments)) {
                                _context3.next = 19;
                                break;
                              }
                              graphic.incrementalAt || (graphic.incrementalAt = 0);
                            case 9:
                              if (!(graphic.incrementalAt < graphic.attribute.segments.length)) {
                                _context3.next = 17;
                                break;
                              }
                              drawContext.multiGraphicOptions = {
                                startAtIdx: graphic.incrementalAt,
                                length: graphic.incremental
                              };
                              this.renderItem(graphic, drawContext);
                              graphic.incrementalAt += graphic.incremental;
                              _context3.next = 15;
                              return this.waitToNextFrame();
                            case 15:
                              _context3.next = 9;
                              break;
                            case 17:
                              _context3.next = 20;
                              break;
                            case 19:
                              this.renderItem(graphic, drawContext);
                            case 20:
                              resolve(!1);
                            case 21:
                            case "end":
                              return _context3.stop();
                          }
                        }, _callee3, this);
                      }));
                    }
                  });
                });
              case 3:
                this.hooks.completeDraw.call();
              case 4:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));
      }
    }, {
      key: "waitToNextFrame",
      value: function waitToNextFrame() {
        return __awaiter$2(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          var _this5 = this;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                return _context5.abrupt("return", new Promise(function (resolve) {
                  _this5.global.getRequestAnimationFrame()(function () {
                    resolve(!1);
                  });
                }));
              case 1:
              case "end":
                return _context5.stop();
            }
          }, _callee5);
        }));
      }
    }, {
      key: "checkForDraw",
      value: function checkForDraw(drawContext) {
        return __awaiter$2(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          var skip;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                skip = this.rendering;
                _context6.t0 = drawContext.restartIncremental;
                if (!_context6.t0) {
                  _context6.next = 7;
                  break;
                }
                skip = !1;
                _context6.next = 6;
                return this.forceStop();
              case 6:
                this.resetToInit();
              case 7:
                return _context6.abrupt("return", skip);
              case 8:
              case "end":
                return _context6.stop();
            }
          }, _callee6, this);
        }));
      }
    }, {
      key: "forceStop",
      value: function forceStop() {
        return __awaiter$2(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
          var _this6 = this;
          return _regeneratorRuntime().wrap(function _callee7$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _context7.t0 = this.rendering;
                if (!_context7.t0) {
                  _context7.next = 5;
                  break;
                }
                this.status = STATUS.STOP;
                _context7.next = 5;
                return new Promise(function (resolve) {
                  _this6.hooks.completeDraw.tap("stopCb", function () {
                    _this6.status = STATUS.NORMAL, _this6.hooks.completeDraw.taps = _this6.hooks.completeDraw.taps.filter(function (item) {
                      return "stopCb" !== item.name;
                    }), resolve(!1);
                  });
                });
              case 5:
              case "end":
                return _context7.stop();
            }
          }, _callee7, this);
        }));
      }
    }, {
      key: "resetToInit",
      value: function resetToInit() {
        this.currFrameStartAt = 0, this.currentIdx = 0;
      }
    }, {
      key: "renderGroup",
      value: function renderGroup(group, drawContext) {
        return __awaiter$2(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
          var _this7 = this;
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                if (!(!drawContext["break"] && !1 !== group.attribute.visibleAll)) {
                  _context10.next = 11;
                  break;
                }
                if (!(group.incremental && drawContext.startAtId === group._uid)) {
                  _context10.next = 7;
                  break;
                }
                _context10.next = 4;
                return this._increaseRender(group, drawContext);
              case 4:
                _context10.t0 = void (drawContext["break"] = !0);
                _context10.next = 10;
                break;
              case 7:
                _context10.next = 9;
                return new Promise(function (resolve) {
                  _this7.renderItem(group, drawContext, {
                    drawingCb: function drawingCb() {
                      return __awaiter$2(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                        var _this8 = this;
                        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                          while (1) switch (_context9.prev = _context9.next) {
                            case 0:
                              _context9.next = 2;
                              return foreachAsync(group, DefaultAttribute.zIndex, function (item) {
                                return __awaiter$2(_this8, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
                                  return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                                    while (1) switch (_context8.prev = _context8.next) {
                                      case 0:
                                        _context8.t0 = drawContext["break"];
                                        if (_context8.t0) {
                                          _context8.next = 6;
                                          break;
                                        }
                                        _context8.t1 = item.isContainer;
                                        if (!_context8.t1) {
                                          _context8.next = 6;
                                          break;
                                        }
                                        _context8.next = 6;
                                        return this.renderGroup(item, drawContext);
                                      case 6:
                                      case "end":
                                        return _context8.stop();
                                    }
                                  }, _callee8, this);
                                }));
                              });
                            case 2:
                              resolve(!1);
                            case 3:
                            case "end":
                              return _context9.stop();
                          }
                        }, _callee9);
                      }));
                    }
                  });
                });
              case 9:
                _context10.t0 = void _context10.sent;
              case 10:
                return _context10.abrupt("return", _context10.t0);
              case 11:
              case "end":
                return _context10.stop();
            }
          }, _callee10, this);
        }));
      }
    }]);
    return DefaultIncrementalDrawContribution;
  }(DefaultDrawContribution);
  DefaultIncrementalDrawContribution = __decorate$1c([injectable(), __param$B(0, multiInject(GraphicRender)), __param$B(1, inject(DefaultIncrementalCanvasLineRender)), __param$B(2, inject(DefaultIncrementalCanvasAreaRender)), __param$B(3, inject(ContributionProvider)), __param$B(3, named(DrawItemInterceptor)), __metadata$W("design:paramtypes", [Array, Object, Object, Object])], DefaultIncrementalDrawContribution);

  var renderModule = new ContainerModule(function (bind) {
    bind(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope(), bind(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope(), bind(DrawContribution).to(DefaultDrawContribution), bind(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution), bind(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope(), bind(GraphicRender).toService(GroupRender), bindContributionProvider(bind, GroupRenderContribution), bind(exports.DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope(), bindContributionProvider(bind, InteractiveSubRenderContribution), bindContributionProvider(bind, GraphicRender), bind(exports.CommonDrawItemInterceptorContribution).toSelf().inSingletonScope(), bind(DrawItemInterceptor).toService(exports.CommonDrawItemInterceptorContribution), bindContributionProvider(bind, DrawItemInterceptor);
  });

  function load(container) {
    container.load(renderModule);
  }

  function preLoadAllModule() {
    preLoadAllModule.__loaded || (preLoadAllModule.__loaded = !0, container.load(coreModule), container.load(graphicModule), container.load(renderModule$1), container.load(pickModule), container.load(pluginModule), load$1(container), load(container));
  }
  preLoadAllModule.__loaded = !1, preLoadAllModule();
  var vglobal = container.get(VGlobal);
  application.global = vglobal;
  var graphicUtil = container.get(GraphicUtil);
  application.graphicUtil = graphicUtil;
  var transformUtil = container.get(TransformUtil);
  application.transformUtil = transformUtil;
  var graphicService = container.get(GraphicService);
  application.graphicService = graphicService;
  var layerService = container.get(LayerService);
  application.layerService = layerService;

  var AutoRenderPlugin = /*#__PURE__*/function () {
    function AutoRenderPlugin() {
      _classCallCheck(this, AutoRenderPlugin);
      this.name = "AutoRenderPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
    }
    _createClass(AutoRenderPlugin, [{
      key: "activate",
      value: function activate(context) {
        this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, function (graphic) {
          graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();
        }), application.graphicService.hooks.onSetStage.tap(this.key, function (graphic) {
          graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();
        });
      }
    }, {
      key: "deactivate",
      value: function deactivate(context) {
        var _this = this;
        application.graphicService.hooks.onAttributeUpdate.taps = application.graphicService.hooks.onAttributeUpdate.taps.filter(function (item) {
          return item.name !== _this.key;
        }), application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter(function (item) {
          return item.name !== _this.key;
        });
      }
    }]);
    return AutoRenderPlugin;
  }();

  var ViewTransform3dPlugin = /*#__PURE__*/function () {
    function ViewTransform3dPlugin() {
      var _this = this;
      _classCallCheck(this, ViewTransform3dPlugin);
      this.name = "ViewTransform3dPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.onMouseDown = function (e) {
        _this.option3d || (_this.option3d = _this.pluginService.stage.option3d), _this.option3d && (_this.mousedown = !0, _this.pageX = e.page.x, _this.pageY = e.page.y);
      }, this.onMouseUp = function (e) {
        _this.option3d || (_this.option3d = _this.pluginService.stage.option3d), _this.option3d && (_this.mousedown = !1);
      }, this.onMouseMove = function (e) {
        var _a, _b;
        var stage = _this.pluginService.stage;
        if (_this.option3d || (_this.option3d = stage.option3d), _this.option3d && _this.mousedown) if (_this.pageX && _this.pageY) {
          var deltaX = e.page.x - _this.pageX,
            deltaY = e.page.y - _this.pageY;
          _this.pageX = e.page.x, _this.pageY = e.page.y;
          var angle1 = deltaX / 100,
            angle2 = deltaY / 100;
          _this.option3d.alpha = (null !== (_a = _this.option3d.alpha) && void 0 !== _a ? _a : 0) + angle1, _this.option3d.beta = (null !== (_b = _this.option3d.beta) && void 0 !== _b ? _b : 0) + angle2, stage.set3dOptions(_this.option3d), stage.renderNextFrame();
        } else _this.pageX = e.page.x, _this.pageY = e.page.y;
      };
    }
    _createClass(ViewTransform3dPlugin, [{
      key: "activate",
      value: function activate(context) {
        this.pluginService = context;
        var stage = context.stage;
        this.option3d = stage.option3d, stage.addEventListener("mousedown", this.onMouseDown), stage.addEventListener("mouseup", this.onMouseUp), stage.addEventListener("mousemove", this.onMouseMove);
      }
    }, {
      key: "deactivate",
      value: function deactivate(context) {
        var stage = context.stage;
        stage.removeEventListener("mousedown", this.onMouseDown), stage.removeEventListener("mouseup", this.onMouseUp), stage.removeEventListener("mousemove", this.onMouseMove);
      }
    }]);
    return ViewTransform3dPlugin;
  }();

  var IncrementalAutoRenderPlugin = /*#__PURE__*/function () {
    function IncrementalAutoRenderPlugin() {
      _classCallCheck(this, IncrementalAutoRenderPlugin);
      this.name = "IncrementalAutoRenderPlugin", this.activeEvent = "onRegister", this.nextFrameRenderGroupSet = new Set(), this.willNextFrameRender = !1, this.nextUserParams = {}, this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
    }
    _createClass(IncrementalAutoRenderPlugin, [{
      key: "activate",
      value: function activate(context) {
        var _this = this;
        this.pluginService = context, application.graphicService.hooks.onAddIncremental.tap(this.key, function (graphic, group, stage) {
          graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && (_this.nextUserParams.startAtId = group._uid, _this.renderNextFrame(group));
        }), application.graphicService.hooks.onClearIncremental.tap(this.key, function (group, stage) {
          group.stage === context.stage && null != group.stage && (_this.nextUserParams.startAtId = group._uid, _this.nextUserParams.restartIncremental = !0, _this.renderNextFrame(group));
        });
      }
    }, {
      key: "deactivate",
      value: function deactivate(context) {
        var _this2 = this;
        application.graphicService.hooks.onAddIncremental.taps = application.graphicService.hooks.onAddIncremental.taps.filter(function (item) {
          return item.name !== _this2.key;
        }), application.graphicService.hooks.onClearIncremental.taps = application.graphicService.hooks.onClearIncremental.taps.filter(function (item) {
          return item.name !== _this2.key;
        });
      }
    }, {
      key: "renderNextFrame",
      value: function renderNextFrame(group) {
        var _this3 = this;
        this.nextFrameRenderGroupSet.add(group), this.willNextFrameRender || (this.willNextFrameRender = !0, application.global.getRequestAnimationFrame()(function () {
          _this3._doRenderInThisFrame(), _this3.willNextFrameRender = !1;
        }));
      }
    }, {
      key: "_doRenderInThisFrame",
      value: function _doRenderInThisFrame() {
        var _this4 = this;
        var stage = this.pluginService.stage;
        this.nextFrameRenderGroupSet.size && (this.nextFrameRenderGroupSet.forEach(function (group) {
          var layer = group.layer;
          if (!layer || !group.layer.subLayers) return;
          var subLayer = group.layer.subLayers.get(group._uid);
          subLayer && subLayer.drawContribution && subLayer.drawContribution.draw(stage.renderService, Object.assign({
            stage: stage,
            layer: layer,
            viewBox: stage.window.getViewBox(),
            transMatrix: stage.window.getViewBoxTransform(),
            clear: "transparent",
            renderService: stage.renderService,
            updateBounds: !1,
            startAtId: group._uid,
            context: subLayer.layer.getNativeHandler().getContext()
          }, _this4.nextUserParams));
        }), this.nextUserParams = {}, this.nextFrameRenderGroupSet.clear());
      }
    }]);
    return IncrementalAutoRenderPlugin;
  }();

  var HtmlAttributePlugin = /*#__PURE__*/function () {
    function HtmlAttributePlugin() {
      _classCallCheck(this, HtmlAttributePlugin);
      this.name = "HtmlAttributePlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.lastDomContainerSet = new Set(), this.currentDomContainerSet = new Set();
    }
    _createClass(HtmlAttributePlugin, [{
      key: "activate",
      value: function activate(context) {
        var _this = this;
        this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, function (stage) {
          stage && stage === _this.pluginService.stage && _this.drawHTML(context.stage.renderService);
        }), application.graphicService.hooks.onRemove.tap(this.key, function (graphic) {
          _this.removeDom(graphic);
        }), application.graphicService.hooks.onRelease.tap(this.key, function (graphic) {
          _this.removeDom(graphic);
        });
      }
    }, {
      key: "deactivate",
      value: function deactivate(context) {
        var _this2 = this;
        context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter(function (item) {
          return item.name !== _this2.key;
        }), application.graphicService.hooks.onRemove.unTap(this.key), application.graphicService.hooks.onRelease.unTap(this.key), this.release();
      }
    }, {
      key: "drawHTML",
      value: function drawHTML(renderService) {
        var _this3 = this;
        "browser" === application.global.env && (renderService.renderTreeRoots.sort(function (a, b) {
          var _a, _b;
          return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
        }).forEach(function (group) {
          _this3.renderGroupHTML(group);
        }), this.lastDomContainerSet.forEach(function (item) {
          _this3.currentDomContainerSet.has(item) || item.parentElement && item.parentElement.removeChild(item);
        }), this.lastDomContainerSet = new Set(this.currentDomContainerSet), this.currentDomContainerSet.clear());
      }
    }, {
      key: "renderGroupHTML",
      value: function renderGroupHTML(group) {
        var _this4 = this;
        this.renderGraphicHTML(group), group.forEachChildren(function (g) {
          g.isContainer ? _this4.renderGroupHTML(g) : _this4.renderGraphicHTML(g);
        });
      }
    }, {
      key: "removeDom",
      value: function removeDom(graphic) {
        graphic.bindDom && graphic.bindDom.size && (graphic.bindDom.forEach(function (item) {
          item.dom && item.dom.parentElement.removeChild(item.dom);
        }), graphic.bindDom.clear());
      }
    }, {
      key: "renderGraphicHTML",
      value: function renderGraphicHTML(graphic) {
        var html = graphic.attribute.html;
        if (!html) return void (graphic.bindDom && graphic.bindDom.size && (graphic.bindDom.forEach(function (item) {
          item.dom && item.dom.parentElement.removeChild(item.dom);
        }), graphic.bindDom.clear()));
        var stage = graphic.stage;
        if (!stage) return;
        var dom = html.dom,
          container = html.container,
          width = html.width,
          height = html.height,
          style = html.style,
          _html$anchorType = html.anchorType,
          anchorType = _html$anchorType === void 0 ? "boundsLeftTop" : _html$anchorType,
          pointerEvents = html.pointerEvents;
        graphic.bindDom || (graphic.bindDom = new Map());
        var lastDom = graphic.bindDom.get(dom);
        var wrapGroup, nativeContainer;
        if (!lastDom || container && container !== lastDom.container) {
          var nativeDom;
          graphic.bindDom.forEach(function (_ref) {
            var wrapGroup = _ref.wrapGroup;
            application.global.removeDom(wrapGroup);
          }), "string" == typeof dom ? (nativeDom = new DOMParser().parseFromString(dom, "text/html").firstChild, nativeDom.lastChild && (nativeDom = nativeDom.lastChild.firstChild)) : nativeDom = dom;
          var _container = container || (!0 === stage.params.enableHtmlAttribute ? null : stage.params.enableHtmlAttribute);
          nativeContainer = _container ? "string" == typeof _container ? application.global.getElementById(_container) : _container : graphic.stage.window.getContainer(), wrapGroup = application.global.createDom({
            tagName: "div",
            width: width,
            height: height,
            style: style,
            parent: nativeContainer
          }), wrapGroup && (wrapGroup.appendChild(nativeDom), graphic.bindDom.set(dom, {
            dom: nativeDom,
            container: container,
            wrapGroup: wrapGroup
          }));
        } else wrapGroup = lastDom.wrapGroup, nativeContainer = wrapGroup.parentNode;
        wrapGroup.style.pointerEvents = pointerEvents || "none", wrapGroup.style.position || (wrapGroup.style.position = "absolute", nativeContainer.style.position = "relative");
        var left = 0,
          top = 0;
        var b = graphic.globalAABBBounds;
        if ("position" === anchorType || b.empty()) {
          var matrix = graphic.globalTransMatrix;
          left = matrix.e, top = matrix.f;
        } else left = b.x1, top = b.y1;
        var containerTL = application.global.getElementTopLeft(nativeContainer, !1),
          windowTL = stage.window.getTopLeft(!1),
          offsetX = left + windowTL.left - containerTL.left,
          offsetTop = top + windowTL.top - containerTL.top;
        wrapGroup.style.left = "".concat(offsetX, "px"), wrapGroup.style.top = "".concat(offsetTop, "px"), this.currentDomContainerSet.add(wrapGroup);
      }
    }, {
      key: "release",
      value: function release() {
        "browser" === application.global.env && (this.removeAllDom(this.pluginService.stage.defaultLayer), this.lastDomContainerSet.clear(), this.currentDomContainerSet.clear());
      }
    }, {
      key: "removeAllDom",
      value: function removeAllDom(g) {
        var _this5 = this;
        this.removeDom(g), g.forEachChildren(function (item) {
          item.isContainer && _this5.removeAllDom(g);
        });
      }
    }]);
    return HtmlAttributePlugin;
  }();

  var globalBounds = new AABBBounds();
  var DirtyBoundsPlugin = /*#__PURE__*/function () {
    function DirtyBoundsPlugin() {
      _classCallCheck(this, DirtyBoundsPlugin);
      this.name = "DirtyBoundsPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
    }
    _createClass(DirtyBoundsPlugin, [{
      key: "activate",
      value: function activate(context) {
        var _this = this;
        this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, function (stage) {
          stage && stage === _this.pluginService.stage && stage.dirtyBounds.clear();
        }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, function (graphic, stage, willUpdate, bounds) {
          graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === _this.pluginService.stage && stage.renderCount && (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds() || willUpdate && (globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix)));
        }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, function (graphic, stage, bounds, params, selfChange) {
          stage && stage === _this.pluginService.stage && stage.renderCount && (graphic.isContainer && !selfChange || stage.dirty(params.globalAABBBounds));
        }), application.graphicService.hooks.onRemove.tap(this.key, function (graphic) {
          var stage = graphic.stage;
          stage && stage === _this.pluginService.stage && stage.renderCount && stage && stage.dirty(graphic.globalAABBBounds);
        });
      }
    }, {
      key: "deactivate",
      value: function deactivate(context) {
        var _this2 = this;
        application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(function (item) {
          return item.name !== _this2.key;
        }), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter(function (item) {
          return item.name !== _this2.key;
        }), context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter(function (item) {
          return item.name !== _this2.key;
        }), application.graphicService.hooks.onRemove.taps = application.graphicService.hooks.onRemove.taps.filter(function (item) {
          return item.name !== _this2.key;
        });
      }
    }]);
    return DirtyBoundsPlugin;
  }();

  var _tempBounds = new AABBBounds();
  var FlexLayoutPlugin = /*#__PURE__*/function () {
    function FlexLayoutPlugin() {
      _classCallCheck(this, FlexLayoutPlugin);
      this.name = "FlexLayoutPlugin", this.activeEvent = "onRegister", this.id = Generator.GenAutoIncrementId(), this.key = this.name + this.id, this.tempBounds = new AABBBounds();
    }
    _createClass(FlexLayoutPlugin, [{
      key: "pauseLayout",
      value: function pauseLayout(p) {
        this.pause = p;
      }
    }, {
      key: "tryLayoutChildren",
      value: function tryLayoutChildren(graphic) {
        graphic.firstChild && this.tryLayout(graphic.firstChild);
      }
    }, {
      key: "tryLayout",
      value: function tryLayout(graphic) {
        var _this = this;
        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        if (this.pause) return;
        var p = graphic.parent;
        if (!(force || p && graphic.needUpdateLayout())) return;
        var theme = getTheme(p).group,
          _p$attribute$display = p.attribute.display,
          display = _p$attribute$display === void 0 ? theme.display : _p$attribute$display;
        if ("flex" !== display) return;
        var _p$attribute = p.attribute,
          _p$attribute$flexDire = _p$attribute.flexDirection,
          flexDirection = _p$attribute$flexDire === void 0 ? theme.flexDirection : _p$attribute$flexDire,
          _p$attribute$flexWrap = _p$attribute.flexWrap,
          flexWrap = _p$attribute$flexWrap === void 0 ? theme.flexWrap : _p$attribute$flexWrap,
          _p$attribute$alignIte = _p$attribute.alignItems,
          alignItems = _p$attribute$alignIte === void 0 ? theme.alignItems : _p$attribute$alignIte,
          _p$attribute$clip = _p$attribute.clip,
          clip = _p$attribute$clip === void 0 ? theme.clip : _p$attribute$clip,
          _p$attribute$alignCon = p.attribute.alignContent,
          alignContent = _p$attribute$alignCon === void 0 ? null != alignItems ? alignItems : theme.alignContent : _p$attribute$alignCon;
        var _p$attribute2 = p.attribute,
          width = _p$attribute2.width,
          height = _p$attribute2.height,
          _p$attribute2$justify = _p$attribute2.justifyContent,
          justifyContent = _p$attribute2$justify === void 0 ? theme.justifyContent : _p$attribute2$justify;
        var children = p.getChildren();
        if (null == width || null == height) {
          var childrenWidth = 0,
            childrenHeight = 0,
            boundsLegal = 0;
          if (children.forEach(function (child) {
            var bounds = _this.getAABBBounds(child);
            bounds.empty() || ("column" === flexDirection || "column-reverse" === flexDirection ? (childrenHeight += bounds.height(), childrenWidth = Math.max(childrenWidth, bounds.width())) : (childrenWidth += bounds.width(), childrenHeight = Math.max(childrenHeight, bounds.height())), boundsLegal += bounds.x1, boundsLegal += bounds.y1, boundsLegal += bounds.x2, boundsLegal += bounds.y2);
          }), !isFinite(boundsLegal)) return;
          width = childrenWidth, height = childrenHeight;
        }
        p.attribute.width = width, p.attribute.height = height, this.tempBounds.copy(p._AABBBounds);
        var result = {
            main: {
              len: width,
              field: "x"
            },
            cross: {
              len: height,
              field: "y"
            }
          },
          main = result.main,
          cross = result.cross;
        "column" !== flexDirection && "column-reverse" !== flexDirection || (main.len = height, cross.len = width, main.field = "y", cross.field = "x"), "row-reverse" !== flexDirection && "column-reverse" !== flexDirection || ("flex-start" === justifyContent ? justifyContent = "flex-end" : "flex-end" === justifyContent ? justifyContent = "flex-start" : children.reverse());
        var mainLen = 0,
          crossLen = 0;
        var mianLenArray = [];
        children.forEach(function (c) {
          var b = _this.getAABBBounds(c);
          if (b.empty()) return;
          var ml = "x" === main.field ? b.width() : b.height(),
            cl = "x" === cross.field ? b.width() : b.height();
          mianLenArray.push({
            mainLen: ml,
            crossLen: cl
          }), mainLen += ml, crossLen = Math.max(crossLen, cl);
        });
        var mainList = [];
        if (mainLen > main.len && "wrap" === flexWrap) {
          var tempMainL = 0,
            tempCrossL = 0;
          mianLenArray.forEach(function (_ref, i) {
            var mainLen = _ref.mainLen,
              crossLen = _ref.crossLen;
            tempMainL + mainLen > main.len ? 0 === tempMainL ? (mainList.push({
              idx: i,
              mainLen: tempMainL + mainLen,
              crossLen: crossLen
            }), tempMainL = 0, tempCrossL = 0) : (mainList.push({
              idx: i - 1,
              mainLen: tempMainL,
              crossLen: crossLen
            }), tempMainL = mainLen, tempCrossL = crossLen) : (tempMainL += mainLen, tempCrossL = Math.max(tempCrossL, crossLen));
          }), mainList.push({
            idx: mianLenArray.length - 1,
            mainLen: tempMainL,
            crossLen: tempCrossL
          });
        } else mainList.push({
          idx: mianLenArray.length - 1,
          mainLen: mainLen,
          crossLen: crossLen
        });
        var lastIdx = 0;
        if (mainList.forEach(function (s) {
          _this.layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, s), lastIdx = s.idx + 1;
        }), crossLen = mainList.reduce(function (a, b) {
          return a + b.crossLen;
        }, 0), 1 === mainList.length) {
          var anchorPosMap = {
            "flex-start": 0,
            "flex-end": cross.len,
            center: cross.len / 2
          };
          this.layoutCross(children, alignItems, cross, anchorPosMap, mianLenArray, mainList[0], 0);
        } else if ("flex-start" === alignContent) {
          lastIdx = 0;
          var anchorPos = 0;
          mainList.forEach(function (s, i) {
            var anchorPosMap = {
              "flex-start": anchorPos,
              "flex-end": anchorPos + s.crossLen,
              center: anchorPos + s.crossLen / 2
            };
            _this.layoutCross(children, "flex-start", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, anchorPos += s.crossLen;
          });
        } else if ("center" === alignContent) {
          lastIdx = 0;
          var _anchorPos = Math.max(0, (cross.len - crossLen) / 2);
          mainList.forEach(function (s, i) {
            var anchorPosMap = {
              "flex-start": _anchorPos,
              "flex-end": _anchorPos + s.crossLen,
              center: _anchorPos + s.crossLen / 2
            };
            _this.layoutCross(children, "center", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, _anchorPos += s.crossLen;
          });
        } else if ("space-around" === alignContent) {
          lastIdx = 0;
          var padding = Math.max(0, (cross.len - crossLen) / mainList.length / 2);
          var _anchorPos2 = padding;
          mainList.forEach(function (s, i) {
            var anchorPosMap = {
              "flex-start": _anchorPos2,
              "flex-end": _anchorPos2 + s.crossLen,
              center: _anchorPos2 + s.crossLen / 2
            };
            _this.layoutCross(children, "flex-start", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, _anchorPos2 += s.crossLen + 2 * padding;
          });
        } else if ("space-between" === alignContent) {
          lastIdx = 0;
          var _padding = Math.max(0, (cross.len - crossLen) / (2 * mainList.length - 2));
          var _anchorPos3 = 0;
          mainList.forEach(function (s, i) {
            var anchorPosMap = {
              "flex-start": _anchorPos3,
              "flex-end": _anchorPos3 + s.crossLen,
              center: _anchorPos3 + s.crossLen / 2
            };
            _this.layoutCross(children, "flex-start", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, _anchorPos3 += s.crossLen + 2 * _padding;
          });
        }
        children.forEach(function (child, idx) {
          child.addUpdateBoundTag(), child.addUpdatePositionTag(), child.clearUpdateLayoutTag();
        }), p.addUpdateLayoutTag();
        var b = this.getAABBBounds(p);
        clip || this.tempBounds.equals(b) || this.tryLayout(p, !1);
      }
    }, {
      key: "getAABBBounds",
      value: function getAABBBounds(graphic) {
        this.skipBoundsTrigger = !0;
        var b = graphic.AABBBounds;
        return this.skipBoundsTrigger = !1, b;
      }
    }, {
      key: "updateChildPos",
      value: function updateChildPos(posBaseLeftTop, lastP, lastBP) {
        return posBaseLeftTop + (null != lastP ? lastP : 0) - lastBP;
      }
    }, {
      key: "layoutMain",
      value: function layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, currSeg) {
        if ("flex-start" === justifyContent) {
          var pos = 0;
          for (var i = lastIdx; i <= currSeg.idx; i++) {
            var posBaseLeftTop = pos + getPadding(children[i], main.field),
              b = this.getAABBBounds(children[i]);
            !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b["".concat(main.field, "1")])), pos += mianLenArray[i].mainLen;
          }
        } else if ("flex-end" === justifyContent) {
          var _pos = main.len;
          for (var _i = lastIdx; _i <= currSeg.idx; _i++) {
            _pos -= mianLenArray[_i].mainLen;
            var _posBaseLeftTop = _pos + getPadding(children[_i], main.field),
              _b = this.getAABBBounds(children[_i]);
            !_b.empty() && (children[_i].attribute[main.field] = this.updateChildPos(_posBaseLeftTop, children[_i].attribute[main.field], _b["".concat(main.field, "1")]));
          }
        } else if ("space-around" === justifyContent) {
          if (currSeg.mainLen >= main.len) {
            var _pos2 = 0;
            for (var _i2 = lastIdx; _i2 <= currSeg.idx; _i2++) {
              var _posBaseLeftTop2 = _pos2 + getPadding(children[_i2], main.field),
                _b2 = this.getAABBBounds(children[_i2]);
              !_b2.empty() && (children[_i2].attribute[main.field] = this.updateChildPos(_posBaseLeftTop2, children[_i2].attribute[main.field], _b2["".concat(main.field, "1")])), _pos2 += mianLenArray[_i2].mainLen;
            }
          } else {
            var size = currSeg.idx - lastIdx + 1,
              padding = (main.len - currSeg.mainLen) / size / 2;
            var _pos3 = padding;
            for (var _i3 = lastIdx; _i3 <= currSeg.idx; _i3++) {
              var _posBaseLeftTop3 = _pos3 + getPadding(children[_i3], main.field),
                _b3 = this.getAABBBounds(children[_i3]);
              !_b3.empty() && (children[_i3].attribute[main.field] = this.updateChildPos(_posBaseLeftTop3, children[_i3].attribute[main.field], _b3["".concat(main.field, "1")])), _pos3 += mianLenArray[_i3].mainLen + 2 * padding;
            }
          }
        } else if ("space-between" === justifyContent) {
          if (currSeg.mainLen >= main.len) {
            var _pos4 = 0;
            for (var _i4 = lastIdx; _i4 <= currSeg.idx; _i4++) {
              var _posBaseLeftTop4 = _pos4 + getPadding(children[_i4], main.field),
                _b4 = this.getAABBBounds(children[_i4]);
              !_b4.empty() && (children[_i4].attribute[main.field] = this.updateChildPos(_posBaseLeftTop4, children[_i4].attribute[main.field], _b4["".concat(main.field, "1")])), _pos4 += mianLenArray[_i4].mainLen;
            }
          } else {
            var _size = currSeg.idx - lastIdx + 1,
              _padding2 = (main.len - currSeg.mainLen) / (2 * _size - 2);
            var _pos5 = 0;
            for (var _i5 = lastIdx; _i5 <= currSeg.idx; _i5++) {
              var _posBaseLeftTop5 = _pos5 + getPadding(children[_i5], main.field),
                _b5 = this.getAABBBounds(children[_i5]);
              !_b5.empty() && (children[_i5].attribute[main.field] = this.updateChildPos(_posBaseLeftTop5, children[_i5].attribute[main.field], _b5["".concat(main.field, "1")])), _pos5 += mianLenArray[_i5].mainLen + 2 * _padding2;
            }
          }
        } else if ("center" === justifyContent) {
          var _pos6 = (main.len - currSeg.mainLen) / 2;
          for (var _i6 = lastIdx; _i6 <= currSeg.idx; _i6++) {
            var _posBaseLeftTop6 = _pos6 + getPadding(children[_i6], main.field),
              _b6 = this.getAABBBounds(children[_i6]);
            !_b6.empty() && (children[_i6].attribute[main.field] = this.updateChildPos(_posBaseLeftTop6, children[_i6].attribute[main.field], _b6["".concat(main.field, "1")])), _pos6 += mianLenArray[_i6].mainLen;
          }
        }
      }
    }, {
      key: "layoutCross",
      value: function layoutCross(children, alignItem, cross, anchorPosMap, lenArray, currSeg, lastIdx) {
        var _a;
        for (var i = lastIdx; i <= currSeg.idx; i++) {
          var child = children[i];
          var alignSelf = child.attribute.alignSelf;
          alignSelf && "auto" !== alignSelf || (alignSelf = alignItem);
          var b = this.getAABBBounds(child),
            anchorPos = null !== (_a = anchorPosMap[alignSelf]) && void 0 !== _a ? _a : anchorPosMap["flex-start"];
          "flex-end" === alignSelf ? !b.empty() && (child.attribute[cross.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen + getPadding(child, cross.field), child.attribute[cross.field], b["".concat(cross.field, "1")])) : "center" === alignSelf ? !b.empty() && (child.attribute[cross.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen / 2 + getPadding(child, cross.field), child.attribute[cross.field], b["".concat(cross.field, "1")])) : !b.empty() && (child.attribute[cross.field] = this.updateChildPos(anchorPos + getPadding(child, cross.field), child.attribute[cross.field], b["".concat(cross.field, "1")]));
        }
      }
    }, {
      key: "activate",
      value: function activate(context) {
        var _this2 = this;
        this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, function (graphic) {
          graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage && graphic.stage === _this2.pluginService.stage && _this2.tryLayout(graphic, !1);
        }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, function (graphic, stage, willUpdate, bounds) {
          graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === _this2.pluginService.stage && graphic.isContainer && !_this2.skipBoundsTrigger && _tempBounds.copy(bounds);
        }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, function (graphic, stage, bounds, params, selfChange) {
          stage && stage === _this2.pluginService.stage && graphic.isContainer && !_this2.skipBoundsTrigger && (_tempBounds.equals(bounds) || _this2.tryLayout(graphic, !1));
        }), application.graphicService.hooks.onSetStage.tap(this.key, function (graphic) {
          graphic.glyphHost && (graphic = graphic.glyphHost), _this2.tryLayout(graphic, !1);
        });
      }
    }, {
      key: "deactivate",
      value: function deactivate(context) {
        var _this3 = this;
        application.graphicService.hooks.onAttributeUpdate.taps = application.graphicService.hooks.onAttributeUpdate.taps.filter(function (item) {
          return item.name !== _this3.key;
        }), application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(function (item) {
          return item.name !== _this3.key;
        }), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter(function (item) {
          return item.name !== _this3.key;
        }), application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter(function (item) {
          return item.name !== _this3.key;
        });
      }
    }]);
    return FlexLayoutPlugin;
  }();
  function getPadding(graphic, field) {
    return 0;
  }

  var defaultTicker = new DefaultTicker();
  defaultTicker.addTimeline(defaultTimeline);
  defaultTicker.setFPS(60);

  var DirectionalLight = /*#__PURE__*/function () {
    function DirectionalLight(dir, color) {
      var ambient = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .8;
      _classCallCheck(this, DirectionalLight);
      this.dir = dir, this.color = color, this.colorRgb = ColorStore.Get(color, exports.ColorType.Color1), this.ambient = ambient;
      var length = sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
      this.formatedDir = [dir[0] / length, dir[1] / length, dir[2] / length];
    }
    _createClass(DirectionalLight, [{
      key: "computeColor",
      value: function computeColor(normal, color) {
        var lightDir = this.formatedDir,
          brightness = min(max((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);
        var colorArray;
        colorArray = isString$1(color) ? ColorStore.Get(color, exports.ColorType.Color1) : color;
        var lightColorArray = this.colorRgb;
        return "rgb(".concat(lightColorArray[0] * colorArray[0] * brightness, ", ").concat(lightColorArray[1] * colorArray[1] * brightness, ", ").concat(lightColorArray[2] * colorArray[2] * brightness, ")");
      }
    }]);
    return DirectionalLight;
  }();

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2],
      centerx = center[0],
      centery = center[1],
      centerz = center[2];
    return Math.abs(eyex - centerx) < epsilon && Math.abs(eyey - centery) < epsilon && Math.abs(eyez - centerz) < epsilon ? DefaultMat4Allocate.identity(out) : (z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz, len = 1 / Math.hypot(z0, z1, z2), z0 *= len, z1 *= len, z2 *= len, x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0, len = Math.hypot(x0, x1, x2), len ? (len = 1 / len, x0 *= len, x1 *= len, x2 *= len) : (x0 = 0, x1 = 0, x2 = 0), y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0, len = Math.hypot(y0, y1, y2), len ? (len = 1 / len, y0 *= len, y1 *= len, y2 *= len) : (y0 = 0, y1 = 0, y2 = 0), out[0] = x0, out[1] = y0, out[2] = z0, out[3] = 0, out[4] = x1, out[5] = y1, out[6] = z1, out[7] = 0, out[8] = x2, out[9] = y2, out[10] = z2, out[11] = 0, out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez), out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez), out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez), out[15] = 1, out);
  }
  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
      bt = 1 / (bottom - top),
      nf = 1 / (near - far);
    return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left + right) * lr, out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;
  }
  function multiply(out, a, b) {
    var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3],
      a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7],
      a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11],
      a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
    var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
    return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
  }
  function transformMat4(out, a, m) {
    var x = a[0],
      y = a[1],
      z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    return w = w || 1, out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w, out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w, out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w, out;
  }

  var OrthoCamera = /*#__PURE__*/function () {
    function OrthoCamera(params) {
      _classCallCheck(this, OrthoCamera);
      this.params = params;
    }
    _createClass(OrthoCamera, [{
      key: "params",
      get: function get() {
        return Object.assign({}, this._params);
      },
      set: function set(params) {
        this._params = Object.assign({}, params), this._projectionMatrixCached = this.forceGetProjectionMatrix(), this._viewMatrixCached = this.forceGetViewMatrix();
      }
    }, {
      key: "getViewMatrix",
      value: function getViewMatrix() {
        return this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate()), this._viewMatrixCached;
      }
    }, {
      key: "forceGetViewMatrix",
      value: function forceGetViewMatrix() {
        this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate());
        var _this$params$viewPara = this.params.viewParams,
          pos = _this$params$viewPara.pos,
          center = _this$params$viewPara.center,
          up = _this$params$viewPara.up;
        return lookAt(this._viewMatrixCached, pos, center, up), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._viewMatrixCached;
      }
    }, {
      key: "getProjectionMatrix",
      value: function getProjectionMatrix() {
        return this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate()), this._projectionMatrixCached;
      }
    }, {
      key: "forceGetProjectionMatrix",
      value: function forceGetProjectionMatrix() {
        this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate());
        var _this$_params = this._params,
          left = _this$_params.left,
          top = _this$_params.top,
          right = _this$_params.right,
          bottom = _this$_params.bottom;
        return ortho(this._projectionMatrixCached, left, right, bottom, top, 0, -2e6), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._projectionMatrixCached;
      }
    }, {
      key: "getField",
      value: function getField() {
        var _this$_params2 = this._params,
          _this$_params2$fieldR = _this$_params2.fieldRatio,
          fieldRatio = _this$_params2$fieldR === void 0 ? .8 : _this$_params2$fieldR,
          fieldDepth = _this$_params2.fieldDepth,
          left = _this$_params2.left,
          right = _this$_params2.right;
        return (null != fieldDepth ? fieldDepth : right - left) * fieldRatio;
      }
    }, {
      key: "getProjectionScale",
      value: function getProjectionScale(z) {
        var field = this.getField();
        return field / (field + z);
      }
    }, {
      key: "view",
      value: function view(x, y, z) {
        var outP = [0, 0, 0];
        return transformMat4(outP, [x, y, z], this._viewMatrixCached), outP;
      }
    }, {
      key: "vp",
      value: function vp(x, y, z) {
        var outP = [0, 0, 0],
          pos = this._params.viewParams.pos;
        transformMat4(outP, [x, y, z], this._viewMatrixCached), x = outP[0], y = outP[1], z = outP[2];
        var sizeProjection = this.getProjectionScale(z);
        return {
          x: x * sizeProjection + pos[0],
          y: y * sizeProjection + pos[1]
        };
      }
    }]);
    return OrthoCamera;
  }();

  var _isBrowserEnv;
  function initIsBrowserEnv() {
    if (null == _isBrowserEnv) try {
      _isBrowserEnv = globalThis === window, _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
    } catch (err) {
      _isBrowserEnv = !1;
    }
  }
  function isBrowserEnv() {
    initIsBrowserEnv();
    var env = application.global && application.global.env;
    return env ? "browser" === env : _isBrowserEnv;
  }
  function isNodeEnv() {
    initIsBrowserEnv();
    var env = application.global && application.global.env;
    return env ? "node" === env : !_isBrowserEnv;
  }
  function getCurrentEnv() {
    return isBrowserEnv() ? "browser" : "node";
  }

  var ReactAttributePlugin = /*#__PURE__*/function (_HtmlAttributePlugin) {
    _inherits(ReactAttributePlugin, _HtmlAttributePlugin);
    var _super = _createSuper(ReactAttributePlugin);
    function ReactAttributePlugin() {
      var _this;
      _classCallCheck(this, ReactAttributePlugin);
      _this = _super.apply(this, arguments), _this.name = "ReactAttributePlugin", _this.activeEvent = "onRegister", _this._uid = Generator.GenAutoIncrementId(), _this.key = _this.name + _this._uid;
      return _this;
    }
    _createClass(ReactAttributePlugin, [{
      key: "removeDom",
      value: function removeDom(graphic) {
        graphic.bindDom && graphic.bindDom.size && (graphic.bindDom.forEach(function (item) {
          item.root && item.root.unmount();
        }), graphic.bindDom.clear());
      }
    }, {
      key: "renderGraphicHTML",
      value: function renderGraphicHTML(graphic) {
        var react = graphic.attribute.react;
        if (!react) return void (graphic.bindDom && graphic.bindDom.size && (graphic.bindDom.forEach(function (item) {
          item.root && item.root.unmount();
        }), graphic.bindDom.clear()));
        var stage = graphic.stage;
        if (!stage) return;
        var ReactDOM = stage.params.ReactDOM,
          element = react.element,
          container = react.container,
          width = react.width,
          height = react.height,
          style = react.style,
          _react$anchorType = react.anchorType,
          anchorType = _react$anchorType === void 0 ? "boundsLeftTop" : _react$anchorType,
          pointerEvents = react.pointerEvents;
        if (!(element && ReactDOM && ReactDOM.createRoot)) return;
        graphic.bindDom || (graphic.bindDom = new Map());
        var lastDom = graphic.bindDom.get(element);
        var wrapGroup, nativeContainer;
        if (!lastDom || container && container !== lastDom.container) {
          graphic.bindDom.forEach(function (_ref) {
            var wrapGroup = _ref.wrapGroup;
            application.global.removeDom(wrapGroup);
          });
          var _container = container;
          if (nativeContainer = _container ? "string" == typeof _container ? application.global.getElementById(_container) : _container : graphic.stage.window.getContainer(), wrapGroup = application.global.createDom({
            tagName: "div",
            width: width,
            height: height,
            style: style,
            parent: nativeContainer
          }), wrapGroup) {
            var root = ReactDOM.createRoot(wrapGroup);
            root.render(element), graphic.bindDom.set(element, {
              dom: element,
              container: container,
              wrapGroup: wrapGroup,
              root: root
            });
          }
        } else wrapGroup = lastDom.wrapGroup, nativeContainer = wrapGroup.parentNode;
        wrapGroup.style.pointerEvents = pointerEvents || "none", wrapGroup.style.position || (wrapGroup.style.position = "absolute", nativeContainer.style.position = "relative");
        var left = 0,
          top = 0;
        var b = graphic.globalAABBBounds;
        if ("position" === anchorType || b.empty()) {
          var matrix = graphic.globalTransMatrix;
          left = matrix.e, top = matrix.f;
        } else left = b.x1, top = b.y1;
        var containerTL = application.global.getElementTopLeft(nativeContainer, !1),
          windowTL = stage.window.getTopLeft(!1),
          offsetX = left + windowTL.left - containerTL.left,
          offsetTop = top + windowTL.top - containerTL.top;
        wrapGroup.style.left = "".concat(offsetX, "px"), wrapGroup.style.top = "".concat(offsetTop, "px");
      }
    }]);
    return ReactAttributePlugin;
  }(HtmlAttributePlugin);

  var DefaultConfig$1 = {
    WIDTH: 500,
    HEIGHT: 500,
    X: 0,
    Y: 0,
    BACKGROUND: "white"
  };
  var Stage = /*#__PURE__*/function (_Group) {
    _inherits(Stage, _Group);
    var _super = _createSuper(Stage);
    function Stage() {
      var _this;
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _classCallCheck(this, Stage);
      var _a;
      _this = _super.call(this, {}), _this._onVisibleChange = function (visible) {
        if (!(_this._skipRender < 0)) if (visible) {
          if (_this.dirtyBounds) {
            var b = _this.window.getViewBox();
            _this.dirtyBounds.setValue(b.x1, b.y1, b.width(), b.height());
          }
          _this._skipRender > 1 && _this.renderNextFrame(), _this._skipRender = 0;
        } else _this._skipRender = 1;
      }, _this.beforeRender = function (stage) {
        _this._beforeRender && _this._beforeRender(stage);
      }, _this.afterRender = function (stage) {
        _this.renderCount++, _this._afterRender && _this._afterRender(stage), _this._afterNextRenderCbs && _this._afterNextRenderCbs.forEach(function (cb) {
          return cb(stage);
        }), _this._afterNextRenderCbs = null;
      }, _this.params = params, _this.theme = new Theme(), _this.hooks = {
        beforeRender: new SyncHook(["stage"]),
        afterRender: new SyncHook(["stage"])
      }, _this.global = application.global, !_this.global.env && isBrowserEnv() && _this.global.setEnv("browser"), _this.window = container.get(VWindow), _this.renderService = container.get(RenderService), _this.pluginService = container.get(PluginService), _this.layerService = container.get(LayerService), _this.pluginService.active(_assertThisInitialized(_this), params), _this.window.create({
        width: params.width,
        height: params.height,
        viewBox: params.viewBox,
        container: params.container,
        dpr: params.dpr || _this.global.devicePixelRatio,
        canvasControled: !1 !== params.canvasControled,
        title: params.title || "",
        canvas: params.canvas
      }), _this.state = "normal", _this.renderCount = 0, _this.tryInitEventSystem(), _this._background = null !== (_a = params.background) && void 0 !== _a ? _a : DefaultConfig$1.BACKGROUND, _this.appendChild(_this.layerService.createLayer(_assertThisInitialized(_this), {
        main: !0
      })), _this.nextFrameRenderLayerSet = new Set(), _this.willNextFrameRender = !1, _this.stage = _assertThisInitialized(_this), _this.renderStyle = params.renderStyle, params.autoRender && _this.enableAutoRender(), !1 === params.disableDirtyBounds && _this.enableDirtyBounds(), params.enableHtmlAttribute && _this.enableHtmlAttribute(params.enableHtmlAttribute), params.ReactDOM && _this.enableReactAttribute(params.ReactDOM), params.enableLayout && _this.enableLayout(), _this.hooks.beforeRender.tap("constructor", _this.beforeRender), _this.hooks.afterRender.tap("constructor", _this.afterRender), _this._beforeRender = params.beforeRender, _this._afterRender = params.afterRender, _this.ticker = params.ticker || defaultTicker, _this.supportInteractiveLayer = !1 !== params.interactiveLayer, _this.timeline = new DefaultTimeline(), _this.ticker.addTimeline(_this.timeline), _this.timeline.pause(), params.optimize || (params.optimize = {}), _this.optmize(params.optimize), params.background && isString$1(_this._background) && _this._background.includes("/") && _this.setAttributes({
        background: _this._background
      });
      return _this;
    }
    _createClass(Stage, [{
      key: "viewBox",
      get: function get() {
        return this.window.getViewBox();
      },
      set: function set(b) {
        this.window.setViewBox(b);
      }
    }, {
      key: "x",
      get: function get() {
        return this.window.getViewBox().x1;
      },
      set: function set(x) {
        var b = this.window.getViewBox();
        b.translate(x - b.x1, 0), this.window.setViewBox(b);
      }
    }, {
      key: "y",
      get: function get() {
        return this.window.getViewBox().y1;
      },
      set: function set(y) {
        var b = this.window.getViewBox();
        b.translate(0, y - b.y1), this.window.setViewBox(b);
      }
    }, {
      key: "width",
      get: function get() {
        return this.window.width;
      },
      set: function set(w) {
        this.resize(w, this.height);
      }
    }, {
      key: "viewWidth",
      get: function get() {
        return this.window.getViewBox().width();
      },
      set: function set(w) {
        this.resizeView(w, this.viewHeight);
      }
    }, {
      key: "viewHeight",
      get: function get() {
        return this.window.getViewBox().height();
      },
      set: function set(h) {
        this.resizeView(this.viewWidth, h);
      }
    }, {
      key: "height",
      get: function get() {
        return this.window.height;
      },
      set: function set(h) {
        this.resize(this.width, h);
      }
    }, {
      key: "dpr",
      get: function get() {
        return this.window.dpr;
      },
      set: function set(r) {
        this.setDpr(r);
      }
    }, {
      key: "background",
      get: function get() {
        var _a;
        return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig$1.BACKGROUND;
      },
      set: function set(b) {
        this._background = b;
      }
    }, {
      key: "defaultLayer",
      get: function get() {
        return this.at(0);
      }
    }, {
      key: "eventSystem",
      get: function get() {
        return this._eventSystem;
      }
    }, {
      key: "pauseRender",
      value: function pauseRender() {
        this._skipRender = -1;
      }
    }, {
      key: "resumeRender",
      value: function resumeRender() {
        this._skipRender = 0;
      }
    }, {
      key: "tryInitEventSystem",
      value: function tryInitEventSystem() {
        this.global.supportEvent && !this._eventSystem && (this._eventSystem = new EventSystem(Object.assign({
          targetElement: this.window,
          resolution: this.window.dpr || this.global.devicePixelRatio,
          rootNode: this,
          global: this.global,
          supportsPointerEvents: this.params.supportsPointerEvents,
          supportsTouchEvents: this.params.supportsTouchEvents
        }, this.params.event)));
      }
    }, {
      key: "preventRender",
      value: function preventRender(prevent) {
        prevent ? this._skipRender = -1 / 0 : !1 !== this.params.optimize.skipRenderWithOutRange ? this._skipRender = this.window.isVisible() ? 0 : 1 : this._skipRender = 0;
      }
    }, {
      key: "optmize",
      value: function optmize(params) {
        this.optmizeRender(params.skipRenderWithOutRange), this.params.optimize = params;
      }
    }, {
      key: "optmizeRender",
      value: function optmizeRender() {
        var skipRenderWithOutRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        skipRenderWithOutRange && (this._skipRender = this._skipRender < 0 ? this._skipRender : this.window.isVisible() ? 0 : 1, this.window.onVisibleChange(this._onVisibleChange));
      }
    }, {
      key: "getTimeline",
      value: function getTimeline() {
        return this.timeline;
      }
    }, {
      key: "get3dOptions",
      value: function get3dOptions(options) {
        var _options$center = options.center,
          center = _options$center === void 0 ? {
            x: this.width / 2,
            y: this.height / 2,
            z: 0,
            dx: 0,
            dy: 0,
            dz: 0
          } : _options$center,
          _options$light = options.light,
          light = _options$light === void 0 ? {} : _options$light,
          _options$alpha = options.alpha,
          alpha = _options$alpha === void 0 ? 0 : _options$alpha,
          _options$beta = options.beta,
          beta = _options$beta === void 0 ? 0 : _options$beta,
          camera = options.camera,
          _options$fieldRatio = options.fieldRatio,
          fieldRatio = _options$fieldRatio === void 0 ? 1 : _options$fieldRatio,
          fieldDepth = options.fieldDepth;
        return Object.assign(Object.assign({}, options), {
          center: center,
          light: light,
          alpha: alpha,
          beta: beta,
          camera: camera,
          fieldRatio: fieldRatio,
          fieldDepth: fieldDepth
        });
      }
    }, {
      key: "set3dOptions",
      value: function set3dOptions(options) {
        var _a, _b, _c, _d, _e, _f;
        this.option3d = options;
        var options3d = this.get3dOptions(options),
          light = options3d.light,
          center = options3d.center,
          camera = options3d.camera,
          alpha = options3d.alpha,
          beta = options3d.beta,
          fieldRatio = options3d.fieldRatio,
          fieldDepth = options3d.fieldDepth,
          _light$dir = light.dir,
          dir = _light$dir === void 0 ? [1, 1, -1] : _light$dir,
          _light$color = light.color,
          color = _light$color === void 0 ? "white" : _light$color,
          ambient = light.ambient,
          centerX = (null !== (_a = center.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center.dx) && void 0 !== _b ? _b : 0),
          centerY = (null !== (_c = center.y) && void 0 !== _c ? _c : this.height / 2) + (null !== (_d = center.dy) && void 0 !== _d ? _d : 0),
          centerVec3 = [centerX, centerY, (null !== (_e = center.z) && void 0 !== _e ? _e : 0) + (null !== (_f = center.dz) && void 0 !== _f ? _f : 0)];
        var cameraX = 0,
          cameraY = 0,
          cameraZ = 0;
        camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, cameraZ = Math.cos(alpha) * Math.cos(beta) * 1), this.light = new DirectionalLight(dir, color, ambient);
        var cameraParams = {
          left: 0,
          right: this.width,
          top: 0,
          bottom: this.height,
          fieldRatio: fieldRatio,
          fieldDepth: fieldDepth,
          viewParams: {
            pos: [cameraX, cameraY, cameraZ],
            center: centerVec3,
            up: [0, 1, 0]
          }
        };
        this.camera ? this.camera.params = cameraParams : this.camera = new OrthoCamera(cameraParams), options.enableView3dTransform && this.enableView3dTransform();
      }
    }, {
      key: "setBeforeRender",
      value: function setBeforeRender(cb) {
        this._beforeRender = cb;
      }
    }, {
      key: "setAfterRender",
      value: function setAfterRender(cb) {
        this._afterRender = cb;
      }
    }, {
      key: "afterNextRender",
      value: function afterNextRender(cb) {
        this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);
      }
    }, {
      key: "enableView3dTransform",
      value: function enableView3dTransform() {
        this.view3dTranform || (this.view3dTranform = !0, this.pluginService.register(new ViewTransform3dPlugin()));
      }
    }, {
      key: "disableView3dTranform",
      value: function disableView3dTranform() {
        var _this2 = this;
        this.view3dTranform && (this.view3dTranform = !1, this.pluginService.findPluginsByName("ViewTransform3dPlugin").forEach(function (plugin) {
          _this2.pluginService.unRegister(plugin);
        }));
      }
    }, {
      key: "enableAutoRender",
      value: function enableAutoRender() {
        this.autoRender || (this.autoRender = !0, this.pluginService.register(new AutoRenderPlugin()));
      }
    }, {
      key: "disableAutoRender",
      value: function disableAutoRender() {
        var _this3 = this;
        this.autoRender && (this.autoRender = !1, this.pluginService.findPluginsByName("AutoRenderPlugin").forEach(function (plugin) {
          _this3.pluginService.unRegister(plugin);
        }));
      }
    }, {
      key: "enableIncrementalAutoRender",
      value: function enableIncrementalAutoRender() {
        this.increaseAutoRender || (this.increaseAutoRender = !0, this.pluginService.register(new IncrementalAutoRenderPlugin()));
      }
    }, {
      key: "disableIncrementalAutoRender",
      value: function disableIncrementalAutoRender() {
        var _this4 = this;
        this.increaseAutoRender && (this.increaseAutoRender = !1, this.pluginService.findPluginsByName("IncrementalAutoRenderPlugin").forEach(function (plugin) {
          _this4.pluginService.unRegister(plugin);
        }));
      }
    }, {
      key: "enableDirtyBounds",
      value: function enableDirtyBounds() {
        if (this.dirtyBounds) return;
        this.dirtyBounds = new Bounds();
        var plugin = this.pluginService.findPluginsByName("DirtyBoundsPlugin")[0];
        plugin ? plugin.activate(this.pluginService) : (plugin = new DirtyBoundsPlugin(), this.pluginService.register(plugin));
      }
    }, {
      key: "disableDirtyBounds",
      value: function disableDirtyBounds() {
        var _this5 = this;
        this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName("DirtyBoundsPlugin").forEach(function (plugin) {
          _this5.pluginService.unRegister(plugin);
        }));
      }
    }, {
      key: "enableLayout",
      value: function enableLayout() {
        this._enableLayout || (this._enableLayout = !0, this.pluginService.register(new FlexLayoutPlugin()));
      }
    }, {
      key: "disableLayout",
      value: function disableLayout() {
        var _this6 = this;
        this._enableLayout && (this._enableLayout = !1, this.pluginService.findPluginsByName("FlexLayoutPlugin").forEach(function (plugin) {
          _this6.pluginService.unRegister(plugin);
        }));
      }
    }, {
      key: "enableHtmlAttribute",
      value: function enableHtmlAttribute(container) {
        this.htmlAttribute || (this.htmlAttribute = container, this.pluginService.register(new HtmlAttributePlugin()));
      }
    }, {
      key: "disableHtmlAttribute",
      value: function disableHtmlAttribute() {
        var _this7 = this;
        this.htmlAttribute && (this.htmlAttribute = !1, this.pluginService.findPluginsByName("HtmlAttributePlugin").forEach(function (plugin) {
          _this7.pluginService.unRegister(plugin);
        }));
      }
    }, {
      key: "enableReactAttribute",
      value: function enableReactAttribute(container) {
        this.reactAttribute || (this.reactAttribute = container, this.pluginService.register(new ReactAttributePlugin()));
      }
    }, {
      key: "disableReactAttribute",
      value: function disableReactAttribute() {
        var _this8 = this;
        this.reactAttribute && (this.reactAttribute = !1, this.pluginService.findPluginsByName("ReactAttributePlugin").forEach(function (plugin) {
          _this8.pluginService.unRegister(plugin);
        }));
      }
    }, {
      key: "getPluginsByName",
      value: function getPluginsByName(name) {
        return this.pluginService.findPluginsByName(name);
      }
    }, {
      key: "tryUpdateAABBBounds",
      value: function tryUpdateAABBBounds() {
        var viewBox = this.window.getViewBox();
        return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), this._AABBBounds;
      }
    }, {
      key: "combineLayer",
      value: function combineLayer(ILayer1, ILayer2) {
        throw new Error("暂不支持");
      }
    }, {
      key: "createLayer",
      value: function createLayer(canvasId, layerMode) {
        var layer = this.layerService.createLayer(this, {
          main: !1,
          layerMode: layerMode,
          canvasId: canvasId
        });
        return this.appendChild(layer), layer;
      }
    }, {
      key: "sortLayer",
      value: function sortLayer(cb) {
        var _this9 = this;
        var children = this.children;
        children.sort(cb), this.removeAllChild(), children.forEach(function (c) {
          _this9.appendChild(c);
        });
      }
    }, {
      key: "removeLayer",
      value: function removeLayer(ILayerId) {
        return this.removeChild(this.findChildByUid(ILayerId));
      }
    }, {
      key: "tryInitInteractiveLayer",
      value: function tryInitInteractiveLayer() {
        this.supportInteractiveLayer && !this.interactiveLayer && (this.interactiveLayer = this.createLayer(), this.interactiveLayer.name = "_builtin_interactive", this.interactiveLayer.attribute.pickable = !1, this.nextFrameRenderLayerSet.add(this.interactiveLayer));
      }
    }, {
      key: "clearViewBox",
      value: function clearViewBox(color) {
        this.window.clearViewBox(color);
      }
    }, {
      key: "render",
      value: function render(layers, params) {
        this.ticker.start(), this.timeline.resume();
        var state = this.state;
        this.state = "rendering", this.layerService.prepareStageLayer(this), this._skipRender || (this.lastRenderparams = params, this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(this.children), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
      }
    }, {
      key: "combineLayersToWindow",
      value: function combineLayersToWindow() {}
    }, {
      key: "renderNextFrame",
      value: function renderNextFrame(layers, force) {
        var _this10 = this;
        this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach(function (layer) {
          _this10.nextFrameRenderLayerSet.add(layer);
        }), this.willNextFrameRender || (this.willNextFrameRender = !0, this.global.getRequestAnimationFrame()(function () {
          _this10._doRenderInThisFrame(), _this10.willNextFrameRender = !1;
        }));
      }
    }, {
      key: "_doRenderInThisFrame",
      value: function _doRenderInThisFrame() {
        this.timeline.resume(), this.ticker.start();
        var state = this.state;
        this.state = "rendering", this.layerService.prepareStageLayer(this), this.nextFrameRenderLayerSet.size && !this._skipRender && (this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(Array.from(this.nextFrameRenderLayerSet.values()), this.lastRenderparams || {}), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
      }
    }, {
      key: "renderLayerList",
      value: function renderLayerList(layerList, params) {
        var _this11 = this;
        var list = [];
        for (var i = 0; i < layerList.length; i++) {
          var l = layerList[i];
          "virtual" === l.layerMode && (l = l.getNativeHandler().mainHandler.layer), list.includes(l) || list.push(l);
        }
        list.forEach(function (layer) {
          layer.renderCount > _this11.renderCount || (layer.renderCount = _this11.renderCount + 1, layer.render({
            renderService: _this11.renderService,
            background: layer === _this11.defaultLayer ? _this11.background : void 0,
            updateBounds: !(!_this11.dirtyBounds || _this11.dirtyBounds.empty()),
            viewBox: _this11.window.getViewBox(),
            transMatrix: _this11.window.getViewBoxTransform()
          }, Object.assign({
            renderStyle: _this11.renderStyle
          }, params)));
        }), this.interactiveLayer && !layerList.includes(this.interactiveLayer) && this.interactiveLayer.render({
          renderService: this.renderService,
          updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
          viewBox: this.window.getViewBox(),
          transMatrix: this.window.getViewBoxTransform()
        }, Object.assign({
          renderStyle: this.renderStyle
        }, params));
      }
    }, {
      key: "resizeWindow",
      value: function resizeWindow(w, h) {
        var rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.window.resize(w, h), rerender && this.render();
      }
    }, {
      key: "resize",
      value: function resize(w, h) {
        var rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.window.hasSubView() || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.window.resize(w, h), this.forEachChildren(function (c) {
          c.resize(w, h);
        }), this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render();
      }
    }, {
      key: "resizeView",
      value: function resizeView(w, h) {
        var rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.forEachChildren(function (c) {
          c.resizeView(w, h);
        }), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
          right: this.width,
          bottom: this.height
        })), rerender && this.render();
      }
    }, {
      key: "setViewBox",
      value: function setViewBox(x, y, w, h, rerender) {
        var _this12 = this;
        var isRerender = !0;
        "object" == _typeof(x) ? (this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2), !1 === y && (isRerender = !1)) : (this.viewBox.setValue(x, y, x + w, y + h), !1 === rerender && (isRerender = !1)), this.forEachChildren(function (c) {
          c.resizeView(_this12.viewBox.width(), _this12.viewBox.height());
        }), isRerender && this.render();
      }
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        var rerender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        this.forEachChildren(function (c) {
          c.setDpr(dpr);
        }), rerender && this.render();
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(x, y) {
        throw new Error("暂不支持");
      }
    }, {
      key: "export",
      value: function _export(type) {
        throw new Error("暂不支持");
      }
    }, {
      key: "pick",
      value: function pick(x, y) {
        this.pickerService || (this.pickerService = container.get(PickerService));
        var result = this.pickerService.pick(this.children, new Point(x, y), {
          bounds: this.AABBBounds
        });
        return !(!(null == result ? void 0 : result.graphic) && !(null == result ? void 0 : result.group)) && result;
      }
    }, {
      key: "startAnimate",
      value: function startAnimate(t) {
        throw new Error("暂不支持");
      }
    }, {
      key: "setToFrame",
      value: function setToFrame(t) {
        throw new Error("暂不支持");
      }
    }, {
      key: "release",
      value: function release() {
        _get(_getPrototypeOf(Stage.prototype), "release", this).call(this), this.hooks.beforeRender.unTap("constructor", this.beforeRender), this.hooks.afterRender.unTap("constructor", this.afterRender), this.eventSystem && this.eventSystem.release(), this.layerService.releaseStage(this), this.pluginService.release(), this.forEach(function (layer) {
          layer.release();
        }), this.interactiveLayer && this.interactiveLayer.release(), this.window.release();
      }
    }, {
      key: "setStage",
      value: function setStage(stage) {}
    }, {
      key: "dirty",
      value: function dirty(b, matrix) {
        matrix && b.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2), this.dirtyBounds.union(b);
      }
    }, {
      key: "getLayer",
      value: function getLayer(name) {
        return this.children.filter(function (layer) {
          return layer.name === name;
        })[0];
      }
    }, {
      key: "renderTo",
      value: function renderTo(window) {
        var _this13 = this;
        this.forEachChildren(function (layer, i) {
          layer.drawTo(window, {
            renderService: _this13.renderService,
            viewBox: window.getViewBox(),
            transMatrix: window.getViewBoxTransform(),
            background: layer === _this13.defaultLayer ? _this13.background : void 0,
            clear: 0 === i,
            updateBounds: !(!_this13.dirtyBounds || _this13.dirtyBounds.empty())
          });
        });
      }
    }, {
      key: "renderToNewWindow",
      value: function renderToNewWindow() {
        var viewBox = arguments.length > 1 ? arguments[1] : undefined;
        var window = container.get(VWindow),
          x1 = viewBox ? -viewBox.x1 : 0,
          y1 = viewBox ? -viewBox.y1 : 0,
          x2 = viewBox ? viewBox.x2 : this.viewWidth,
          y2 = viewBox ? viewBox.y2 : this.viewHeight,
          width = viewBox ? viewBox.width() : this.viewWidth,
          height = viewBox ? viewBox.height() : this.viewHeight;
        return window.create({
          viewBox: {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          },
          width: width,
          height: height,
          dpr: this.window.dpr,
          canvasControled: !0,
          offscreen: !0,
          title: ""
        }), this.renderTo(window), window;
      }
    }, {
      key: "toCanvas",
      value: function toCanvas() {
        var fullImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        var viewBox = arguments.length > 1 ? arguments[1] : undefined;
        var c = this.renderToNewWindow(fullImage, viewBox).getNativeHandler();
        return c.nativeCanvas ? c.nativeCanvas : null;
      }
    }, {
      key: "setCursor",
      value: function setCursor(mode) {
        this._cursor = mode, this.eventSystem.setCursor(mode, "ignore");
      }
    }, {
      key: "getCursor",
      value: function getCursor() {
        return this._cursor;
      }
    }]);
    return Stage;
  }(Group);

  function createStage(params) {
    return new Stage(params);
  }

  var strCommandMap = ["arc", "arcTo", "bezierCurveTo", "closePath", "ellipse", "lineTo", "moveTo", "quadraticCurveTo", "rect"];

  var __decorate$1b = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$V = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var initMatrix = new Matrix(1, 0, 0, 1, 0, 0),
    globalPoint = {
      x: 0,
      y: 0
    };
  exports.EmptyContext2d = /*#__PURE__*/function () {
    function EmptyContext2d(canvas, dpr) {
      _classCallCheck(this, EmptyContext2d);
      this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.path = new CustomPath2D(), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    }
    _createClass(EmptyContext2d, [{
      key: "nativeContext",
      get: function get() {
        return this.path;
      }
    }, {
      key: "getCanvas",
      value: function getCanvas() {
        throw new Error("不支持getCanvas");
      }
    }, {
      key: "getContext",
      value: function getContext() {
        throw new Error("不支持getContext");
      }
    }, {
      key: "setTransformForCurrent",
      value: function setTransformForCurrent() {
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
      }
    }, {
      key: "currentMatrix",
      get: function get() {
        return this.matrix;
      }
    }, {
      key: "cloneMatrix",
      value: function cloneMatrix(m) {
        return matrixAllocate.allocateByObj(m);
      }
    }, {
      key: "clear",
      value: function clear() {
        this.save(), this.resetTransform(), this.restore();
      }
    }, {
      key: "restore",
      value: function restore() {
        this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent());
      }
    }, {
      key: "highPerformanceRestore",
      value: function highPerformanceRestore() {
        this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
      }
    }, {
      key: "rotate",
      value: function rotate(rad) {
        var setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "save",
      value: function save() {
        var matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
      }
    }, {
      key: "highPerformanceSave",
      value: function highPerformanceSave() {
        var matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
      }
    }, {
      key: "scale",
      value: function scale(sx, sy) {
        var setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "setScale",
      value: function setScale(sx, sy) {
        var setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "scalePoint",
      value: function scalePoint(sx, sy, px, py) {
        var setTransform = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;
        this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "setTransform",
      value: function setTransform(a, b, c, d, e, f) {
        var _setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
        var dpr = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this.dpr;
        this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), _setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "setTransformFromMatrix",
      value: function setTransformFromMatrix(matrix) {
        var setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        var dpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dpr;
        this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "resetTransform",
      value: function resetTransform() {
        var setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        var dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
        this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "transform",
      value: function transform(a, b, c, d, e, f) {
        var setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
        this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "transformFromMatrix",
      value: function transformFromMatrix(matrix, setTransform) {
        this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "translate",
      value: function translate(x, y) {
        var setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "rotateDegrees",
      value: function rotateDegrees(deg) {
        var setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        var rad = deg * Math.PI / 180;
        this.rotate(rad, setTransform);
      }
    }, {
      key: "rotateAbout",
      value: function rotateAbout(rad, x, y) {
        var setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
        this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "rotateDegreesAbout",
      value: function rotateDegreesAbout(deg, x, y) {
        var setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
        this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "beginPath",
      value: function beginPath() {
        this.path.clear();
      }
    }, {
      key: "clip",
      value: function clip(path, fillRule) {}
    }, {
      key: "arc",
      value: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {
        this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
      }
    }, {
      key: "arcTo",
      value: function arcTo(x1, y1, x2, y2, radiusX) {
        this.path.arcTo(x1, y1, x2, y2, radiusX);
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      }
    }, {
      key: "closePath",
      value: function closePath() {
        this.path.closePath();
      }
    }, {
      key: "ellipse",
      value: function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {}
    }, {
      key: "lineTo",
      value: function lineTo(x, y) {
        this.path.lineTo(x, y);
      }
    }, {
      key: "moveTo",
      value: function moveTo(x, y) {
        this.path.moveTo(x, y);
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(cpx, cpy, x, y) {
        this.path.quadraticCurveTo(cpx, cpy, x, y);
      }
    }, {
      key: "rect",
      value: function rect(x, y, w, h) {
        this.path.rect(x, y, w, h);
      }
    }, {
      key: "createImageData",
      value: function createImageData(imageDataOrSw, sh) {
        return null;
      }
    }, {
      key: "createLinearGradient",
      value: function createLinearGradient(x0, y0, x1, y1) {
        throw new Error("不支持createLinearGradient");
      }
    }, {
      key: "createPattern",
      value: function createPattern(image, repetition) {
        throw new Error("不支持createPattern");
      }
    }, {
      key: "createRadialGradient",
      value: function createRadialGradient(x0, y0, r0, x1, y1, r1) {
        throw new Error("不支持createRadialGradient");
      }
    }, {
      key: "createConicGradient",
      value: function createConicGradient(x, y, startAngle, endAngle) {
        return null;
      }
    }, {
      key: "fill",
      value: function fill(path, fillRule) {}
    }, {
      key: "fillRect",
      value: function fillRect(x, y, width, height) {
        this.path.rect(x, y, width, height);
      }
    }, {
      key: "clearRect",
      value: function clearRect(x, y, w, h) {}
    }, {
      key: "fillText",
      value: function fillText(text, x, y) {}
    }, {
      key: "getImageData",
      value: function getImageData(sx, sy, sw, sh) {
        return null;
      }
    }, {
      key: "getLineDash",
      value: function getLineDash() {
        return [];
      }
    }, {
      key: "isPointInPath",
      value: function isPointInPath(x, y) {
        return this.matrix.transformPoint({
          x: x,
          y: y
        }, globalPoint), contain(this.path.commandList, globalPoint.x, globalPoint.y);
      }
    }, {
      key: "isPointInStroke",
      value: function isPointInStroke(x, y) {
        if (!this.lineWidth) return !1;
        this.matrix.transformPoint({
          x: x,
          y: y
        }, globalPoint);
        var lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
        return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
      }
    }, {
      key: "measureText",
      value: function measureText(text) {
        throw new Error("不支持measureText");
      }
    }, {
      key: "putImageData",
      value: function putImageData(imagedata, dx, dy) {
        throw new Error("不支持measureText");
      }
    }, {
      key: "setLineDash",
      value: function setLineDash(segments) {}
    }, {
      key: "stroke",
      value: function stroke(path) {}
    }, {
      key: "strokeRect",
      value: function strokeRect(x, y, width, height) {
        this.path.rect(x, y, width, height);
      }
    }, {
      key: "strokeText",
      value: function strokeText(text, x, y) {}
    }, {
      key: "drawImage",
      value: function drawImage() {}
    }, {
      key: "setCommonStyle",
      value: function setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {}
    }, {
      key: "_setCommonStyle",
      value: function _setCommonStyle(params, offsetX, offsetY, defaultParams) {}
    }, {
      key: "setStrokeStyle",
      value: function setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {}
    }, {
      key: "_setStrokeStyle",
      value: function _setStrokeStyle(params, offsetX, offsetY, defaultParams) {}
    }, {
      key: "setTextStyleWithoutAlignBaseline",
      value: function setTextStyleWithoutAlignBaseline(params, defaultParams) {}
    }, {
      key: "setTextStyle",
      value: function setTextStyle(params, defaultParams) {}
    }, {
      key: "draw",
      value: function draw() {}
    }, {
      key: "clearMatrix",
      value: function clearMatrix() {
        var setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        var dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
        this.setTransformFromMatrix(initMatrix, setTransform, dpr);
      }
    }, {
      key: "setClearMatrix",
      value: function setClearMatrix(a, b, c, d, e, f) {
        this._clearMatrix.setValue(a, b, c, d, e, f);
      }
    }, {
      key: "onlyTranslate",
      value: function onlyTranslate() {
        var dpr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dpr;
        return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
      }
    }, {
      key: "release",
      value: function release() {
        this.stack.forEach(function (m) {
          return matrixAllocate.free(m);
        }), this.stack.length = 0;
      }
    }]);
    return EmptyContext2d;
  }();
  exports.EmptyContext2d = __decorate$1b([injectable(), __metadata$V("design:paramtypes", [Object, Number])], exports.EmptyContext2d);

  var __decorate$1a = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$U = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var DefaultConfig = {
    WIDTH: 500,
    HEIGHT: 500,
    DPR: 1
  };
  exports.BaseCanvas = /*#__PURE__*/function () {
    function BaseCanvas(params) {
      _classCallCheck(this, BaseCanvas);
      var _a;
      var nativeCanvas = params.nativeCanvas,
        _params$width = params.width,
        width = _params$width === void 0 ? DefaultConfig.WIDTH : _params$width,
        _params$height = params.height,
        height = _params$height === void 0 ? DefaultConfig.HEIGHT : _params$height,
        _params$dpr = params.dpr,
        dpr = _params$dpr === void 0 ? DefaultConfig.DPR : _params$dpr,
        x = params.x,
        y = params.y,
        id = params.id,
        _params$canvasControl = params.canvasControled,
        canvasControled = _params$canvasControl === void 0 ? !0 : _params$canvasControl;
      this._x = null != x ? x : 0, this._y = null != y ? y : 0, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, this._visiable = !1 !== params.visiable, this.controled = canvasControled, this._displayWidth = width, this._displayHeight = height, this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._id = null !== (_a = nativeCanvas.id) && void 0 !== _a ? _a : id, id && (nativeCanvas.id = id), this.init(params);
    }
    _createClass(BaseCanvas, [{
      key: "displayWidth",
      get: function get() {
        return this._pixelWidth / this._dpr;
      }
    }, {
      key: "displayHeight",
      get: function get() {
        return this._pixelHeight / this._dpr;
      }
    }, {
      key: "id",
      get: function get() {
        return this._id;
      }
    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(_x) {
        this._x = _x;
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(_y) {
        this._y = _y;
      }
    }, {
      key: "nativeCanvas",
      get: function get() {
        return this._nativeCanvas;
      }
    }, {
      key: "width",
      get: function get() {
        return this._pixelWidth;
      },
      set: function set(width) {
        this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
      }
    }, {
      key: "height",
      get: function get() {
        return this._pixelHeight;
      },
      set: function set(height) {
        this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
      }
    }, {
      key: "getContext",
      value: function getContext(str) {
        return this._context;
      }
    }, {
      key: "visiable",
      get: function get() {
        return this._visiable;
      },
      set: function set(visiable) {
        this._visiable = visiable, visiable ? this.show() : this.hide();
      }
    }, {
      key: "dpr",
      get: function get() {
        return this._dpr;
      },
      set: function set(dpr) {
        this._dpr = dpr, this.resize(this._displayWidth, this._displayHeight);
      }
    }, {
      key: "getNativeCanvas",
      value: function getNativeCanvas() {
        return this._nativeCanvas;
      }
    }, {
      key: "hide",
      value: function hide() {}
    }, {
      key: "show",
      value: function show() {}
    }, {
      key: "applyPosition",
      value: function applyPosition() {}
    }, {
      key: "resetStyle",
      value: function resetStyle(params) {}
    }, {
      key: "resize",
      value: function resize(width, height) {}
    }, {
      key: "toDataURL",
      value: function toDataURL(mimeType, quality) {
        return "";
      }
    }, {
      key: "readPixels",
      value: function readPixels(x, y, w, h) {
        return this._context.getImageData(x, y, w, h);
      }
    }, {
      key: "convertToBlob",
      value: function convertToBlob(options) {
        throw new Error("暂未实现");
      }
    }, {
      key: "transferToImageBitmap",
      value: function transferToImageBitmap() {
        throw new Error("暂未实现");
      }
    }, {
      key: "release",
      value: function release() {
        this.controled && this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
      }
    }]);
    return BaseCanvas;
  }();
  exports.BaseCanvas.env = "browser", exports.BaseCanvas = __decorate$1a([injectable(), __metadata$U("design:paramtypes", [Object])], exports.BaseCanvas);

  var __decorate$19 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  exports.BaseEnvContribution = /*#__PURE__*/function () {
    function BaseEnvContribution() {
      _classCallCheck(this, BaseEnvContribution);
    }
    _createClass(BaseEnvContribution, [{
      key: "configure",
      value: function configure(service) {
        service.env === this.type && service.setActiveEnvContribution(this);
      }
    }, {
      key: "getNativeAABBBounds",
      value: function getNativeAABBBounds(dom) {
        return new AABBBounds();
      }
    }, {
      key: "removeDom",
      value: function removeDom(dom) {
        return !1;
      }
    }, {
      key: "createDom",
      value: function createDom(params) {
        return null;
      }
    }, {
      key: "getDynamicCanvasCount",
      value: function getDynamicCanvasCount() {
        return 999;
      }
    }, {
      key: "getStaticCanvasCount",
      value: function getStaticCanvasCount() {
        return 999;
      }
    }, {
      key: "getElementById",
      value: function getElementById(str) {
        return document.getElementById(str);
      }
    }, {
      key: "getRootElement",
      value: function getRootElement() {
        return document.body;
      }
    }, {
      key: "loadJson",
      value: function loadJson(url) {
        var jsonPromise = fetch(url).then(function (data) {
          return data.json();
        });
        return jsonPromise.then(function (json) {
          return {
            data: json,
            state: "success"
          };
        })["catch"](function () {
          return {
            data: null,
            state: "fail"
          };
        }), jsonPromise;
      }
    }, {
      key: "loadArrayBuffer",
      value: function loadArrayBuffer(url) {
        return fetch(url).then(function (data) {
          return data.arrayBuffer();
        }).then(function (arrayBuffer) {
          return {
            data: arrayBuffer,
            loadState: "success"
          };
        })["catch"](function () {
          return {
            data: null,
            loadState: "fail"
          };
        });
      }
    }, {
      key: "loadBlob",
      value: function loadBlob(url) {
        return fetch(url).then(function (data) {
          return data.blob();
        }).then(function (blob) {
          return {
            data: blob,
            loadState: "success"
          };
        })["catch"](function () {
          return {
            data: null,
            loadState: "fail"
          };
        });
      }
    }, {
      key: "getElementTop",
      value: function getElementTop(dom, baseWindow) {
        return 0;
      }
    }, {
      key: "getElementLeft",
      value: function getElementLeft(dom, baseWindow) {
        return 0;
      }
    }, {
      key: "getElementTopLeft",
      value: function getElementTopLeft(dom, baseWindow) {
        return {
          top: 0,
          left: 0
        };
      }
    }]);
    return BaseEnvContribution;
  }();
  exports.BaseEnvContribution = __decorate$19([injectable()], exports.BaseEnvContribution);

  var __decorate$18 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$T = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  exports.BaseWindowHandlerContribution = /*#__PURE__*/function () {
    function BaseWindowHandlerContribution() {
      _classCallCheck(this, BaseWindowHandlerContribution);
      this._uid = Generator.GenAutoIncrementId(), this.viewBox = new AABBBounds(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    }
    _createClass(BaseWindowHandlerContribution, [{
      key: "onChange",
      value: function onChange(cb) {
        this._onChangeCb = cb;
      }
    }, {
      key: "configure",
      value: function configure(window, global) {
        global.env === this.type && window.setWindowHandler(this);
      }
    }, {
      key: "release",
      value: function release() {
        this.releaseWindow();
      }
    }, {
      key: "isVisible",
      value: function isVisible(bbox) {
        return !0;
      }
    }, {
      key: "onVisibleChange",
      value: function onVisibleChange(cb) {}
    }, {
      key: "getTopLeft",
      value: function getTopLeft(baseWindow) {
        return {
          top: 0,
          left: 0
        };
      }
    }, {
      key: "setViewBox",
      value: function setViewBox(vb) {
        this.viewBox.setValue(vb.x1, vb.y1, vb.x2, vb.y2);
      }
    }, {
      key: "getViewBox",
      value: function getViewBox() {
        return this.viewBox;
      }
    }, {
      key: "setViewBoxTransform",
      value: function setViewBoxTransform(a, b, c, d, e, f) {
        this.modelMatrix.setValue(a, b, c, d, e, f);
      }
    }, {
      key: "getViewBoxTransform",
      value: function getViewBoxTransform() {
        return this.modelMatrix;
      }
    }]);
    return BaseWindowHandlerContribution;
  }();
  exports.BaseWindowHandlerContribution = __decorate$18([injectable(), __metadata$T("design:paramtypes", [])], exports.BaseWindowHandlerContribution);

  var __decorate$17 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$S = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$A = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  exports.DefaultPickService = /*#__PURE__*/function () {
    function DefaultPickService(pickItemInterceptorContributions) {
      _classCallCheck(this, DefaultPickService);
      this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.type = "default", this.global = application.global;
    }
    _createClass(DefaultPickService, [{
      key: "_init",
      value: function _init() {
        this.InterceptorContributions = this.pickItemInterceptorContributions.getContributions().sort(function (a, b) {
          return a.order - b.order;
        });
      }
    }, {
      key: "pick",
      value: function pick(graphics, point, params) {
        var result = {
          graphic: null,
          group: null
        };
        params.pickerService = this;
        var w = params.bounds.width(),
          h = params.bounds.height();
        if (!new AABBBounds().setValue(0, 0, w, h).containsPoint(point)) return result;
        this.pickContext && (this.pickContext.inuse = !0), params.pickContext = this.pickContext, this.pickContext && this.pickContext.clearMatrix(!0, 1);
        var parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
        var group;
        for (var i = graphics.length - 1; i >= 0 && (result = graphics[i].isContainer ? this.pickGroup(graphics[i], point, parentMatrix, params) : this.pickItem(graphics[i], point, parentMatrix, params), !result.graphic); i--) group || (group = result.group);
        if (result.graphic || (result.group = group), this.pickContext && (this.pickContext.inuse = !1), result.graphic) {
          var g = result.graphic;
          for (; g.parent;) g = g.parent;
          g.shadowHost && (result.params = {
            shadowTarget: result.graphic
          }, result.graphic = g.shadowHost);
        }
        return result;
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(graphic, point, params) {
        var _a;
        return !!(null === (_a = this.pickItem(graphic, point, null, null != params ? params : {
          pickContext: this.pickContext,
          pickerService: this
        })) || void 0 === _a ? void 0 : _a.graphic);
      }
    }, {
      key: "pickGroup",
      value: function pickGroup(group, point, parentMatrix, params) {
        var _this = this;
        var result = {
          group: null,
          graphic: null
        };
        if (!1 === group.attribute.visibleAll) return result;
        var context = params.pickContext,
          lastMatrix = context.modelMatrix;
        if (context.camera) {
          var m = group.transMatrix,
            matrix = mat4Allocate.allocate();
          if (mat3Tomat4(matrix, m), lastMatrix) {
            if (matrix) {
              var _m = mat4Allocate.allocate();
              context.modelMatrix = multiplyMat4Mat4(_m, lastMatrix, matrix), mat4Allocate.free(matrix);
            }
          } else mat3Tomat4(matrix, group.globalTransMatrix), context.modelMatrix = matrix;
        }
        if (this.InterceptorContributions.length) for (var i = 0; i < this.InterceptorContributions.length; i++) {
          var drawContribution = this.InterceptorContributions[i];
          if (drawContribution.beforePickItem) {
            var _result = drawContribution.beforePickItem(group, this, point, params, {
              parentMatrix: parentMatrix
            });
            if (_result) return context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, _result;
          }
        }
        var transMatrix = group.transMatrix,
          currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix),
          newPoint = new Point(point.x, point.y);
        currentGroupMatrix.transformPoint(newPoint, newPoint);
        var insideGroup = group.AABBBounds.containsPoint(newPoint);
        if (!insideGroup && !group.stage.camera) return result;
        var pickedItem = this.pickItem(group, newPoint.clone(), parentMatrix, params);
        pickedItem && pickedItem.graphic && (result.graphic = pickedItem.graphic, result.params = pickedItem.params);
        var groupPicked = !1 !== group.attribute.pickable && insideGroup;
        return currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), !1 === group.attribute.childrenPickable || pickedItem && pickedItem.graphic || foreach(group, DefaultAttribute.zIndex, function (graphic) {
          if (graphic.isContainer) {
            var _newPoint = new Point(point.x, point.y),
              theme = getTheme(group).group,
              _group$attribute = group.attribute,
              _group$attribute$scro = _group$attribute.scrollX,
              scrollX = _group$attribute$scro === void 0 ? theme.scrollX : _group$attribute$scro,
              _group$attribute$scro2 = _group$attribute.scrollY,
              scrollY = _group$attribute$scro2 === void 0 ? theme.scrollY : _group$attribute$scro2;
            _newPoint.x -= scrollX, _newPoint.y -= scrollY, result = _this.pickGroup(graphic, _newPoint, currentGroupMatrix, params);
          } else {
            var _newPoint2 = new Point(point.x, point.y);
            currentGroupMatrix.transformPoint(_newPoint2, _newPoint2);
            var _theme = getTheme(group).group,
              _group$attribute2 = group.attribute,
              _group$attribute2$scr = _group$attribute2.scrollX,
              _scrollX = _group$attribute2$scr === void 0 ? _theme.scrollX : _group$attribute2$scr,
              _group$attribute2$scr2 = _group$attribute2.scrollY,
              _scrollY = _group$attribute2$scr2 === void 0 ? _theme.scrollY : _group$attribute2$scr2;
            _newPoint2.x -= _scrollX, _newPoint2.y -= _scrollY;
            var _pickedItem = _this.pickItem(graphic, _newPoint2, parentMatrix, params);
            _pickedItem && _pickedItem.graphic && (result.graphic = _pickedItem.graphic, result.params = _pickedItem.params);
          }
          return !!result.graphic || !!result.group;
        }, !0, !!context.camera), context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result.graphic || result.group || !groupPicked || group.stage.camera || (result.group = group), matrixAllocate.free(currentGroupMatrix), result;
      }
    }, {
      key: "selectPicker",
      value: function selectPicker(graphic) {
        var picker = this.pickerMap.get(graphic.numberType);
        return picker || null;
      }
    }]);
    return DefaultPickService;
  }();
  exports.DefaultPickService = __decorate$17([injectable(), __param$A(0, inject(ContributionProvider)), __param$A(0, named(PickItemInterceptor)), __metadata$S("design:paramtypes", [Object])], exports.DefaultPickService);

  var __decorate$16 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$R = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  exports.DefaultGlobalPickerService = /*#__PURE__*/function () {
    function DefaultGlobalPickerService() {
      var _this = this;
      _classCallCheck(this, DefaultGlobalPickerService);
      this.global = application.global, this.global.hooks.onSetEnv.tap("global-picker-service", function (lastEnv, env, global) {
        _this.configure(global, env);
      }), this.configure(this.global, this.global.env);
    }
    _createClass(DefaultGlobalPickerService, [{
      key: "configure",
      value: function configure(global, env) {}
    }, {
      key: "pick",
      value: function pick(graphics, point, params) {
        var result = {
          graphic: null,
          group: null
        };
        var parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
        var group;
        for (var i = 0; i < graphics.length; i++) {
          if (graphics[i].isContainer) result = this.pickGroup(graphics[i], point, parentMatrix, params);else {
            var data = this.pickItem(graphics[i], point, parentMatrix, params);
            data && (result.graphic = data.graphic, result.params = data.params);
          }
          if (result.graphic) break;
          group || (group = result.group);
        }
        if (result.graphic || (result.group = group), result.graphic) {
          var g = result.graphic;
          for (; g.parent;) g = g.parent;
          g.shadowHost && (result.params = {
            shadowTarget: result.graphic
          }, result.graphic = g.shadowHost);
        }
        return result;
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(graphic, point, params) {
        return !!this.pickItem(graphic, point, null, params);
      }
    }, {
      key: "pickGroup",
      value: function pickGroup(group, point, parentMatrix, params) {
        var _this2 = this;
        var result = {
          group: null,
          graphic: null
        };
        if (!1 === group.attribute.visibleAll) return result;
        var transMatrix = group.transMatrix,
          newPoint = new Point(point.x, point.y);
        parentMatrix.transformPoint(newPoint, newPoint);
        var insideGroup = group.AABBBounds.containsPoint(newPoint);
        if (!insideGroup) return result;
        var groupPicked = !1 !== group.attribute.pickable && insideGroup;
        return parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), !1 !== group.attribute.childrenPickable && group.forEachChildren(function (graphic) {
          if (graphic.isContainer) result = _this2.pickGroup(graphic, point, parentMatrix, params);else {
            var _newPoint = new Point(point.x, point.y);
            parentMatrix.transformPoint(_newPoint, _newPoint);
            var data = _this2.pickItem(graphic, _newPoint, parentMatrix, params);
            data && (result.graphic = data.graphic, result.params = data.params);
          }
          return !!result.graphic || !!result.group;
        }), result.graphic || result.group || !groupPicked || (result.group = group), result;
      }
    }, {
      key: "pickItem",
      value: function pickItem(graphic, point, parentMatrix, params) {
        return !1 === graphic.attribute.pickable ? null : graphic.AABBBounds.containsPoint(point) ? {
          graphic: graphic
        } : null;
      }
    }]);
    return DefaultGlobalPickerService;
  }();
  exports.DefaultGlobalPickerService = __decorate$16([injectable(), __metadata$R("design:paramtypes", [])], exports.DefaultGlobalPickerService);

  function simplifyRadialDist(points, sqTolerance) {
    var deltaX,
      deltaY,
      lastX = points[0].x,
      lastY = points[0].y;
    var newPoints = [points[0]];
    for (var i = 1, len = points.length; i < len; i++) deltaX = points[i].x - lastX, deltaY = points[i].y - lastY, deltaX * deltaX + deltaY * deltaY > sqTolerance && (lastX = points[i].x, lastY = points[i].y, newPoints.push(points[i]));
    return points[points.length - 1].x === lastX && points[points.length - 1].y === lastY || newPoints.push(points[points.length - 1]), newPoints;
  }
  function simplifyDPStep(points, startIdx, endIdx, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
      nextIdx = startIdx;
    var startX = points[startIdx].x,
      startY = points[startIdx].y,
      vecX2 = points[endIdx].x - startX,
      vecY2 = points[endIdx].y - startY,
      sqLength = vecX2 * vecX2 + vecY2 * vecY2;
    var area, sqArea, sqDistance, vecX1, vecY1;
    for (var i = startIdx + 1, len = endIdx - 1; i < len; i++) vecX1 = points[i].x - startX, vecY1 = points[i].y - startY, area = vecX1 * vecY2 - vecX2 * vecY1, sqArea = area * area, sqDistance = sqArea / sqLength, sqDistance > maxSqDist && (maxSqDist = sqDistance, nextIdx = i);
    maxSqDist > sqTolerance && (nextIdx - startIdx > 2 && simplifyDPStep(points, startIdx, nextIdx, sqTolerance, simplified), simplified.push(points[nextIdx], points[nextIdx + 1]), endIdx - nextIdx > 2 && simplifyDPStep(points, nextIdx, endIdx, sqTolerance, simplified));
  }
  function simplifyDouglasPeucker(points, sqTolerance) {
    var lastIdx = points.length - 1,
      simplified = [points[0]];
    return simplifyDPStep(points, 0, lastIdx, sqTolerance, simplified), simplified.push(points[lastIdx]), simplified;
  }
  function flatten_simplify(points, tolerance, highestQuality) {
    if (points.length <= 10) return points;
    var sqTolerance = void 0 !== tolerance ? tolerance * tolerance : 1;
    return points = simplifyDouglasPeucker(points = highestQuality ? points : simplifyRadialDist(points, sqTolerance), sqTolerance);
  }

  var DefaultGraphicAllocate = /*#__PURE__*/function () {
    function DefaultGraphicAllocate() {
      _classCallCheck(this, DefaultGraphicAllocate);
      this.pools = [];
    }
    _createClass(DefaultGraphicAllocate, [{
      key: "free",
      value: function free(d) {
        this.pools.push(d);
      }
    }, {
      key: "length",
      get: function get() {
        return this.pools.length;
      }
    }, {
      key: "release",
      value: function release() {
        this.pools = [];
      }
    }]);
    return DefaultGraphicAllocate;
  }();
  var DefaultRectAllocate = /*#__PURE__*/function (_DefaultGraphicAlloca) {
    _inherits(DefaultRectAllocate, _DefaultGraphicAlloca);
    var _super = _createSuper(DefaultRectAllocate);
    function DefaultRectAllocate() {
      _classCallCheck(this, DefaultRectAllocate);
      return _super.apply(this, arguments);
    }
    _createClass(DefaultRectAllocate, [{
      key: "allocate",
      value: function allocate(attribute) {
        if (!this.pools.length) return application.graphicService.creator.rect(attribute);
        var g = this.pools.pop();
        return g.initAttributes(attribute), g;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(rect) {
        if (!this.pools.length) return application.graphicService.creator.rect(rect.attribute);
        var g = this.pools.pop();
        return g.initAttributes(rect.attribute), g;
      }
    }]);
    return DefaultRectAllocate;
  }(DefaultGraphicAllocate);
  var defaultRectAllocate = new DefaultRectAllocate();
  var DefaultArcAllocate = /*#__PURE__*/function (_DefaultGraphicAlloca2) {
    _inherits(DefaultArcAllocate, _DefaultGraphicAlloca2);
    var _super2 = _createSuper(DefaultArcAllocate);
    function DefaultArcAllocate() {
      _classCallCheck(this, DefaultArcAllocate);
      return _super2.apply(this, arguments);
    }
    _createClass(DefaultArcAllocate, [{
      key: "allocate",
      value: function allocate(attribute) {
        if (!this.pools.length) return application.graphicService.creator.arc(attribute);
        var g = this.pools.pop();
        return g.initAttributes(attribute), g;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(arc) {
        if (!this.pools.length) return application.graphicService.creator.arc(arc.attribute);
        var g = this.pools.pop();
        return g.initAttributes(arc.attribute), g;
      }
    }]);
    return DefaultArcAllocate;
  }(DefaultGraphicAllocate);
  var defaultArcAllocate = new DefaultArcAllocate();
  var DefaultAreaAllocate = /*#__PURE__*/function (_DefaultGraphicAlloca3) {
    _inherits(DefaultAreaAllocate, _DefaultGraphicAlloca3);
    var _super3 = _createSuper(DefaultAreaAllocate);
    function DefaultAreaAllocate() {
      _classCallCheck(this, DefaultAreaAllocate);
      return _super3.apply(this, arguments);
    }
    _createClass(DefaultAreaAllocate, [{
      key: "allocate",
      value: function allocate(attribute) {
        if (!this.pools.length) return application.graphicService.creator.area(attribute);
        var g = this.pools.pop();
        return g.initAttributes(attribute), g;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(area) {
        if (!this.pools.length) return application.graphicService.creator.area(area.attribute);
        var g = this.pools.pop();
        return g.initAttributes(area.attribute), g;
      }
    }]);
    return DefaultAreaAllocate;
  }(DefaultGraphicAllocate);
  var defaultAreaAllocate = new DefaultAreaAllocate();
  var DefaultCircleAllocate = /*#__PURE__*/function (_DefaultGraphicAlloca4) {
    _inherits(DefaultCircleAllocate, _DefaultGraphicAlloca4);
    var _super4 = _createSuper(DefaultCircleAllocate);
    function DefaultCircleAllocate() {
      _classCallCheck(this, DefaultCircleAllocate);
      return _super4.apply(this, arguments);
    }
    _createClass(DefaultCircleAllocate, [{
      key: "allocate",
      value: function allocate(attribute) {
        if (!this.pools.length) return application.graphicService.creator.circle(attribute);
        var g = this.pools.pop();
        return g.initAttributes(attribute), g;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(area) {
        if (!this.pools.length) return application.graphicService.creator.circle(area.attribute);
        var g = this.pools.pop();
        return g.initAttributes(area.attribute), g;
      }
    }]);
    return DefaultCircleAllocate;
  }(DefaultGraphicAllocate);
  var defaultCircleAllocate = new DefaultCircleAllocate();
  var DefaultLineAllocate = /*#__PURE__*/function (_DefaultGraphicAlloca5) {
    _inherits(DefaultLineAllocate, _DefaultGraphicAlloca5);
    var _super5 = _createSuper(DefaultLineAllocate);
    function DefaultLineAllocate() {
      _classCallCheck(this, DefaultLineAllocate);
      return _super5.apply(this, arguments);
    }
    _createClass(DefaultLineAllocate, [{
      key: "allocate",
      value: function allocate(attribute) {
        if (!this.pools.length) return application.graphicService.creator.line(attribute);
        var g = this.pools.pop();
        return g.initAttributes(attribute), g;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(line) {
        if (!this.pools.length) return application.graphicService.creator.line(line.attribute);
        var g = this.pools.pop();
        return g.initAttributes(line.attribute), g;
      }
    }]);
    return DefaultLineAllocate;
  }(DefaultGraphicAllocate);
  var defaultLineAllocate = new DefaultLineAllocate();
  var DefaultPathAllocate = /*#__PURE__*/function (_DefaultGraphicAlloca6) {
    _inherits(DefaultPathAllocate, _DefaultGraphicAlloca6);
    var _super6 = _createSuper(DefaultPathAllocate);
    function DefaultPathAllocate() {
      _classCallCheck(this, DefaultPathAllocate);
      return _super6.apply(this, arguments);
    }
    _createClass(DefaultPathAllocate, [{
      key: "allocate",
      value: function allocate(attribute) {
        if (!this.pools.length) return application.graphicService.creator.path(attribute);
        var g = this.pools.pop();
        return g.initAttributes(attribute), g;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(path) {
        if (!this.pools.length) return application.graphicService.creator.path(path.attribute);
        var g = this.pools.pop();
        return g.initAttributes(path.attribute), g;
      }
    }]);
    return DefaultPathAllocate;
  }(DefaultGraphicAllocate);
  var defaultPathAllocate = new DefaultPathAllocate();
  var DefaultSymbolAllocate = /*#__PURE__*/function (_DefaultGraphicAlloca7) {
    _inherits(DefaultSymbolAllocate, _DefaultGraphicAlloca7);
    var _super7 = _createSuper(DefaultSymbolAllocate);
    function DefaultSymbolAllocate() {
      _classCallCheck(this, DefaultSymbolAllocate);
      return _super7.apply(this, arguments);
    }
    _createClass(DefaultSymbolAllocate, [{
      key: "allocate",
      value: function allocate(attribute) {
        if (!this.pools.length) return application.graphicService.creator.symbol(attribute);
        var g = this.pools.pop();
        return g.initAttributes(attribute), g;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(symbol) {
        if (!this.pools.length) return application.graphicService.creator.symbol(symbol.attribute);
        var g = this.pools.pop();
        return g.initAttributes(symbol.attribute), g;
      }
    }]);
    return DefaultSymbolAllocate;
  }(DefaultGraphicAllocate);
  var defaultSymbolAllocate = new DefaultSymbolAllocate();
  var DefaultTextAllocate = /*#__PURE__*/function (_DefaultGraphicAlloca8) {
    _inherits(DefaultTextAllocate, _DefaultGraphicAlloca8);
    var _super8 = _createSuper(DefaultTextAllocate);
    function DefaultTextAllocate() {
      _classCallCheck(this, DefaultTextAllocate);
      return _super8.apply(this, arguments);
    }
    _createClass(DefaultTextAllocate, [{
      key: "allocate",
      value: function allocate(attribute) {
        if (!this.pools.length) return application.graphicService.creator.text(attribute);
        var g = this.pools.pop();
        return g.initAttributes(attribute), g;
      }
    }, {
      key: "allocateByObj",
      value: function allocateByObj(text) {
        if (!this.pools.length) return application.graphicService.creator.text(text.attribute);
        var g = this.pools.pop();
        return g.initAttributes(text.attribute), g;
      }
    }]);
    return DefaultTextAllocate;
  }(DefaultGraphicAllocate);
  var defaultTextAllocate = new DefaultTextAllocate();
  var DefaultGraphicMemoryManager = /*#__PURE__*/function () {
    function DefaultGraphicMemoryManager() {
      _classCallCheck(this, DefaultGraphicMemoryManager);
      this.map = {
        text: defaultTextAllocate,
        symbol: defaultSymbolAllocate
      };
    }
    _createClass(DefaultGraphicMemoryManager, [{
      key: "gc",
      value: function gc(g) {
        var _this = this;
        g.isContainer ? g.forEachChildren(function (i) {
          return _this.gc(i);
        }) : this.gcItem(g);
      }
    }, {
      key: "gcItem",
      value: function gcItem(g) {
        var allocate = this.map[g.type];
        allocate && allocate.free(g);
      }
    }]);
    return DefaultGraphicMemoryManager;
  }();
  var defaultGraphicMemoryManager = new DefaultGraphicMemoryManager();

  var loadArcModule = !1;
  var arcModule = new ContainerModule(function (bind) {
    loadArcModule || (loadArcModule = !0, bind(exports.DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(ArcRender).to(exports.DefaultCanvasArcRender).inSingletonScope(), bind(GraphicRender).toService(ArcRender), bind(ArcRenderContribution).toService(exports.DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ArcRenderContribution));
  });

  var loadRectModule = !1;
  var rectModule = new ContainerModule(function (bind) {
    loadRectModule || (loadRectModule = !0, bind(exports.DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(RectRender).to(exports.DefaultCanvasRectRender).inSingletonScope(), bind(GraphicRender).toService(RectRender), bind(exports.SplitRectAfterRenderContribution).toSelf(), bind(exports.SplitRectBeforeRenderContribution).toSelf(), bind(RectRenderContribution).toService(exports.SplitRectAfterRenderContribution), bind(RectRenderContribution).toService(exports.SplitRectBeforeRenderContribution), bind(RectRenderContribution).toService(exports.DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, RectRenderContribution));
  });

  var loadLineModule = !1;
  var lineModule = new ContainerModule(function (bind) {
    loadLineModule || (loadLineModule = !0, bind(exports.DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), bind(LineRender).to(exports.DefaultCanvasLineRender).inSingletonScope(), bind(GraphicRender).toService(LineRender));
  });

  var loadAreaModule = !1;
  var areaModule = new ContainerModule(function (bind) {
    loadAreaModule || (loadAreaModule = !0, bind(exports.DefaultCanvasAreaRender).toSelf().inSingletonScope(), bind(AreaRender).to(exports.DefaultCanvasAreaRender).inSingletonScope(), bind(GraphicRender).toService(AreaRender), bind(AreaRenderContribution).toService(exports.DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, AreaRenderContribution), bind(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope());
  });

  var loadSymbolModule = !1;
  var symbolModule = new ContainerModule(function (bind) {
    loadSymbolModule || (loadSymbolModule = !0, bind(exports.DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(SymbolRender).to(exports.DefaultCanvasSymbolRender).inSingletonScope(), bind(GraphicRender).toService(SymbolRender), bind(SymbolRenderContribution).toService(exports.DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, SymbolRenderContribution));
  });

  var loadCircleModule = !1;
  var circleModule = new ContainerModule(function (bind) {
    loadCircleModule || (loadCircleModule = !0, bind(exports.DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(CircleRender).to(exports.DefaultCanvasCircleRender).inSingletonScope(), bind(GraphicRender).toService(CircleRender), bind(CircleRenderContribution).toService(exports.DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, CircleRenderContribution));
  });

  var loadTextModule = !1;
  var textModule = new ContainerModule(function (bind) {
    loadTextModule || (loadTextModule = !0, bind(TextRender).to(exports.DefaultCanvasTextRender).inSingletonScope(), bind(GraphicRender).toService(TextRender), bind(TextRenderContribution).toService(exports.DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, TextRenderContribution));
  });

  var loadPathModule = !1;
  var pathModule = new ContainerModule(function (bind) {
    loadPathModule || (loadPathModule = !0, bind(exports.DefaultCanvasPathRender).toSelf().inSingletonScope(), bind(PathRender).to(exports.DefaultCanvasPathRender).inSingletonScope(), bind(GraphicRender).toService(PathRender), bind(PathRenderContribution).toService(exports.DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PathRenderContribution));
  });

  var loadPolygonModule = !1;
  var polygonModule = new ContainerModule(function (bind) {
    loadPolygonModule || (loadPolygonModule = !0, bind(PolygonRender).to(exports.DefaultCanvasPolygonRender).inSingletonScope(), bind(GraphicRender).toService(PolygonRender), bind(PolygonRenderContribution).toService(exports.DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PolygonRenderContribution));
  });

  var __decorate$15 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultCanvasGlyphRender = /*#__PURE__*/function () {
    function DefaultCanvasGlyphRender() {
      _classCallCheck(this, DefaultCanvasGlyphRender);
      this.numberType = GLYPH_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasGlyphRender, [{
      key: "drawShape",
      value: function drawShape(glyph, context, x, y, drawContext, params, fillCb, strokeCb) {
        drawContext.drawContribution && glyph.getSubGraphic().forEach(function (item) {
          var renderer = drawContext.drawContribution.getRenderContribution(item);
          renderer && renderer.drawShape && renderer.drawShape(item, context, x, y, drawContext, params, fillCb, strokeCb);
        });
      }
    }, {
      key: "draw",
      value: function draw(glyph, renderService, drawContext, params) {
        var context = drawContext.context;
        if (!context) return;
        if (context.highPerformanceSave(), !drawContext.drawContribution) return;
        var glyphTheme = getTheme(glyph),
          subGraphic = glyph.getSubGraphic();
        subGraphic.length && subGraphic.forEach(function (g) {
          drawContext.drawContribution.renderItem(g, drawContext, {
            theme: glyphTheme
          });
        }), context.highPerformanceRestore();
      }
    }]);
    return DefaultCanvasGlyphRender;
  }();
  DefaultCanvasGlyphRender = __decorate$15([injectable()], DefaultCanvasGlyphRender);

  var loadGlyphModule = !1;
  var glyphModule = new ContainerModule(function (bind) {
    loadGlyphModule || (loadGlyphModule = !0, bind(GlyphRender).to(DefaultCanvasGlyphRender).inSingletonScope(), bind(GraphicRender).toService(GlyphRender));
  });

  var __decorate$14 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$Q = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var DefaultCanvasRichTextRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasRichTextRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasRichTextRender);
    function DefaultCanvasRichTextRender() {
      var _this;
      _classCallCheck(this, DefaultCanvasRichTextRender);
      _this = _super.call(this), _this.numberType = RICHTEXT_NUMBER_TYPE, _this.builtinContributions = [defaultTextBackgroundRenderContribution], _this.init();
      return _this;
    }
    _createClass(DefaultCanvasRichTextRender, [{
      key: "drawShape",
      value: function drawShape(richtext, context, x, y, drawContext) {
        var richtextAttribute = getTheme(richtext).richtext,
          _richtext$attribute = richtext.attribute,
          _richtext$attribute$s = _richtext$attribute.strokeOpacity,
          strokeOpacity = _richtext$attribute$s === void 0 ? richtextAttribute.strokeOpacity : _richtext$attribute$s,
          _richtext$attribute$o = _richtext$attribute.opacity,
          opacity = _richtext$attribute$o === void 0 ? richtextAttribute.opacity : _richtext$attribute$o,
          _richtext$attribute$f = _richtext$attribute.fillOpacity,
          fillOpacity = _richtext$attribute$f === void 0 ? richtextAttribute.fillOpacity : _richtext$attribute$f,
          _richtext$attribute$v = _richtext$attribute.visible,
          visible = _richtext$attribute$v === void 0 ? richtextAttribute.visible : _richtext$attribute$v;
        if (!richtext.valid || !visible) return;
        var fVisible = fillVisible(opacity, fillOpacity, !0),
          sVisible = fillVisible(opacity, strokeOpacity, !0);
        if (!fVisible) return;
        context.translate(x, y), this.beforeRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
        richtext.getFrameCache().draw(context, this.drawIcon), this.afterRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
      }
    }, {
      key: "drawIcon",
      value: function drawIcon(icon, context, x, y, baseline) {
        var _a;
        var richtextIconAttribute = getTheme(icon).richtextIcon,
          _icon$attribute = icon.attribute,
          _icon$attribute$width = _icon$attribute.width,
          width = _icon$attribute$width === void 0 ? richtextIconAttribute.width : _icon$attribute$width,
          _icon$attribute$heigh = _icon$attribute.height,
          height = _icon$attribute$heigh === void 0 ? richtextIconAttribute.height : _icon$attribute$heigh,
          _icon$attribute$opaci = _icon$attribute.opacity,
          opacity = _icon$attribute$opaci === void 0 ? richtextIconAttribute.opacity : _icon$attribute$opaci,
          url = _icon$attribute.image,
          _icon$attribute$backg = _icon$attribute.backgroundFill,
          backgroundFill = _icon$attribute$backg === void 0 ? richtextIconAttribute.backgroundFill : _icon$attribute$backg,
          _icon$attribute$backg2 = _icon$attribute.backgroundFillOpacity,
          backgroundFillOpacity = _icon$attribute$backg2 === void 0 ? richtextIconAttribute.backgroundFillOpacity : _icon$attribute$backg2,
          _icon$attribute$backg3 = _icon$attribute.backgroundStroke,
          backgroundStroke = _icon$attribute$backg3 === void 0 ? richtextIconAttribute.backgroundStroke : _icon$attribute$backg3,
          _icon$attribute$backg4 = _icon$attribute.backgroundStrokeOpacity,
          backgroundStrokeOpacity = _icon$attribute$backg4 === void 0 ? richtextIconAttribute.backgroundStrokeOpacity : _icon$attribute$backg4,
          _icon$attribute$backg5 = _icon$attribute.backgroundRadius,
          backgroundRadius = _icon$attribute$backg5 === void 0 ? richtextIconAttribute.backgroundRadius : _icon$attribute$backg5,
          margin = _icon$attribute.margin,
          _icon$attribute2 = icon.attribute,
          _icon$attribute2$back = _icon$attribute2.backgroundWidth,
          backgroundWidth = _icon$attribute2$back === void 0 ? width : _icon$attribute2$back,
          _icon$attribute2$back2 = _icon$attribute2.backgroundHeight,
          backgroundHeight = _icon$attribute2$back2 === void 0 ? height : _icon$attribute2$back2;
        if (margin && (x += icon._marginArray[3], y += icon._marginArray[0]), icon._hovered) {
          var expandX = (backgroundWidth - width) / 2,
            expandY = (backgroundHeight - height) / 2;
          0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius)), backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, context.strokeStyle = backgroundStroke, context.stroke());
        }
        var res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));
        res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));
      }
    }, {
      key: "draw",
      value: function draw(richtext, renderService, drawContext) {
        var richtextAttribute = getTheme(richtext).richtext;
        this._draw(richtext, richtextAttribute, !1, drawContext);
      }
    }]);
    return DefaultCanvasRichTextRender;
  }(BaseRender);
  DefaultCanvasRichTextRender = __decorate$14([injectable(), __metadata$Q("design:paramtypes", [])], DefaultCanvasRichTextRender);

  var loadRichtextModule = !1;
  var richtextModule = new ContainerModule(function (bind) {
    loadRichtextModule || (loadRichtextModule = !0, bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(), bind(GraphicRender).toService(RichTextRender));
  });

  var loadImageModule = !1;
  var imageModule = new ContainerModule(function (bind) {
    loadImageModule || (loadImageModule = !0, bind(ImageRender).to(exports.DefaultCanvasImageRender).inSingletonScope(), bind(GraphicRender).toService(ImageRender), bind(ImageRenderContribution).toService(exports.DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ImageRenderContribution));
  });

  var __decorate$13 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultCanvasRect3dRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasRect3dRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasRect3dRender);
    function DefaultCanvasRect3dRender() {
      var _this;
      _classCallCheck(this, DefaultCanvasRect3dRender);
      _this = _super.apply(this, arguments), _this.type = "rect3d", _this.numberType = RECT3D_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasRect3dRender, [{
      key: "drawShape",
      value: function drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        var rectAttribute = getTheme(rect, null == params ? void 0 : params.theme).rect3d,
          _rect$attribute = rect.attribute,
          _rect$attribute$fill = _rect$attribute.fill,
          fill = _rect$attribute$fill === void 0 ? rectAttribute.fill : _rect$attribute$fill,
          _rect$attribute$strok = _rect$attribute.stroke,
          stroke = _rect$attribute$strok === void 0 ? rectAttribute.stroke : _rect$attribute$strok,
          x1 = _rect$attribute.x1,
          y1 = _rect$attribute.y1,
          originX = _rect$attribute.x,
          originY = _rect$attribute.y,
          _rect$attribute$opaci = _rect$attribute.opacity,
          opacity = _rect$attribute$opaci === void 0 ? rectAttribute.opacity : _rect$attribute$opaci,
          _rect$attribute$fillO = _rect$attribute.fillOpacity,
          fillOpacity = _rect$attribute$fillO === void 0 ? rectAttribute.fillOpacity : _rect$attribute$fillO,
          _rect$attribute$lineW = _rect$attribute.lineWidth,
          lineWidth = _rect$attribute$lineW === void 0 ? rectAttribute.lineWidth : _rect$attribute$lineW,
          _rect$attribute$strok2 = _rect$attribute.strokeOpacity,
          strokeOpacity = _rect$attribute$strok2 === void 0 ? rectAttribute.strokeOpacity : _rect$attribute$strok2,
          _rect$attribute$visib = _rect$attribute.visible,
          visible = _rect$attribute$visib === void 0 ? rectAttribute.visible : _rect$attribute$visib;
        var _rect$attribute2 = rect.attribute,
          width = _rect$attribute2.width,
          height = _rect$attribute2.height;
        width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
        var z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
          fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
          sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height),
          doFill = runFill(fill),
          doStroke = runStroke(stroke, lineWidth);
        if (!rect.valid || !visible) return;
        if (!doFill && !doStroke) return;
        if (!(fVisible || sVisible || fillCb || strokeCb)) return;
        var _ref = drawContext.stage || {},
          light = _ref.light;
          _ref.camera;
          var face3d = rect.findFace();
        if (!1 !== fill) {
          context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);
          var fc = fill;
          "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, fc, context, light, fillCb);
        }
        !1 !== stroke && (context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute), this.stroke(x, y, z, face3d, context));
      }
    }, {
      key: "stroke",
      value: function stroke(x, y, z, face3d, context) {
        var vertices = face3d.vertices;
        face3d.edges.forEach(function (edge) {
          var p1 = vertices[edge[0]],
            v1 = {
              x: x + p1[0],
              y: y + p1[1],
              z: z + p1[2]
            },
            p2 = vertices[edge[1]],
            v2 = {
              x: x + p2[0],
              y: y + p2[1],
              z: z + p2[2]
            };
          context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
        });
      }
    }, {
      key: "fill",
      value: function fill(x, y, z, face3d, fillColor, context, light, fillCb) {
        var rgbArray = ColorStore.Get(fillColor, exports.ColorType.Color255),
          vertices = face3d.vertices,
          viewdVerticesZ = vertices.map(function (v) {
            return context.view(v[0], v[1], v[2])[2];
          }),
          sortFace = [];
        face3d.polygons.forEach(function (p, i) {
          sortFace.push({
            faceIdx: i,
            polygon: p
          });
          var polygon = p.polygon;
            p.normal;
            var z1 = viewdVerticesZ[polygon[0]],
            z2 = viewdVerticesZ[polygon[1]],
            z3 = viewdVerticesZ[polygon[2]],
            z4 = viewdVerticesZ[polygon[3]];
          p.ave_z = z1 + z2 + z3 + z4;
        }), sortFace.sort(function (a, b) {
          return b.polygon.ave_z - a.polygon.ave_z;
        }), sortFace.forEach(function (item) {
          var _item$polygon = item.polygon,
            polygon = _item$polygon.polygon,
            normal = _item$polygon.normal,
            p1 = vertices[polygon[0]],
            p2 = vertices[polygon[1]],
            p3 = vertices[polygon[2]],
            p4 = vertices[polygon[3]],
            v1 = {
              x: x + p1[0],
              y: y + p1[1],
              z: z + p1[2]
            },
            v2 = {
              x: x + p2[0],
              y: y + p2[1],
              z: z + p2[2]
            },
            v3 = {
              x: x + p3[0],
              y: y + p3[1],
              z: z + p3[2]
            },
            v4 = {
              x: x + p4[0],
              y: y + p4[1],
              z: z + p4[2]
            };
          context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, null, null) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
        });
      }
    }, {
      key: "draw",
      value: function draw(rect, renderService, drawContext) {
        var rectAttribute = getTheme(rect).rect;
        this._draw(rect, rectAttribute, !1, drawContext);
      }
    }]);
    return DefaultCanvasRect3dRender;
  }(BaseRender);
  DefaultCanvasRect3dRender = __decorate$13([injectable()], DefaultCanvasRect3dRender);

  var loadRect3dModule = !1;
  var rect3dModule = new ContainerModule(function (bind) {
    loadRect3dModule || (loadRect3dModule = !0, bind(Rect3DRender).to(DefaultCanvasRect3dRender).inSingletonScope(), bind(GraphicRender).toService(Rect3DRender));
  });

  var __decorate$12 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  function drawArcPath(arc, context, cx, cy, z, outerRadius, innerRadius) {
    var _arc$getParsedAngle = arc.getParsedAngle(),
      startAngle = _arc$getParsedAngle.startAngle,
      endAngle = _arc$getParsedAngle.endAngle,
      deltaAngle = abs(endAngle - startAngle),
      clockwise = endAngle > startAngle;
    var collapsedToLine = !1;
    if (outerRadius < innerRadius) {
      var temp = outerRadius;
      outerRadius = innerRadius, innerRadius = temp;
    }
    if (outerRadius <= epsilon) context.moveTo(cx, cy, z);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z));else {
      var _arc$getParsePadAngle = arc.getParsePadAngle(startAngle, endAngle),
        outerDeltaAngle = _arc$getParsePadAngle.outerDeltaAngle,
        innerDeltaAngle = _arc$getParsePadAngle.innerDeltaAngle,
        outerStartAngle = _arc$getParsePadAngle.outerStartAngle,
        outerEndAngle = _arc$getParsePadAngle.outerEndAngle,
        innerEndAngle = _arc$getParsePadAngle.innerEndAngle,
        innerStartAngle = _arc$getParsePadAngle.innerStartAngle,
        xors = outerRadius * cos(outerStartAngle),
        yors = outerRadius * sin(outerStartAngle),
        xire = innerRadius * cos(innerEndAngle),
        yire = innerRadius * sin(innerEndAngle);
      outerDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), !(innerRadius > epsilon) || innerDeltaAngle < .001 ? (context.lineTo(cx + xire, cy + yire, z), collapsedToLine = !0) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));
    }
    return context.closePath(), collapsedToLine;
  }
  function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
    var _arc$getParsedAngle2 = arc.getParsedAngle(),
      startAngle = _arc$getParsedAngle2.startAngle,
      endAngle = _arc$getParsedAngle2.endAngle,
      deltaAngle = abs(endAngle - startAngle),
      clockwise = endAngle > startAngle;
    var collapsedToLine = !1;
    if (radius <= epsilon) context.moveTo(cx, cy, z1);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2), context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2);else {
      var _getParsePadAngle = getParsePadAngle(startAngle, endAngle),
        innerouterDeltaAngle = _getParsePadAngle.innerouterDeltaAngle,
        innerouterStartAngle = _getParsePadAngle.innerouterStartAngle,
        innerouterEndAngle = _getParsePadAngle.innerouterEndAngle,
        xors = radius * cos(innerouterStartAngle),
        yors = radius * sin(innerouterStartAngle),
        xore = radius * cos(innerouterEndAngle),
        yore = radius * sin(innerouterEndAngle);
      innerouterDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z1), context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
    }
    return context.closePath(), collapsedToLine;
  }
  var DefaultCanvasArc3DRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasArc3DRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasArc3DRender);
    function DefaultCanvasArc3DRender() {
      var _this;
      _classCallCheck(this, DefaultCanvasArc3DRender);
      _this = _super.apply(this, arguments), _this.numberType = ARC3D_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasArc3DRender, [{
      key: "drawShape",
      value: function drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        var arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc,
          _arc$attribute$fill = arc.attribute.fill,
          fill = _arc$attribute$fill === void 0 ? arcAttribute.fill : _arc$attribute$fill,
          data = this.valid(arc, arcAttribute, fillCb, strokeCb);
        if (!data) return;
        var fVisible = data.fVisible,
          sVisible = data.sVisible,
          doFill = data.doFill,
          doStroke = data.doStroke,
          z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
          _arc$attribute = arc.attribute,
          _arc$attribute$outerP = _arc$attribute.outerPadding,
          outerPadding = _arc$attribute$outerP === void 0 ? arcAttribute.outerPadding : _arc$attribute$outerP,
          _arc$attribute$innerP = _arc$attribute.innerPadding,
          innerPadding = _arc$attribute$innerP === void 0 ? arcAttribute.innerPadding : _arc$attribute$innerP,
          _arc$attribute$height = _arc$attribute.height,
          height = _arc$attribute$height === void 0 ? 10 : _arc$attribute$height;
        var _arc$attribute2 = arc.attribute,
          _arc$attribute2$outer = _arc$attribute2.outerRadius,
          outerRadius = _arc$attribute2$outer === void 0 ? arcAttribute.outerRadius : _arc$attribute2$outer,
          _arc$attribute2$inner = _arc$attribute2.innerRadius,
          innerRadius = _arc$attribute2$inner === void 0 ? arcAttribute.innerRadius : _arc$attribute2$inner;
        outerRadius += outerPadding, innerRadius -= innerPadding;
        var rgbArray = ColorStore.Get(fill, exports.ColorType.Color255),
          _ref = drawContext.stage || {},
          light = _ref.light,
          face = drawContext.hack_pieFace,
          z_face = {
            top: z,
            bottom: z + height
          },
          n_face = {
            top: [0, 1, 0],
            bottom: [0, -1, 0],
            outside: [1, 0, -1],
            inside: [1, 0, -1]
          };
        "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath(arc, context, x, y, z_face[face], outerRadius, innerRadius), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), context.beginPath(), context.arc(x, y, innerRadius, 0, pi2, !0, z_face.top), context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, function (startAngle, endAngle) {
          var _arc$getParsePadAngle2 = arc.getParsePadAngle(startAngle, endAngle),
            outerDeltaAngle = _arc$getParsePadAngle2.outerDeltaAngle,
            innerDeltaAngle = _arc$getParsePadAngle2.innerDeltaAngle,
            outerStartAngle = _arc$getParsePadAngle2.outerStartAngle,
            outerEndAngle = _arc$getParsePadAngle2.outerEndAngle,
            innerEndAngle = _arc$getParsePadAngle2.innerEndAngle,
            innerStartAngle = _arc$getParsePadAngle2.innerStartAngle;
          return "outside" === face ? {
            innerouterDeltaAngle: outerDeltaAngle,
            innerouterEndAngle: outerEndAngle,
            innerouterStartAngle: outerStartAngle
          } : {
            innerouterDeltaAngle: innerDeltaAngle,
            innerouterEndAngle: innerEndAngle,
            innerouterStartAngle: innerStartAngle
          };
        }), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke())), "inside" === face && context.restore());
      }
    }, {
      key: "draw",
      value: function draw(arc, renderService, drawContext, params) {
        var arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc;
        this._draw(arc, arcAttribute, !1, drawContext, params);
      }
    }]);
    return DefaultCanvasArc3DRender;
  }(BaseRender);
  DefaultCanvasArc3DRender = __decorate$12([injectable()], DefaultCanvasArc3DRender);

  var loadArc3dModule = !1;
  var arc3dModule = new ContainerModule(function (bind) {
    loadArc3dModule || (loadArc3dModule = !0, bind(Arc3dRender).to(DefaultCanvasArc3DRender).inSingletonScope(), bind(GraphicRender).toService(Arc3dRender));
  });

  var __decorate$11 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultCanvasPyramid3dRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(DefaultCanvasPyramid3dRender, _BaseRender);
    var _super = _createSuper(DefaultCanvasPyramid3dRender);
    function DefaultCanvasPyramid3dRender() {
      var _this;
      _classCallCheck(this, DefaultCanvasPyramid3dRender);
      _this = _super.apply(this, arguments), _this.type = "pyramid3d", _this.numberType = PYRAMID3D_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasPyramid3dRender, [{
      key: "drawShape",
      value: function drawShape(pyramid3d, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        var pyramidAttribute = getTheme(pyramid3d, null == params ? void 0 : params.theme).polygon,
          _pyramid3d$attribute = pyramid3d.attribute,
          _pyramid3d$attribute$ = _pyramid3d$attribute.fill,
          fill = _pyramid3d$attribute$ === void 0 ? pyramidAttribute.fill : _pyramid3d$attribute$,
          _pyramid3d$attribute$2 = _pyramid3d$attribute.stroke,
          stroke = _pyramid3d$attribute$2 === void 0 ? pyramidAttribute.stroke : _pyramid3d$attribute$2,
          _pyramid3d$attribute$3 = _pyramid3d$attribute.face,
          face = _pyramid3d$attribute$3 === void 0 ? [!0, !0, !0, !0, !0, !0] : _pyramid3d$attribute$3,
          z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
        if (!this.valid(pyramid3d, pyramidAttribute, fillCb, strokeCb)) return;
        var _ref = drawContext.stage || {},
          light = _ref.light,
          camera = _ref.camera,
          face3d = pyramid3d.findFace();
        if (!1 !== fill) {
          context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
          var fc = fill;
          "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, face, fc, context, light, camera, pyramid3d, pyramidAttribute, fillCb);
        }
        !1 !== stroke && (context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute), this.stroke(x, y, z, face3d, context));
      }
    }, {
      key: "stroke",
      value: function stroke(x, y, z, face3d, context) {
        var vertices = face3d.vertices;
        face3d.edges.forEach(function (p) {
          var p1 = vertices[p[0]],
            p2 = vertices[p[1]],
            v1 = {
              x: x + p1[0],
              y: y + p1[1],
              z: z + p1[2]
            },
            v2 = {
              x: x + p2[0],
              y: y + p2[1],
              z: z + p2[2]
            };
          context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
        });
      }
    }, {
      key: "fill",
      value: function fill(x, y, z, face3d, faces, fillColor, context, light, camera, pyramid3d, pyramid3dAttribute, fillCb) {
        var rgbArray = ColorStore.Get(fillColor, exports.ColorType.Color255),
          vertices = face3d.vertices,
          viewdVerticesZ = vertices.map(function (v) {
            return context.view(v[0], v[1], v[2])[2];
          }),
          sortFace = [];
        face3d.polygons.forEach(function (p, i) {
          if (!faces[i]) return;
          sortFace.push({
            faceIdx: i,
            polygon: p
          });
          var polygon = p.polygon;
            p.normal;
            var z1 = viewdVerticesZ[polygon[0]],
            z2 = viewdVerticesZ[polygon[1]],
            z3 = viewdVerticesZ[polygon[2]],
            z4 = viewdVerticesZ[polygon[3]];
          p.ave_z = z1 + z2 + z3 + z4;
        }), sortFace.sort(function (a, b) {
          return b.polygon.ave_z - a.polygon.ave_z;
        }), sortFace.forEach(function (item) {
          var _item$polygon = item.polygon,
            polygon = _item$polygon.polygon,
            normal = _item$polygon.normal,
            p1 = vertices[polygon[0]],
            p2 = vertices[polygon[1]],
            p3 = vertices[polygon[2]],
            p4 = vertices[polygon[3]],
            v1 = {
              x: x + p1[0],
              y: y + p1[1],
              z: z + p1[2]
            },
            v2 = {
              x: x + p2[0],
              y: y + p2[1],
              z: z + p2[2]
            },
            v3 = {
              x: x + p3[0],
              y: y + p3[1],
              z: z + p3[2]
            },
            v4 = {
              x: x + p4[0],
              y: y + p4[1],
              z: z + p4[2]
            };
          context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, pyramid3d.attribute, pyramid3dAttribute) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
        });
      }
    }, {
      key: "draw",
      value: function draw(pyramid3d, renderService, drawContext) {
        var pyramid3dAttribute = getTheme(pyramid3d).polygon;
        this._draw(pyramid3d, pyramid3dAttribute, !1, drawContext);
      }
    }]);
    return DefaultCanvasPyramid3dRender;
  }(BaseRender);
  DefaultCanvasPyramid3dRender = __decorate$11([injectable()], DefaultCanvasPyramid3dRender);

  var loadPyramid3dModule = !1;
  var pyramid3dModule = new ContainerModule(function (bind) {
    loadPyramid3dModule || (loadPyramid3dModule = !0, bind(Pyramid3dRender).to(DefaultCanvasPyramid3dRender).inSingletonScope(), bind(GraphicRender).toService(Pyramid3dRender));
  });

  function registerArcGraphic() {
    graphicCreator.RegisterGraphicCreator("arc", createArc);
  }

  function registerArc3dGraphic() {
    graphicCreator.RegisterGraphicCreator("arc3d", createArc3d);
  }

  function registerAreaGraphic() {
    graphicCreator.RegisterGraphicCreator("area", createArea);
  }

  function registerCircleGraphic() {
    graphicCreator.RegisterGraphicCreator("circle", createCircle);
  }

  function registerGlyphGraphic() {
    graphicCreator.RegisterGraphicCreator("glyph", createGlyph);
  }

  function registerGroupGraphic() {
    graphicCreator.RegisterGraphicCreator("group", createGroup);
  }

  function registerImageGraphic() {
    graphicCreator.RegisterGraphicCreator("image", createImage);
  }

  function registerLineGraphic() {
    graphicCreator.RegisterGraphicCreator("line", createLine);
  }

  function registerPathGraphic() {
    graphicCreator.RegisterGraphicCreator("path", createPath);
  }

  function registerPolygonGraphic() {
    graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
  }

  function registerPyramid3dGraphic() {
    graphicCreator.RegisterGraphicCreator("pyramid3d", createPyramid3d);
  }

  function registerRectGraphic() {
    graphicCreator.RegisterGraphicCreator("rect", createRect);
  }

  function registerRect3dGraphic() {
    graphicCreator.RegisterGraphicCreator("rect3d", createRect3d);
  }

  function registerRichtextGraphic() {
    graphicCreator.RegisterGraphicCreator("richtext", createRichText);
  }

  function registerSymbolGraphic() {
    graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
  }

  function registerTextGraphic() {
    graphicCreator.RegisterGraphicCreator("text", createText);
  }

  function registerShadowRootGraphic() {
    graphicCreator.RegisterGraphicCreator("shadowRoot", createShadowRoot);
  }

  function registerWrapTextGraphic() {
    graphicCreator.RegisterGraphicCreator("wrapText", createWrapText);
  }

  function t(t, e, s) {
    if (t && t.length) {
      var _e = _slicedToArray(e, 2),
        _n = _e[0],
        _a = _e[1],
        _o = Math.PI / 180 * s,
        _h = Math.cos(_o),
        _r = Math.sin(_o);
      t.forEach(function (t) {
        var _t = _slicedToArray(t, 2),
          e = _t[0],
          s = _t[1];
        t[0] = (e - _n) * _h - (s - _a) * _r + _n, t[1] = (e - _n) * _r + (s - _a) * _h + _a;
      });
    }
  }
  function e(t) {
    var e = t[0],
      s = t[1];
    return Math.sqrt(Math.pow(e[0] - s[0], 2) + Math.pow(e[1] - s[1], 2));
  }
  function s(e, s) {
    var n = s.hachureAngle + 90;
    var a = s.hachureGap;
    a < 0 && (a = 4 * s.strokeWidth), a = Math.max(a, .1);
    var o = [0, 0];
    if (n) {
      var _iterator = _createForOfIteratorHelper(e),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _s = _step.value;
          t(_s, o, n);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    var h = function (t, e) {
      var s = [];
      var _iterator2 = _createForOfIteratorHelper(t),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _e5 = _step2.value;
          var _t6 = _toConsumableArray(_e5);
          _t6[0].join(",") !== _t6[_t6.length - 1].join(",") && _t6.push([_t6[0][0], _t6[0][1]]), _t6.length > 2 && s.push(_t6);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var n = [];
      e = Math.max(e, .1);
      var a = [];
      for (var _i = 0, _s2 = s; _i < _s2.length; _i++) {
        var _t2 = _s2[_i];
        for (var _e2 = 0; _e2 < _t2.length - 1; _e2++) {
          var _s3 = _t2[_e2],
            _n2 = _t2[_e2 + 1];
          if (_s3[1] !== _n2[1]) {
            var _t3 = Math.min(_s3[1], _n2[1]);
            a.push({
              ymin: _t3,
              ymax: Math.max(_s3[1], _n2[1]),
              x: _t3 === _s3[1] ? _s3[0] : _n2[0],
              islope: (_n2[0] - _s3[0]) / (_n2[1] - _s3[1])
            });
          }
        }
      }
      if (a.sort(function (t, e) {
        return t.ymin < e.ymin ? -1 : t.ymin > e.ymin ? 1 : t.x < e.x ? -1 : t.x > e.x ? 1 : t.ymax === e.ymax ? 0 : (t.ymax - e.ymax) / Math.abs(t.ymax - e.ymax);
      }), !a.length) return n;
      var o = [],
        h = a[0].ymin;
      for (; o.length || a.length;) {
        if (a.length) {
          var _t4 = -1;
          for (var _e3 = 0; _e3 < a.length && !(a[_e3].ymin > h); _e3++) _t4 = _e3;
          a.splice(0, _t4 + 1).forEach(function (t) {
            o.push({
              s: h,
              edge: t
            });
          });
        }
        if (o = o.filter(function (t) {
          return !(t.edge.ymax <= h);
        }), o.sort(function (t, e) {
          return t.edge.x === e.edge.x ? 0 : (t.edge.x - e.edge.x) / Math.abs(t.edge.x - e.edge.x);
        }), o.length > 1) for (var _t5 = 0; _t5 < o.length; _t5 += 2) {
          var _e4 = _t5 + 1;
          if (_e4 >= o.length) break;
          var _s4 = o[_t5].edge,
            _a2 = o[_e4].edge;
          n.push([[Math.round(_s4.x), h], [Math.round(_a2.x), h]]);
        }
        h += e, o.forEach(function (t) {
          t.edge.x = t.edge.x + e * t.edge.islope;
        });
      }
      return n;
    }(e, a);
    if (n) {
      var _iterator3 = _createForOfIteratorHelper(e),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _s5 = _step3.value;
          t(_s5, o, -n);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      !function (e, s, n) {
        var a = [];
        e.forEach(function (t) {
          return a.push.apply(a, _toConsumableArray(t));
        }), t(a, s, n);
      }(h, o, -n);
    }
    return h;
  }
  var n = /*#__PURE__*/function () {
    function n(t) {
      _classCallCheck(this, n);
      this.helper = t;
    }
    _createClass(n, [{
      key: "fillPolygons",
      value: function fillPolygons(t, e) {
        return this._fillPolygons(t, e);
      }
    }, {
      key: "_fillPolygons",
      value: function _fillPolygons(t, e) {
        var _n3 = s(t, e);
        return {
          type: "fillSketch",
          ops: this.renderLines(_n3, e)
        };
      }
    }, {
      key: "renderLines",
      value: function renderLines(t, e) {
        var s = [];
        var _iterator4 = _createForOfIteratorHelper(t),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _n4 = _step4.value;
            s.push.apply(s, _toConsumableArray(this.helper.doubleLineOps(_n4[0][0], _n4[0][1], _n4[1][0], _n4[1][1], e)));
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        return s;
      }
    }]);
    return n;
  }();
  var a = /*#__PURE__*/function (_n5) {
    _inherits(a, _n5);
    var _super = _createSuper(a);
    function a() {
      _classCallCheck(this, a);
      return _super.apply(this, arguments);
    }
    _createClass(a, [{
      key: "fillPolygons",
      value: function fillPolygons(t, n) {
        var _a3 = n.hachureGap;
        _a3 < 0 && (_a3 = 4 * n.strokeWidth), _a3 = Math.max(_a3, .1);
        var o = s(t, Object.assign({}, n, {
            hachureGap: _a3
          })),
          h = Math.PI / 180 * n.hachureAngle,
          r = [],
          i = .5 * _a3 * Math.cos(h),
          c = .5 * _a3 * Math.sin(h);
        var _iterator5 = _createForOfIteratorHelper(o),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
              _t7 = _step5$value[0],
              _s6 = _step5$value[1];
            e([_t7, _s6]) && r.push([[_t7[0] - i, _t7[1] + c], _toConsumableArray(_s6)], [[_t7[0] + i, _t7[1] - c], _toConsumableArray(_s6)]);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        return {
          type: "fillSketch",
          ops: this.renderLines(r, n)
        };
      }
    }]);
    return a;
  }(n);
  var o = /*#__PURE__*/function (_n6) {
    _inherits(o, _n6);
    var _super2 = _createSuper(o);
    function o() {
      _classCallCheck(this, o);
      return _super2.apply(this, arguments);
    }
    _createClass(o, [{
      key: "fillPolygons",
      value: function fillPolygons(t, e) {
        var s = this._fillPolygons(t, e),
          n = Object.assign({}, e, {
            hachureAngle: e.hachureAngle + 90
          }),
          a = this._fillPolygons(t, n);
        return s.ops = s.ops.concat(a.ops), s;
      }
    }]);
    return o;
  }(n);
  var h = /*#__PURE__*/function () {
    function h(t) {
      _classCallCheck(this, h);
      this.helper = t;
    }
    _createClass(h, [{
      key: "fillPolygons",
      value: function fillPolygons(t, e) {
        var n = s(t, e = Object.assign({}, e, {
          hachureAngle: 0
        }));
        return this.dotsOnLines(n, e);
      }
    }, {
      key: "dotsOnLines",
      value: function dotsOnLines(t, s) {
        var n = [];
        var a = s.hachureGap;
        a < 0 && (a = 4 * s.strokeWidth), a = Math.max(a, .1);
        var o = s.fillWeight;
        o < 0 && (o = s.strokeWidth / 2);
        var _h2 = a / 4;
        var _iterator6 = _createForOfIteratorHelper(t),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _r2 = _step6.value;
            var _t8 = e(_r2),
              _i2 = _t8 / a,
              _c = Math.ceil(_i2) - 1,
              _l = _t8 - _c * a,
              _u = (_r2[0][0] + _r2[1][0]) / 2 - a / 4,
              _p = Math.min(_r2[0][1], _r2[1][1]);
            for (var _t9 = 0; _t9 < _c; _t9++) {
              var _e6 = _p + _l + _t9 * a,
                _r3 = _u - _h2 + 2 * Math.random() * _h2,
                _i3 = _e6 - _h2 + 2 * Math.random() * _h2,
                _c2 = this.helper.ellipse(_r3, _i3, o, o, s);
              n.push.apply(n, _toConsumableArray(_c2.ops));
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        return {
          type: "fillSketch",
          ops: n
        };
      }
    }]);
    return h;
  }();
  var r = /*#__PURE__*/function () {
    function r(t) {
      _classCallCheck(this, r);
      this.helper = t;
    }
    _createClass(r, [{
      key: "fillPolygons",
      value: function fillPolygons(t, e) {
        var n = s(t, e);
        return {
          type: "fillSketch",
          ops: this.dashedLine(n, e)
        };
      }
    }, {
      key: "dashedLine",
      value: function dashedLine(t, s) {
        var _this = this;
        var n = s.dashOffset < 0 ? s.hachureGap < 0 ? 4 * s.strokeWidth : s.hachureGap : s.dashOffset,
          a = s.dashGap < 0 ? s.hachureGap < 0 ? 4 * s.strokeWidth : s.hachureGap : s.dashGap,
          o = [];
        return t.forEach(function (t) {
          var h = e(t),
            _r4 = Math.floor(h / (n + a)),
            i = (h + a - _r4 * (n + a)) / 2;
          var c = t[0],
            l = t[1];
          c[0] > l[0] && (c = t[1], l = t[0]);
          var u = Math.atan((l[1] - c[1]) / (l[0] - c[0]));
          for (var _t10 = 0; _t10 < _r4; _t10++) {
            var _e7 = _t10 * (n + a),
              _h3 = _e7 + n,
              _r5 = [c[0] + _e7 * Math.cos(u) + i * Math.cos(u), c[1] + _e7 * Math.sin(u) + i * Math.sin(u)],
              _l2 = [c[0] + _h3 * Math.cos(u) + i * Math.cos(u), c[1] + _h3 * Math.sin(u) + i * Math.sin(u)];
            o.push.apply(o, _toConsumableArray(_this.helper.doubleLineOps(_r5[0], _r5[1], _l2[0], _l2[1], s)));
          }
        }), o;
      }
    }]);
    return r;
  }();
  var i = /*#__PURE__*/function () {
    function i(t) {
      _classCallCheck(this, i);
      this.helper = t;
    }
    _createClass(i, [{
      key: "fillPolygons",
      value: function fillPolygons(t, e) {
        var n = e.hachureGap < 0 ? 4 * e.strokeWidth : e.hachureGap,
          a = e.zigzagOffset < 0 ? n : e.zigzagOffset,
          o = s(t, e = Object.assign({}, e, {
            hachureGap: n + a
          }));
        return {
          type: "fillSketch",
          ops: this.zigzagLines(o, a, e)
        };
      }
    }, {
      key: "zigzagLines",
      value: function zigzagLines(t, s, n) {
        var _this2 = this;
        var a = [];
        return t.forEach(function (t) {
          var o = e(t),
            h = Math.round(o / (2 * s));
          var r = t[0],
            _i4 = t[1];
          r[0] > _i4[0] && (r = t[1], _i4 = t[0]);
          var c = Math.atan((_i4[1] - r[1]) / (_i4[0] - r[0]));
          for (var _t11 = 0; _t11 < h; _t11++) {
            var _e8 = 2 * _t11 * s,
              _o2 = 2 * (_t11 + 1) * s,
              _h4 = Math.sqrt(2 * Math.pow(s, 2)),
              _i5 = [r[0] + _e8 * Math.cos(c), r[1] + _e8 * Math.sin(c)],
              _l3 = [r[0] + _o2 * Math.cos(c), r[1] + _o2 * Math.sin(c)],
              _u2 = [_i5[0] + _h4 * Math.cos(c + Math.PI / 4), _i5[1] + _h4 * Math.sin(c + Math.PI / 4)];
            a.push.apply(a, _toConsumableArray(_this2.helper.doubleLineOps(_i5[0], _i5[1], _u2[0], _u2[1], n)).concat(_toConsumableArray(_this2.helper.doubleLineOps(_u2[0], _u2[1], _l3[0], _l3[1], n))));
          }
        }), a;
      }
    }]);
    return i;
  }();
  var c = {};
  var l = /*#__PURE__*/function () {
    function l(t) {
      _classCallCheck(this, l);
      this.seed = t;
    }
    _createClass(l, [{
      key: "next",
      value: function next() {
        return this.seed ? (Math.pow(2, 31) - 1 & (this.seed = Math.imul(48271, this.seed))) / Math.pow(2, 31) : Math.random();
      }
    }]);
    return l;
  }();
  var u = {
    A: 7,
    a: 7,
    C: 6,
    c: 6,
    H: 1,
    h: 1,
    L: 2,
    l: 2,
    M: 2,
    m: 2,
    Q: 4,
    q: 4,
    S: 4,
    s: 4,
    T: 2,
    t: 2,
    V: 1,
    v: 1,
    Z: 0,
    z: 0
  };
  function p(t, e) {
    return t.type === e;
  }
  function f(t) {
    var e = [],
      s = function (t) {
        var e = new Array();
        for (; "" !== t;) if (t.match(/^([ \t\r\n,]+)/)) t = t.substr(RegExp.$1.length);else if (t.match(/^([aAcChHlLmMqQsStTvVzZ])/)) e[e.length] = {
          type: 0,
          text: RegExp.$1
        }, t = t.substr(RegExp.$1.length);else {
          if (!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
          e[e.length] = {
            type: 1,
            text: "".concat(parseFloat(RegExp.$1))
          }, t = t.substr(RegExp.$1.length);
        }
        return e[e.length] = {
          type: 2,
          text: ""
        }, e;
      }(t);
    var n = "BOD",
      a = 0,
      o = s[a];
    for (; !p(o, 2);) {
      var _h5 = 0;
      var _r6 = [];
      if ("BOD" === n) {
        if ("M" !== o.text && "m" !== o.text) return f("M0,0" + t);
        a++, _h5 = u[o.text], n = o.text;
      } else p(o, 1) ? _h5 = u[n] : (a++, _h5 = u[o.text], n = o.text);
      if (!(a + _h5 < s.length)) throw new Error("Path data ended short");
      for (var _t12 = a; _t12 < a + _h5; _t12++) {
        var _e9 = s[_t12];
        if (!p(_e9, 1)) throw new Error("Param not a number: " + n + "," + _e9.text);
        _r6[_r6.length] = +_e9.text;
      }
      if ("number" != typeof u[n]) throw new Error("Bad segment: " + n);
      {
        var _t13 = {
          key: n,
          data: _r6
        };
        e.push(_t13), a += _h5, o = s[a], "M" === n && (n = "L"), "m" === n && (n = "l");
      }
    }
    return e;
  }
  function d(t) {
    var _r8, _r9, _r10;
    var e = 0,
      s = 0,
      n = 0,
      a = 0;
    var o = [];
    var _iterator7 = _createForOfIteratorHelper(t),
      _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var _step7$value = _step7.value,
          _h6 = _step7$value.key,
          _r7 = _step7$value.data;
        switch (_h6) {
          case "M":
            o.push({
              key: "M",
              data: _toConsumableArray(_r7)
            }), (_r8 = _slicedToArray(_r7, 2), e = _r8[0], s = _r8[1]), (_r9 = _slicedToArray(_r7, 2), n = _r9[0], a = _r9[1]);
            break;
          case "m":
            e += _r7[0], s += _r7[1], o.push({
              key: "M",
              data: [e, s]
            }), n = e, a = s;
            break;
          case "L":
            o.push({
              key: "L",
              data: _toConsumableArray(_r7)
            }), (_r10 = _slicedToArray(_r7, 2), e = _r10[0], s = _r10[1]);
            break;
          case "l":
            e += _r7[0], s += _r7[1], o.push({
              key: "L",
              data: [e, s]
            });
            break;
          case "C":
            o.push({
              key: "C",
              data: _toConsumableArray(_r7)
            }), e = _r7[4], s = _r7[5];
            break;
          case "c":
            {
              var _t14 = _r7.map(function (t, n) {
                return n % 2 ? t + s : t + e;
              });
              o.push({
                key: "C",
                data: _t14
              }), e = _t14[4], s = _t14[5];
              break;
            }
          case "Q":
            o.push({
              key: "Q",
              data: _toConsumableArray(_r7)
            }), e = _r7[2], s = _r7[3];
            break;
          case "q":
            {
              var _t15 = _r7.map(function (t, n) {
                return n % 2 ? t + s : t + e;
              });
              o.push({
                key: "Q",
                data: _t15
              }), e = _t15[2], s = _t15[3];
              break;
            }
          case "A":
            o.push({
              key: "A",
              data: _toConsumableArray(_r7)
            }), e = _r7[5], s = _r7[6];
            break;
          case "a":
            e += _r7[5], s += _r7[6], o.push({
              key: "A",
              data: [_r7[0], _r7[1], _r7[2], _r7[3], _r7[4], e, s]
            });
            break;
          case "H":
            o.push({
              key: "H",
              data: _toConsumableArray(_r7)
            }), e = _r7[0];
            break;
          case "h":
            e += _r7[0], o.push({
              key: "H",
              data: [e]
            });
            break;
          case "V":
            o.push({
              key: "V",
              data: _toConsumableArray(_r7)
            }), s = _r7[0];
            break;
          case "v":
            s += _r7[0], o.push({
              key: "V",
              data: [s]
            });
            break;
          case "S":
            o.push({
              key: "S",
              data: _toConsumableArray(_r7)
            }), e = _r7[2], s = _r7[3];
            break;
          case "s":
            {
              var _t16 = _r7.map(function (t, n) {
                return n % 2 ? t + s : t + e;
              });
              o.push({
                key: "S",
                data: _t16
              }), e = _t16[2], s = _t16[3];
              break;
            }
          case "T":
            o.push({
              key: "T",
              data: _toConsumableArray(_r7)
            }), e = _r7[0], s = _r7[1];
            break;
          case "t":
            e += _r7[0], s += _r7[1], o.push({
              key: "T",
              data: [e, s]
            });
            break;
          case "Z":
          case "z":
            o.push({
              key: "Z",
              data: []
            }), e = n, s = a;
        }
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
    return o;
  }
  function g(t) {
    var _l5, _l6, _l7;
    var e = [];
    var s = "",
      n = 0,
      a = 0,
      o = 0,
      h = 0,
      r = 0,
      i = 0;
    var _iterator8 = _createForOfIteratorHelper(t),
      _step8;
    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var _step8$value = _step8.value,
          _c3 = _step8$value.key,
          _l4 = _step8$value.data;
        switch (_c3) {
          case "M":
            e.push({
              key: "M",
              data: _toConsumableArray(_l4)
            }), (_l5 = _slicedToArray(_l4, 2), n = _l5[0], a = _l5[1]), (_l6 = _slicedToArray(_l4, 2), o = _l6[0], h = _l6[1]);
            break;
          case "C":
            e.push({
              key: "C",
              data: _toConsumableArray(_l4)
            }), n = _l4[4], a = _l4[5], r = _l4[2], i = _l4[3];
            break;
          case "L":
            e.push({
              key: "L",
              data: _toConsumableArray(_l4)
            }), (_l7 = _slicedToArray(_l4, 2), n = _l7[0], a = _l7[1]);
            break;
          case "H":
            n = _l4[0], e.push({
              key: "L",
              data: [n, a]
            });
            break;
          case "V":
            a = _l4[0], e.push({
              key: "L",
              data: [n, a]
            });
            break;
          case "S":
            {
              var _t17 = 0,
                _o3 = 0;
              "C" === s || "S" === s ? (_t17 = n + (n - r), _o3 = a + (a - i)) : (_t17 = n, _o3 = a), e.push({
                key: "C",
                data: [_t17, _o3].concat(_toConsumableArray(_l4))
              }), r = _l4[0], i = _l4[1], n = _l4[2], a = _l4[3];
              break;
            }
          case "T":
            {
              var _l8 = _slicedToArray(_l4, 2),
                _t18 = _l8[0],
                _o4 = _l8[1];
              var _h7 = 0,
                _c4 = 0;
              "Q" === s || "T" === s ? (_h7 = n + (n - r), _c4 = a + (a - i)) : (_h7 = n, _c4 = a);
              var _u3 = n + 2 * (_h7 - n) / 3,
                _p2 = a + 2 * (_c4 - a) / 3,
                _f = _t18 + 2 * (_h7 - _t18) / 3,
                _d = _o4 + 2 * (_c4 - _o4) / 3;
              e.push({
                key: "C",
                data: [_u3, _p2, _f, _d, _t18, _o4]
              }), r = _h7, i = _c4, n = _t18, a = _o4;
              break;
            }
          case "Q":
            {
              var _l9 = _slicedToArray(_l4, 4),
                _t19 = _l9[0],
                _s7 = _l9[1],
                _o5 = _l9[2],
                _h8 = _l9[3],
                _c5 = n + 2 * (_t19 - n) / 3,
                _u4 = a + 2 * (_s7 - a) / 3,
                _p3 = _o5 + 2 * (_t19 - _o5) / 3,
                _f2 = _h8 + 2 * (_s7 - _h8) / 3;
              e.push({
                key: "C",
                data: [_c5, _u4, _p3, _f2, _o5, _h8]
              }), r = _t19, i = _s7, n = _o5, a = _h8;
              break;
            }
          case "A":
            {
              var _t20 = Math.abs(_l4[0]),
                _s8 = Math.abs(_l4[1]),
                _o6 = _l4[2],
                _h9 = _l4[3],
                _r11 = _l4[4],
                _i6 = _l4[5],
                _c6 = _l4[6];
              if (0 === _t20 || 0 === _s8) e.push({
                key: "C",
                data: [n, a, _i6, _c6, _i6, _c6]
              }), n = _i6, a = _c6;else if (n !== _i6 || a !== _c6) {
                k(n, a, _i6, _c6, _t20, _s8, _o6, _h9, _r11).forEach(function (t) {
                  e.push({
                    key: "C",
                    data: t
                  });
                }), n = _i6, a = _c6;
              }
              break;
            }
          case "Z":
            e.push({
              key: "Z",
              data: []
            }), n = o, a = h;
        }
        s = _c3;
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }
    return e;
  }
  function M(t, e, s) {
    return [t * Math.cos(s) - e * Math.sin(s), t * Math.sin(s) + e * Math.cos(s)];
  }
  function k(t, e, s, n, a, o, h, r, i, c) {
    var l = (u = h, Math.PI * u / 180);
    var u;
    var p = [],
      f = 0,
      d = 0,
      g = 0,
      b = 0;
    if (c) {
      var _c7 = _slicedToArray(c, 4);
      f = _c7[0];
      d = _c7[1];
      g = _c7[2];
      b = _c7[3];
    } else {
      var _M, _M2, _M3, _M4;
      (_M = M(t, e, -l), _M2 = _slicedToArray(_M, 2), t = _M2[0], e = _M2[1]), (_M3 = M(s, n, -l), _M4 = _slicedToArray(_M3, 2), s = _M4[0], n = _M4[1]);
      var _h10 = (t - s) / 2,
        _c8 = (e - n) / 2;
      var _u5 = _h10 * _h10 / (a * a) + _c8 * _c8 / (o * o);
      _u5 > 1 && (_u5 = Math.sqrt(_u5), a *= _u5, o *= _u5);
      var _p4 = a * a,
        _k = o * o,
        _y = _p4 * _k - _p4 * _c8 * _c8 - _k * _h10 * _h10,
        _m = _p4 * _c8 * _c8 + _k * _h10 * _h10,
        _w = (r === i ? -1 : 1) * Math.sqrt(Math.abs(_y / _m));
      g = _w * a * _c8 / o + (t + s) / 2, b = _w * -o * _h10 / a + (e + n) / 2, f = Math.asin(parseFloat(((e - b) / o).toFixed(9))), d = Math.asin(parseFloat(((n - b) / o).toFixed(9))), t < g && (f = Math.PI - f), s < g && (d = Math.PI - d), f < 0 && (f = 2 * Math.PI + f), d < 0 && (d = 2 * Math.PI + d), i && f > d && (f -= 2 * Math.PI), !i && d > f && (d -= 2 * Math.PI);
    }
    var y = d - f;
    if (Math.abs(y) > 120 * Math.PI / 180) {
      var _t21 = d,
        _e10 = s,
        _r12 = n;
      d = i && d > f ? f + 120 * Math.PI / 180 * 1 : f + 120 * Math.PI / 180 * -1, p = k(s = g + a * Math.cos(d), n = b + o * Math.sin(d), _e10, _r12, a, o, h, 0, i, [d, _t21, g, b]);
    }
    y = d - f;
    var m = Math.cos(f),
      w = Math.sin(f),
      x = Math.cos(d),
      P = Math.sin(d),
      v = Math.tan(y / 4),
      O = 4 / 3 * a * v,
      S = 4 / 3 * o * v,
      L = [t, e],
      T = [t + O * w, e - S * m],
      D = [s + O * P, n - S * x],
      A = [s, n];
    if (T[0] = 2 * L[0] - T[0], T[1] = 2 * L[1] - T[1], c) return [T, D, A].concat(p);
    {
      p = [T, D, A].concat(p);
      var _t22 = [];
      for (var _e11 = 0; _e11 < p.length; _e11 += 3) {
        var _s9 = M(p[_e11][0], p[_e11][1], l),
          _n7 = M(p[_e11 + 1][0], p[_e11 + 1][1], l),
          _a4 = M(p[_e11 + 2][0], p[_e11 + 2][1], l);
        _t22.push([_s9[0], _s9[1], _n7[0], _n7[1], _a4[0], _a4[1]]);
      }
      return _t22;
    }
  }
  var b = {
    randOffset: function randOffset(t, e) {
      return A(t, e);
    },
    randOffsetWithRange: function randOffsetWithRange(t, e, s) {
      return D(t, e, s);
    },
    ellipse: function ellipse(t, e, s, n, a) {
      var o = P(s, n, a);
      return v(t, e, a, o).opset;
    },
    doubleLineOps: function doubleLineOps(t, e, s, n, a) {
      return I(t, e, s, n, a, !0);
    }
  };
  function y(t, e, s, n, a) {
    return {
      type: "path",
      ops: I(t, e, s, n, a)
    };
  }
  function m$2(t, e, s) {
    var n = (t || []).length;
    if (n > 2) {
      var _a5 = [];
      for (var _e12 = 0; _e12 < n - 1; _e12++) _a5.push.apply(_a5, _toConsumableArray(I(t[_e12][0], t[_e12][1], t[_e12 + 1][0], t[_e12 + 1][1], s)));
      return e && _a5.push.apply(_a5, _toConsumableArray(I(t[n - 1][0], t[n - 1][1], t[0][0], t[0][1], s))), {
        type: "path",
        ops: _a5
      };
    }
    return 2 === n ? y(t[0][0], t[0][1], t[1][0], t[1][1], s) : {
      type: "path",
      ops: []
    };
  }
  function w(t, e, s, n, a) {
    return function (t, e) {
      return m$2(t, !0, e);
    }([[t, e], [t + s, e], [t + s, e + n], [t, e + n]], a);
  }
  function x(t, e) {
    var s = _(t, 1 * (1 + .2 * e.roughness), e);
    if (!e.disableMultiStroke) {
      var _n8 = _(t, 1.5 * (1 + .22 * e.roughness), function (t) {
        var e = Object.assign({}, t);
        e.randomizer = void 0, t.seed && (e.seed = t.seed + 1);
        return e;
      }(e));
      s = s.concat(_n8);
    }
    return {
      type: "path",
      ops: s
    };
  }
  function P(t, e, s) {
    var n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t / 2, 2) + Math.pow(e / 2, 2)) / 2)),
      a = Math.ceil(Math.max(s.curveStepCount, s.curveStepCount / Math.sqrt(200) * n)),
      o = 2 * Math.PI / a;
    var h = Math.abs(t / 2),
      r = Math.abs(e / 2);
    var i = 1 - s.curveFitting;
    return h += A(h * i, s), r += A(r * i, s), {
      increment: o,
      rx: h,
      ry: r
    };
  }
  function v(t, e, s, n) {
    var _z = z(n.increment, t, e, n.rx, n.ry, 1, n.increment * D(.1, D(.4, 1, s), s), s),
      _z2 = _slicedToArray(_z, 2),
      a = _z2[0],
      o = _z2[1];
    var h = W(a, null, s);
    if (!s.disableMultiStroke && 0 !== s.roughness) {
      var _z3 = z(n.increment, t, e, n.rx, n.ry, 1.5, 0, s),
        _z4 = _slicedToArray(_z3, 1),
        _a6 = _z4[0],
        _o7 = W(_a6, null, s);
      h = h.concat(_o7);
    }
    return {
      estimatedPoints: o,
      opset: {
        type: "path",
        ops: h
      }
    };
  }
  function O(t, e, s, n, a, o, h, r, i) {
    var c = t,
      l = e;
    var u = Math.abs(s / 2),
      p = Math.abs(n / 2);
    u += A(.01 * u, i), p += A(.01 * p, i);
    var f = a,
      d = o;
    for (; f < 0;) f += 2 * Math.PI, d += 2 * Math.PI;
    d - f > 2 * Math.PI && (f = 0, d = 2 * Math.PI);
    var g = 2 * Math.PI / i.curveStepCount,
      M = Math.min(g / 2, (d - f) / 2),
      k = E(M, c, l, u, p, f, d, 1, i);
    if (!i.disableMultiStroke) {
      var _t23 = E(M, c, l, u, p, f, d, 1.5, i);
      k.push.apply(k, _toConsumableArray(_t23));
    }
    return h && (r ? k.push.apply(k, _toConsumableArray(I(c, l, c + u * Math.cos(f), l + p * Math.sin(f), i)).concat(_toConsumableArray(I(c, l, c + u * Math.cos(d), l + p * Math.sin(d), i)))) : k.push({
      op: "lineTo",
      data: [c, l]
    }, {
      op: "lineTo",
      data: [c + u * Math.cos(f), l + p * Math.sin(f)]
    })), {
      type: "path",
      ops: k
    };
  }
  function S(t, e) {
    var s = [];
    var _iterator9 = _createForOfIteratorHelper(t),
      _step9;
    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var _n9 = _step9.value;
        if (_n9.length) {
          var _t24 = e.maxRandomnessOffset || 0,
            _a7 = _n9.length;
          if (_a7 > 2) {
            s.push({
              op: "move",
              data: [_n9[0][0] + A(_t24, e), _n9[0][1] + A(_t24, e)]
            });
            for (var _o8 = 1; _o8 < _a7; _o8++) s.push({
              op: "lineTo",
              data: [_n9[_o8][0] + A(_t24, e), _n9[_o8][1] + A(_t24, e)]
            });
          }
        }
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }
    return {
      type: "fillPath",
      ops: s
    };
  }
  function L(t, e) {
    return function (t, e) {
      var s = t.fillStyle || "hachure";
      if (!c[s]) switch (s) {
        case "zigzag":
          c[s] || (c[s] = new a(e));
          break;
        case "cross-hatch":
          c[s] || (c[s] = new o(e));
          break;
        case "dots":
          c[s] || (c[s] = new h(e));
          break;
        case "dashed":
          c[s] || (c[s] = new r(e));
          break;
        case "zigzag-line":
          c[s] || (c[s] = new i(e));
          break;
        case "hachure":
        default:
          s = "hachure", c[s] || (c[s] = new n(e));
      }
      return c[s];
    }(e, b).fillPolygons(t, e);
  }
  function T(t) {
    return t.randomizer || (t.randomizer = new l(t.seed || 0)), t.randomizer.next();
  }
  function D(t, e, s) {
    var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    return s.roughness * n * (T(s) * (e - t) + t);
  }
  function A(t, e) {
    var s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return D(-t, t, e, s);
  }
  function I(t, e, s, n, a) {
    var o = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
    var h = o ? a.disableMultiStrokeFill : a.disableMultiStroke,
      r = C(t, e, s, n, a, !0, !1);
    if (h) return r;
    var i = C(t, e, s, n, a, !0, !0);
    return r.concat(i);
  }
  function C(t, e, s, n, a, o, h) {
    var r = Math.pow(t - s, 2) + Math.pow(e - n, 2),
      i = Math.sqrt(r);
    var c = 1;
    c = i < 200 ? 1 : i > 500 ? .4 : -.0016668 * i + 1.233334;
    var l = a.maxRandomnessOffset || 0;
    l * l * 100 > r && (l = i / 10);
    var u = l / 2,
      p = .2 + .2 * T(a);
    var f = a.bowing * a.maxRandomnessOffset * (n - e) / 200,
      d = a.bowing * a.maxRandomnessOffset * (t - s) / 200;
    f = A(f, a, c), d = A(d, a, c);
    var g = [],
      M = function M() {
        return A(u, a, c);
      },
      k = function k() {
        return A(l, a, c);
      },
      b = a.preserveVertices;
    return o && (h ? g.push({
      op: "move",
      data: [t + (b ? 0 : M()), e + (b ? 0 : M())]
    }) : g.push({
      op: "move",
      data: [t + (b ? 0 : A(l, a, c)), e + (b ? 0 : A(l, a, c))]
    })), h ? g.push({
      op: "bcurveTo",
      data: [f + t + (s - t) * p + M(), d + e + (n - e) * p + M(), f + t + 2 * (s - t) * p + M(), d + e + 2 * (n - e) * p + M(), s + (b ? 0 : M()), n + (b ? 0 : M())]
    }) : g.push({
      op: "bcurveTo",
      data: [f + t + (s - t) * p + k(), d + e + (n - e) * p + k(), f + t + 2 * (s - t) * p + k(), d + e + 2 * (n - e) * p + k(), s + (b ? 0 : k()), n + (b ? 0 : k())]
    }), g;
  }
  function _(t, e, s) {
    var n = [];
    n.push([t[0][0] + A(e, s), t[0][1] + A(e, s)]), n.push([t[0][0] + A(e, s), t[0][1] + A(e, s)]);
    for (var _a8 = 1; _a8 < t.length; _a8++) n.push([t[_a8][0] + A(e, s), t[_a8][1] + A(e, s)]), _a8 === t.length - 1 && n.push([t[_a8][0] + A(e, s), t[_a8][1] + A(e, s)]);
    return W(n, null, s);
  }
  function W(t, e, s) {
    var n = t.length,
      a = [];
    if (n > 3) {
      var _o9 = [],
        _h11 = 1 - s.curveTightness;
      a.push({
        op: "move",
        data: [t[1][0], t[1][1]]
      });
      for (var _e13 = 1; _e13 + 2 < n; _e13++) {
        var _s10 = t[_e13];
        _o9[0] = [_s10[0], _s10[1]], _o9[1] = [_s10[0] + (_h11 * t[_e13 + 1][0] - _h11 * t[_e13 - 1][0]) / 6, _s10[1] + (_h11 * t[_e13 + 1][1] - _h11 * t[_e13 - 1][1]) / 6], _o9[2] = [t[_e13 + 1][0] + (_h11 * t[_e13][0] - _h11 * t[_e13 + 2][0]) / 6, t[_e13 + 1][1] + (_h11 * t[_e13][1] - _h11 * t[_e13 + 2][1]) / 6], _o9[3] = [t[_e13 + 1][0], t[_e13 + 1][1]], a.push({
          op: "bcurveTo",
          data: [_o9[1][0], _o9[1][1], _o9[2][0], _o9[2][1], _o9[3][0], _o9[3][1]]
        });
      }
      if (e && 2 === e.length) {
        var _t25 = s.maxRandomnessOffset;
        a.push({
          op: "lineTo",
          data: [e[0] + A(_t25, s), e[1] + A(_t25, s)]
        });
      }
    } else 3 === n ? (a.push({
      op: "move",
      data: [t[1][0], t[1][1]]
    }), a.push({
      op: "bcurveTo",
      data: [t[1][0], t[1][1], t[2][0], t[2][1], t[2][0], t[2][1]]
    })) : 2 === n && a.push.apply(a, _toConsumableArray(I(t[0][0], t[0][1], t[1][0], t[1][1], s)));
    return a;
  }
  function z(t, e, s, n, a, o, h, r) {
    var i = [],
      c = [];
    if (0 === r.roughness) {
      t /= 4, c.push([e + n * Math.cos(-t), s + a * Math.sin(-t)]);
      for (var _o10 = 0; _o10 <= 2 * Math.PI; _o10 += t) {
        var _t26 = [e + n * Math.cos(_o10), s + a * Math.sin(_o10)];
        i.push(_t26), c.push(_t26);
      }
      c.push([e + n * Math.cos(0), s + a * Math.sin(0)]), c.push([e + n * Math.cos(t), s + a * Math.sin(t)]);
    } else {
      var _l10 = A(.5, r) - Math.PI / 2;
      c.push([A(o, r) + e + .9 * n * Math.cos(_l10 - t), A(o, r) + s + .9 * a * Math.sin(_l10 - t)]);
      var _u6 = 2 * Math.PI + _l10 - .01;
      for (var _h12 = _l10; _h12 < _u6; _h12 += t) {
        var _t27 = [A(o, r) + e + n * Math.cos(_h12), A(o, r) + s + a * Math.sin(_h12)];
        i.push(_t27), c.push(_t27);
      }
      c.push([A(o, r) + e + n * Math.cos(_l10 + 2 * Math.PI + .5 * h), A(o, r) + s + a * Math.sin(_l10 + 2 * Math.PI + .5 * h)]), c.push([A(o, r) + e + .98 * n * Math.cos(_l10 + h), A(o, r) + s + .98 * a * Math.sin(_l10 + h)]), c.push([A(o, r) + e + .9 * n * Math.cos(_l10 + .5 * h), A(o, r) + s + .9 * a * Math.sin(_l10 + .5 * h)]);
    }
    return [c, i];
  }
  function E(t, e, s, n, a, o, h, r, i) {
    var c = o + A(.1, i),
      l = [];
    l.push([A(r, i) + e + .9 * n * Math.cos(c - t), A(r, i) + s + .9 * a * Math.sin(c - t)]);
    for (var _o11 = c; _o11 <= h; _o11 += t) l.push([A(r, i) + e + n * Math.cos(_o11), A(r, i) + s + a * Math.sin(_o11)]);
    return l.push([e + n * Math.cos(h), s + a * Math.sin(h)]), l.push([e + n * Math.cos(h), s + a * Math.sin(h)]), W(l, null, i);
  }
  function $(t, e, s, n, a, o, h, r) {
    var i = [],
      c = [r.maxRandomnessOffset || 1, (r.maxRandomnessOffset || 1) + .3];
    var l = [0, 0];
    var u = r.disableMultiStroke ? 1 : 2,
      p = r.preserveVertices;
    for (var _f3 = 0; _f3 < u; _f3++) 0 === _f3 ? i.push({
      op: "move",
      data: [h[0], h[1]]
    }) : i.push({
      op: "move",
      data: [h[0] + (p ? 0 : A(c[0], r)), h[1] + (p ? 0 : A(c[0], r))]
    }), l = p ? [a, o] : [a + A(c[_f3], r), o + A(c[_f3], r)], i.push({
      op: "bcurveTo",
      data: [t + A(c[_f3], r), e + A(c[_f3], r), s + A(c[_f3], r), n + A(c[_f3], r), l[0], l[1]]
    });
    return i;
  }
  function G(t) {
    return _toConsumableArray(t);
  }
  function R(t, e) {
    return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
  }
  function q(t, e, s) {
    var n = R(e, s);
    if (0 === n) return R(t, e);
    var a = ((t[0] - e[0]) * (s[0] - e[0]) + (t[1] - e[1]) * (s[1] - e[1])) / n;
    return a = Math.max(0, Math.min(1, a)), R(t, j(e, s, a));
  }
  function j(t, e, s) {
    return [t[0] + (e[0] - t[0]) * s, t[1] + (e[1] - t[1]) * s];
  }
  function F(t, e, s, n) {
    var a = n || [];
    if (function (t, e) {
      var s = t[e + 0],
        n = t[e + 1],
        a = t[e + 2],
        o = t[e + 3];
      var h = 3 * n[0] - 2 * s[0] - o[0];
      h *= h;
      var r = 3 * n[1] - 2 * s[1] - o[1];
      r *= r;
      var i = 3 * a[0] - 2 * o[0] - s[0];
      i *= i;
      var c = 3 * a[1] - 2 * o[1] - s[1];
      return c *= c, h < i && (h = i), r < c && (r = c), h + r;
    }(t, e) < s) {
      var _s11 = t[e + 0];
      if (a.length) {
        (o = a[a.length - 1], h = _s11, Math.sqrt(R(o, h))) > 1 && a.push(_s11);
      } else a.push(_s11);
      a.push(t[e + 3]);
    } else {
      var _n10 = .5,
        _o12 = t[e + 0],
        _h13 = t[e + 1],
        _r13 = t[e + 2],
        _i7 = t[e + 3],
        _c9 = j(_o12, _h13, _n10),
        _l11 = j(_h13, _r13, _n10),
        _u7 = j(_r13, _i7, _n10),
        _p5 = j(_c9, _l11, _n10),
        _f4 = j(_l11, _u7, _n10),
        _d2 = j(_p5, _f4, _n10);
      F([_o12, _c9, _p5, _d2], 0, s, a), F([_d2, _f4, _u7, _i7], 0, s, a);
    }
    var o, h;
    return a;
  }
  function V(t, e) {
    return Z(t, 0, t.length, e);
  }
  function Z(t, e, s, n, a) {
    var o = a || [],
      h = t[e],
      r = t[s - 1];
    var i = 0,
      c = 1;
    for (var _n11 = e + 1; _n11 < s - 1; ++_n11) {
      var _e14 = q(t[_n11], h, r);
      _e14 > i && (i = _e14, c = _n11);
    }
    return Math.sqrt(i) > n ? (Z(t, e, c + 1, n, o), Z(t, c, s, n, o)) : (o.length || o.push(h), o.push(r)), o;
  }
  function Q(t) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .15;
    var s = arguments.length > 2 ? arguments[2] : undefined;
    var n = [],
      a = (t.length - 1) / 3;
    for (var _s12 = 0; _s12 < a; _s12++) {
      F(t, 3 * _s12, e, n);
    }
    return s && s > 0 ? Z(n, 0, n.length, s) : n;
  }
  var H = "none";
  var N = /*#__PURE__*/function () {
    function N(t) {
      _classCallCheck(this, N);
      this.defaultOptions = {
        maxRandomnessOffset: 2,
        roughness: 1,
        bowing: 1,
        stroke: "#000",
        strokeWidth: 1,
        curveTightness: 0,
        curveFitting: .95,
        curveStepCount: 9,
        fillStyle: "hachure",
        fillWeight: -1,
        hachureAngle: -41,
        hachureGap: -1,
        dashOffset: -1,
        dashGap: -1,
        zigzagOffset: -1,
        seed: 0,
        disableMultiStroke: !1,
        disableMultiStrokeFill: !1,
        preserveVertices: !1
      }, this.config = t || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
    }
    _createClass(N, [{
      key: "_o",
      value: function _o(t) {
        return t ? Object.assign({}, this.defaultOptions, t) : this.defaultOptions;
      }
    }, {
      key: "_d",
      value: function _d(t, e, s) {
        return {
          shape: t,
          sets: e || [],
          options: s || this.defaultOptions
        };
      }
    }, {
      key: "line",
      value: function line(t, e, s, n, a) {
        var o = this._o(a);
        return this._d("line", [y(t, e, s, n, o)], o);
      }
    }, {
      key: "rectangle",
      value: function rectangle(t, e, s, n, a) {
        var o = this._o(a),
          h = [],
          r = w(t, e, s, n, o);
        if (o.fill) {
          var _a9 = [[t, e], [t + s, e], [t + s, e + n], [t, e + n]];
          "solid" === o.fillStyle ? h.push(S([_a9], o)) : h.push(L([_a9], o));
        }
        return o.stroke !== H && h.push(r), this._d("rectangle", h, o);
      }
    }, {
      key: "ellipse",
      value: function ellipse(t, e, s, n, a) {
        var o = this._o(a),
          h = [],
          r = P(s, n, o),
          i = v(t, e, o, r);
        if (o.fill) if ("solid" === o.fillStyle) {
          var _s13 = v(t, e, o, r).opset;
          _s13.type = "fillPath", h.push(_s13);
        } else h.push(L([i.estimatedPoints], o));
        return o.stroke !== H && h.push(i.opset), this._d("ellipse", h, o);
      }
    }, {
      key: "circle",
      value: function circle(t, e, s, n) {
        var a = this.ellipse(t, e, s, s, n);
        return a.shape = "circle", a;
      }
    }, {
      key: "linearPath",
      value: function linearPath(t, e) {
        var s = this._o(e);
        return this._d("linearPath", [m$2(t, !1, s)], s);
      }
    }, {
      key: "arc",
      value: function arc(t, e, s, n, a, o) {
        var h = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
        var r = arguments.length > 7 ? arguments[7] : undefined;
        var i = this._o(r),
          c = [],
          l = O(t, e, s, n, a, o, h, !0, i);
        if (h && i.fill) if ("solid" === i.fillStyle) {
          var _h14 = Object.assign({}, i);
          _h14.disableMultiStroke = !0;
          var _r14 = O(t, e, s, n, a, o, !0, !1, _h14);
          _r14.type = "fillPath", c.push(_r14);
        } else c.push(function (t, e, s, n, a, o, h) {
          var r = t,
            i = e;
          var c = Math.abs(s / 2),
            l = Math.abs(n / 2);
          c += A(.01 * c, h), l += A(.01 * l, h);
          var u = a,
            p = o;
          for (; u < 0;) u += 2 * Math.PI, p += 2 * Math.PI;
          p - u > 2 * Math.PI && (u = 0, p = 2 * Math.PI);
          var f = (p - u) / h.curveStepCount,
            d = [];
          for (var _t28 = u; _t28 <= p; _t28 += f) d.push([r + c * Math.cos(_t28), i + l * Math.sin(_t28)]);
          return d.push([r + c * Math.cos(p), i + l * Math.sin(p)]), d.push([r, i]), L([d], h);
        }(t, e, s, n, a, o, i));
        return i.stroke !== H && c.push(l), this._d("arc", c, i);
      }
    }, {
      key: "curve",
      value: function curve(t, e) {
        var s = this._o(e),
          n = [],
          a = x(t, s);
        if (s.fill && s.fill !== H && t.length >= 3) {
          var _e15 = Q(function (t) {
            var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var s = t.length;
            if (s < 3) throw new Error("A curve must have at least three points.");
            var n = [];
            if (3 === s) n.push(G(t[0]), G(t[1]), G(t[2]), G(t[2]));else {
              var _s14 = [];
              _s14.push(t[0], t[0]);
              for (var _e16 = 1; _e16 < t.length; _e16++) _s14.push(t[_e16]), _e16 === t.length - 1 && _s14.push(t[_e16]);
              var _a10 = [],
                _o13 = 1 - e;
              n.push(G(_s14[0]));
              for (var _t29 = 1; _t29 + 2 < _s14.length; _t29++) {
                var _e17 = _s14[_t29];
                _a10[0] = [_e17[0], _e17[1]], _a10[1] = [_e17[0] + (_o13 * _s14[_t29 + 1][0] - _o13 * _s14[_t29 - 1][0]) / 6, _e17[1] + (_o13 * _s14[_t29 + 1][1] - _o13 * _s14[_t29 - 1][1]) / 6], _a10[2] = [_s14[_t29 + 1][0] + (_o13 * _s14[_t29][0] - _o13 * _s14[_t29 + 2][0]) / 6, _s14[_t29 + 1][1] + (_o13 * _s14[_t29][1] - _o13 * _s14[_t29 + 2][1]) / 6], _a10[3] = [_s14[_t29 + 1][0], _s14[_t29 + 1][1]], n.push(_a10[1], _a10[2], _a10[3]);
              }
            }
            return n;
          }(t), 10, (1 + s.roughness) / 2);
          "solid" === s.fillStyle ? n.push(S([_e15], s)) : n.push(L([_e15], s));
        }
        return s.stroke !== H && n.push(a), this._d("curve", n, s);
      }
    }, {
      key: "polygon",
      value: function polygon(t, e) {
        var s = this._o(e),
          n = [],
          a = m$2(t, !0, s);
        return s.fill && ("solid" === s.fillStyle ? n.push(S([t], s)) : n.push(L([t], s))), s.stroke !== H && n.push(a), this._d("polygon", n, s);
      }
    }, {
      key: "path",
      value: function path(t, e) {
        var s = this._o(e),
          n = [];
        if (!t) return this._d("path", n, s);
        t = (t || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
        var a = s.fill && "transparent" !== s.fill && s.fill !== H,
          o = s.stroke !== H,
          h = !!(s.simplification && s.simplification < 1),
          r = function (t, e, s) {
            var n = g(d(f(t))),
              a = [];
            var o = [],
              h = [0, 0],
              r = [];
            var i = function i() {
                var _o14;
                r.length >= 4 && (_o14 = o).push.apply(_o14, _toConsumableArray(Q(r, e))), r = [];
              },
              c = function c() {
                i(), o.length && (a.push(o), o = []);
              };
            var _iterator10 = _createForOfIteratorHelper(n),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var _step10$value = _step10.value,
                  _t31 = _step10$value.key,
                  _e19 = _step10$value.data;
                switch (_t31) {
                  case "M":
                    c(), h = [_e19[0], _e19[1]], o.push(h);
                    break;
                  case "L":
                    i(), o.push([_e19[0], _e19[1]]);
                    break;
                  case "C":
                    if (!r.length) {
                      var _t32 = o.length ? o[o.length - 1] : h;
                      r.push([_t32[0], _t32[1]]);
                    }
                    r.push([_e19[0], _e19[1]]), r.push([_e19[2], _e19[3]]), r.push([_e19[4], _e19[5]]);
                    break;
                  case "Z":
                    i(), o.push([h[0], h[1]]);
                }
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
            if (c(), !s) return a;
            var l = [];
            for (var _i8 = 0, _a11 = a; _i8 < _a11.length; _i8++) {
              var _t30 = _a11[_i8];
              var _e18 = V(_t30, s);
              _e18.length && l.push(_e18);
            }
            return l;
          }(t, 1, h ? 4 - 4 * s.simplification : (1 + s.roughness) / 2);
        return a && ("solid" === s.fillStyle ? n.push(S(r, s)) : n.push(L(r, s))), o && (h ? r.forEach(function (t) {
          n.push(m$2(t, !1, s));
        }) : n.push(function (t, e) {
          var s = g(d(f(t))),
            n = [];
          var a = [0, 0],
            o = [0, 0];
          var _iterator11 = _createForOfIteratorHelper(s),
            _step11;
          try {
            var _loop = function _loop() {
              var _step11$value = _step11.value,
                t = _step11$value.key,
                h = _step11$value.data;
              switch (t) {
                case "M":
                  {
                    var _t33 = 1 * (e.maxRandomnessOffset || 0),
                      _s15 = e.preserveVertices;
                    n.push({
                      op: "move",
                      data: h.map(function (n) {
                        return n + (_s15 ? 0 : A(_t33, e));
                      })
                    }), o = [h[0], h[1]], a = [h[0], h[1]];
                    break;
                  }
                case "L":
                  n.push.apply(n, _toConsumableArray(I(o[0], o[1], h[0], h[1], e))), o = [h[0], h[1]];
                  break;
                case "C":
                  {
                    var _h15 = _slicedToArray(h, 6),
                      _t34 = _h15[0],
                      _s16 = _h15[1],
                      _a12 = _h15[2],
                      _r15 = _h15[3],
                      _i9 = _h15[4],
                      _c10 = _h15[5];
                    n.push.apply(n, _toConsumableArray($(_t34, _s16, _a12, _r15, _i9, _c10, o, e))), o = [_i9, _c10];
                    break;
                  }
                case "Z":
                  n.push.apply(n, _toConsumableArray(I(o[0], o[1], a[0], a[1], e))), o = [a[0], a[1]];
              }
            };
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
          return {
            type: "path",
            ops: n
          };
        }(t, s))), this._d("path", n, s);
      }
    }, {
      key: "opsToPath",
      value: function opsToPath(t, e) {
        var s = "";
        var _iterator12 = _createForOfIteratorHelper(t.ops),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var _n12 = _step12.value;
            var _t35 = "number" == typeof e && e >= 0 ? _n12.data.map(function (t) {
              return +t.toFixed(e);
            }) : _n12.data;
            switch (_n12.op) {
              case "move":
                s += "M".concat(_t35[0], " ").concat(_t35[1], " ");
                break;
              case "bcurveTo":
                s += "C".concat(_t35[0], " ").concat(_t35[1], ", ").concat(_t35[2], " ").concat(_t35[3], ", ").concat(_t35[4], " ").concat(_t35[5], " ");
                break;
              case "lineTo":
                s += "L".concat(_t35[0], " ").concat(_t35[1], " ");
            }
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        return s.trim();
      }
    }, {
      key: "toPaths",
      value: function toPaths(t) {
        var e = t.sets || [],
          s = t.options || this.defaultOptions,
          n = [];
        var _iterator13 = _createForOfIteratorHelper(e),
          _step13;
        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var _t36 = _step13.value;
            var _e20 = null;
            switch (_t36.type) {
              case "path":
                _e20 = {
                  d: this.opsToPath(_t36),
                  stroke: s.stroke,
                  strokeWidth: s.strokeWidth,
                  fill: H
                };
                break;
              case "fillPath":
                _e20 = {
                  d: this.opsToPath(_t36),
                  stroke: H,
                  strokeWidth: 0,
                  fill: s.fill || H
                };
                break;
              case "fillSketch":
                _e20 = this.fillSketch(_t36, s);
            }
            _e20 && n.push(_e20);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
        return n;
      }
    }, {
      key: "fillSketch",
      value: function fillSketch(t, e) {
        var s = e.fillWeight;
        return s < 0 && (s = e.strokeWidth / 2), {
          d: this.opsToPath(t),
          stroke: e.fill || H,
          strokeWidth: s,
          fill: H
        };
      }
    }], [{
      key: "newSeed",
      value: function newSeed() {
        return Math.floor(Math.random() * Math.pow(2, 31));
      }
    }]);
    return N;
  }();
  var B = /*#__PURE__*/function () {
    function B(t, e) {
      _classCallCheck(this, B);
      this.canvas = t, this.ctx = this.canvas.getContext("2d"), this.gen = new N(e);
    }
    _createClass(B, [{
      key: "draw",
      value: function draw(t) {
        var e = t.sets || [],
          s = t.options || this.getDefaultOptions(),
          n = this.ctx,
          a = t.options.fixedDecimalPlaceDigits;
        var _iterator14 = _createForOfIteratorHelper(e),
          _step14;
        try {
          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
            var _o15 = _step14.value;
            switch (_o15.type) {
              case "path":
                n.save(), n.strokeStyle = "none" === s.stroke ? "transparent" : s.stroke, n.lineWidth = s.strokeWidth, s.strokeLineDash && n.setLineDash(s.strokeLineDash), s.strokeLineDashOffset && (n.lineDashOffset = s.strokeLineDashOffset), this._drawToContext(n, _o15, a), n.restore();
                break;
              case "fillPath":
                {
                  n.save(), n.fillStyle = s.fill || "";
                  var _e21 = "curve" === t.shape || "polygon" === t.shape || "path" === t.shape ? "evenodd" : "nonzero";
                  this._drawToContext(n, _o15, a, _e21), n.restore();
                  break;
                }
              case "fillSketch":
                this.fillSketch(n, _o15, s);
            }
          }
        } catch (err) {
          _iterator14.e(err);
        } finally {
          _iterator14.f();
        }
      }
    }, {
      key: "fillSketch",
      value: function fillSketch(t, e, s) {
        var n = s.fillWeight;
        n < 0 && (n = s.strokeWidth / 2), t.save(), s.fillLineDash && t.setLineDash(s.fillLineDash), s.fillLineDashOffset && (t.lineDashOffset = s.fillLineDashOffset), t.strokeStyle = s.fill || "", t.lineWidth = n, this._drawToContext(t, e, s.fixedDecimalPlaceDigits), t.restore();
      }
    }, {
      key: "_drawToContext",
      value: function _drawToContext(t, e, s) {
        var n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "nonzero";
        t.beginPath();
        var _iterator15 = _createForOfIteratorHelper(e.ops),
          _step15;
        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var _n13 = _step15.value;
            var _e22 = "number" == typeof s && s >= 0 ? _n13.data.map(function (t) {
              return +t.toFixed(s);
            }) : _n13.data;
            switch (_n13.op) {
              case "move":
                t.moveTo(_e22[0], _e22[1]);
                break;
              case "bcurveTo":
                t.bezierCurveTo(_e22[0], _e22[1], _e22[2], _e22[3], _e22[4], _e22[5]);
                break;
              case "lineTo":
                t.lineTo(_e22[0], _e22[1]);
            }
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
        "fillPath" === e.type ? t.fill(n) : t.stroke();
      }
    }, {
      key: "generator",
      get: function get() {
        return this.gen;
      }
    }, {
      key: "getDefaultOptions",
      value: function getDefaultOptions() {
        return this.gen.defaultOptions;
      }
    }, {
      key: "line",
      value: function line(t, e, s, n, a) {
        var o = this.gen.line(t, e, s, n, a);
        return this.draw(o), o;
      }
    }, {
      key: "rectangle",
      value: function rectangle(t, e, s, n, a) {
        var o = this.gen.rectangle(t, e, s, n, a);
        return this.draw(o), o;
      }
    }, {
      key: "ellipse",
      value: function ellipse(t, e, s, n, a) {
        var o = this.gen.ellipse(t, e, s, n, a);
        return this.draw(o), o;
      }
    }, {
      key: "circle",
      value: function circle(t, e, s, n) {
        var a = this.gen.circle(t, e, s, n);
        return this.draw(a), a;
      }
    }, {
      key: "linearPath",
      value: function linearPath(t, e) {
        var s = this.gen.linearPath(t, e);
        return this.draw(s), s;
      }
    }, {
      key: "polygon",
      value: function polygon(t, e) {
        var s = this.gen.polygon(t, e);
        return this.draw(s), s;
      }
    }, {
      key: "arc",
      value: function arc(t, e, s, n, a, o) {
        var h = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
        var r = arguments.length > 7 ? arguments[7] : undefined;
        var i = this.gen.arc(t, e, s, n, a, o, h, r);
        return this.draw(i), i;
      }
    }, {
      key: "curve",
      value: function curve(t, e) {
        var s = this.gen.curve(t, e);
        return this.draw(s), s;
      }
    }, {
      key: "path",
      value: function path(t, e) {
        var s = this.gen.path(t, e);
        return this.draw(s), s;
      }
    }]);
    return B;
  }();
  var J = "http://www.w3.org/2000/svg";
  var K = /*#__PURE__*/function () {
    function K(t, e) {
      _classCallCheck(this, K);
      this.svg = t, this.gen = new N(e);
    }
    _createClass(K, [{
      key: "draw",
      value: function draw(t) {
        var e = t.sets || [],
          s = t.options || this.getDefaultOptions(),
          n = this.svg.ownerDocument || window.document,
          a = n.createElementNS(J, "g"),
          o = t.options.fixedDecimalPlaceDigits;
        var _iterator16 = _createForOfIteratorHelper(e),
          _step16;
        try {
          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
            var _h16 = _step16.value;
            var _e23 = null;
            switch (_h16.type) {
              case "path":
                _e23 = n.createElementNS(J, "path"), _e23.setAttribute("d", this.opsToPath(_h16, o)), _e23.setAttribute("stroke", s.stroke), _e23.setAttribute("stroke-width", s.strokeWidth + ""), _e23.setAttribute("fill", "none"), s.strokeLineDash && _e23.setAttribute("stroke-dasharray", s.strokeLineDash.join(" ").trim()), s.strokeLineDashOffset && _e23.setAttribute("stroke-dashoffset", "".concat(s.strokeLineDashOffset));
                break;
              case "fillPath":
                _e23 = n.createElementNS(J, "path"), _e23.setAttribute("d", this.opsToPath(_h16, o)), _e23.setAttribute("stroke", "none"), _e23.setAttribute("stroke-width", "0"), _e23.setAttribute("fill", s.fill || ""), "curve" !== t.shape && "polygon" !== t.shape || _e23.setAttribute("fill-rule", "evenodd");
                break;
              case "fillSketch":
                _e23 = this.fillSketch(n, _h16, s);
            }
            _e23 && a.appendChild(_e23);
          }
        } catch (err) {
          _iterator16.e(err);
        } finally {
          _iterator16.f();
        }
        return a;
      }
    }, {
      key: "fillSketch",
      value: function fillSketch(t, e, s) {
        var n = s.fillWeight;
        n < 0 && (n = s.strokeWidth / 2);
        var a = t.createElementNS(J, "path");
        return a.setAttribute("d", this.opsToPath(e, s.fixedDecimalPlaceDigits)), a.setAttribute("stroke", s.fill || ""), a.setAttribute("stroke-width", n + ""), a.setAttribute("fill", "none"), s.fillLineDash && a.setAttribute("stroke-dasharray", s.fillLineDash.join(" ").trim()), s.fillLineDashOffset && a.setAttribute("stroke-dashoffset", "".concat(s.fillLineDashOffset)), a;
      }
    }, {
      key: "generator",
      get: function get() {
        return this.gen;
      }
    }, {
      key: "getDefaultOptions",
      value: function getDefaultOptions() {
        return this.gen.defaultOptions;
      }
    }, {
      key: "opsToPath",
      value: function opsToPath(t, e) {
        return this.gen.opsToPath(t, e);
      }
    }, {
      key: "line",
      value: function line(t, e, s, n, a) {
        var o = this.gen.line(t, e, s, n, a);
        return this.draw(o);
      }
    }, {
      key: "rectangle",
      value: function rectangle(t, e, s, n, a) {
        var o = this.gen.rectangle(t, e, s, n, a);
        return this.draw(o);
      }
    }, {
      key: "ellipse",
      value: function ellipse(t, e, s, n, a) {
        var o = this.gen.ellipse(t, e, s, n, a);
        return this.draw(o);
      }
    }, {
      key: "circle",
      value: function circle(t, e, s, n) {
        var a = this.gen.circle(t, e, s, n);
        return this.draw(a);
      }
    }, {
      key: "linearPath",
      value: function linearPath(t, e) {
        var s = this.gen.linearPath(t, e);
        return this.draw(s);
      }
    }, {
      key: "polygon",
      value: function polygon(t, e) {
        var s = this.gen.polygon(t, e);
        return this.draw(s);
      }
    }, {
      key: "arc",
      value: function arc(t, e, s, n, a, o) {
        var h = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
        var r = arguments.length > 7 ? arguments[7] : undefined;
        var i = this.gen.arc(t, e, s, n, a, o, h, r);
        return this.draw(i);
      }
    }, {
      key: "curve",
      value: function curve(t, e) {
        var s = this.gen.curve(t, e);
        return this.draw(s);
      }
    }, {
      key: "path",
      value: function path(t, e) {
        var s = this.gen.path(t, e);
        return this.draw(s);
      }
    }]);
    return K;
  }();
  var U = {
    canvas: function canvas(t, e) {
      return new B(t, e);
    },
    svg: function svg(t, e) {
      return new K(t, e);
    },
    generator: function generator(t) {
      return new N(t);
    },
    newSeed: function newSeed() {
      return N.newSeed();
    }
  };

  var defaultRouthThemeSpec = {
    maxRandomnessOffset: 3,
    roughness: 1,
    bowing: 1,
    curveFitting: .95,
    curveTightness: void 0,
    curveStepCount: 9,
    fillStyle: "hachure",
    fillWeight: void 0,
    hachureAngle: 60,
    hachureGap: 6,
    simplification: 0,
    dashOffset: void 0,
    dashGap: void 0,
    zigzagOffset: void 0,
    seed: 1,
    fillLineDash: void 0,
    fillLineDashOffset: void 0,
    disableMultiStroke: !1,
    disableMultiStrokeFill: !1,
    preserveVertices: !0,
    fixedDecimalPlaceDigits: void 0
  };

  var __decorate$10 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$P = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$z = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var RoughCanvasArcRender = /*#__PURE__*/function () {
    function RoughCanvasArcRender(canvasRenderer) {
      _classCallCheck(this, RoughCanvasArcRender);
      this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
    }
    _createClass(RoughCanvasArcRender, [{
      key: "draw",
      value: function draw(arc, renderService, drawContext, params) {
        var context = drawContext.context;
        if (!context) return;
        var canvas = context.canvas.nativeCanvas,
          rc = U.canvas(canvas);
        context.highPerformanceSave();
        var arcAttribute = getTheme(arc).arc;
        var _arc$attribute = arc.attribute,
          _arc$attribute$x = _arc$attribute.x,
          x = _arc$attribute$x === void 0 ? arcAttribute.x : _arc$attribute$x,
          _arc$attribute$y = _arc$attribute.y,
          y = _arc$attribute$y === void 0 ? arcAttribute.y : _arc$attribute$y;
        if (arc.transMatrix.onlyTranslate()) {
          var _arc$attribute2 = arc.attribute,
            _arc$attribute2$dx = _arc$attribute2.dx,
            dx = _arc$attribute2$dx === void 0 ? arcAttribute.dx : _arc$attribute2$dx,
            _arc$attribute2$dy = _arc$attribute2.dy,
            dy = _arc$attribute2$dy === void 0 ? arcAttribute.dy : _arc$attribute2$dy;
          x += dx, y += dy, context.setTransformForCurrent();
        } else x = 0, y = 0, context.transformFromMatrix(arc.transMatrix, !0);
        var customPath = new CustomPath2D(),
          _arc$attribute3 = arc.attribute,
          _arc$attribute3$fill = _arc$attribute3.fill,
          fill = _arc$attribute3$fill === void 0 ? arcAttribute.fill : _arc$attribute3$fill,
          _arc$attribute3$strok = _arc$attribute3.stroke,
          stroke = _arc$attribute3$strok === void 0 ? arcAttribute.stroke : _arc$attribute3$strok,
          _arc$attribute3$lineW = _arc$attribute3.lineWidth,
          lineWidth = _arc$attribute3$lineW === void 0 ? arcAttribute.lineWidth : _arc$attribute3$lineW,
          _arc$attribute3$outer = _arc$attribute3.outerRadius,
          outerRadius = _arc$attribute3$outer === void 0 ? arcAttribute.outerRadius : _arc$attribute3$outer,
          _arc$attribute3$inner = _arc$attribute3.innerRadius,
          innerRadius = _arc$attribute3$inner === void 0 ? arcAttribute.innerRadius : _arc$attribute3$inner,
          _arc$attribute3$maxRa = _arc$attribute3.maxRandomnessOffset,
          maxRandomnessOffset = _arc$attribute3$maxRa === void 0 ? defaultRouthThemeSpec.maxRandomnessOffset : _arc$attribute3$maxRa,
          _arc$attribute3$rough = _arc$attribute3.roughness,
          roughness = _arc$attribute3$rough === void 0 ? defaultRouthThemeSpec.roughness : _arc$attribute3$rough,
          _arc$attribute3$bowin = _arc$attribute3.bowing,
          bowing = _arc$attribute3$bowin === void 0 ? defaultRouthThemeSpec.bowing : _arc$attribute3$bowin,
          _arc$attribute3$curve = _arc$attribute3.curveFitting,
          curveFitting = _arc$attribute3$curve === void 0 ? defaultRouthThemeSpec.curveFitting : _arc$attribute3$curve,
          _arc$attribute3$curve2 = _arc$attribute3.curveTightness,
          curveTightness = _arc$attribute3$curve2 === void 0 ? defaultRouthThemeSpec.curveTightness : _arc$attribute3$curve2,
          _arc$attribute3$curve3 = _arc$attribute3.curveStepCount,
          curveStepCount = _arc$attribute3$curve3 === void 0 ? defaultRouthThemeSpec.curveStepCount : _arc$attribute3$curve3,
          _arc$attribute3$fillS = _arc$attribute3.fillStyle,
          fillStyle = _arc$attribute3$fillS === void 0 ? defaultRouthThemeSpec.fillStyle : _arc$attribute3$fillS,
          _arc$attribute3$fillW = _arc$attribute3.fillWeight,
          fillWeight = _arc$attribute3$fillW === void 0 ? defaultRouthThemeSpec.fillWeight : _arc$attribute3$fillW,
          _arc$attribute3$hachu = _arc$attribute3.hachureAngle,
          hachureAngle = _arc$attribute3$hachu === void 0 ? defaultRouthThemeSpec.hachureAngle : _arc$attribute3$hachu,
          _arc$attribute3$hachu2 = _arc$attribute3.hachureGap,
          hachureGap = _arc$attribute3$hachu2 === void 0 ? defaultRouthThemeSpec.hachureGap : _arc$attribute3$hachu2,
          _arc$attribute3$simpl = _arc$attribute3.simplification,
          simplification = _arc$attribute3$simpl === void 0 ? defaultRouthThemeSpec.simplification : _arc$attribute3$simpl,
          _arc$attribute3$dashO = _arc$attribute3.dashOffset,
          dashOffset = _arc$attribute3$dashO === void 0 ? defaultRouthThemeSpec.dashOffset : _arc$attribute3$dashO,
          _arc$attribute3$dashG = _arc$attribute3.dashGap,
          dashGap = _arc$attribute3$dashG === void 0 ? defaultRouthThemeSpec.dashGap : _arc$attribute3$dashG,
          _arc$attribute3$zigza = _arc$attribute3.zigzagOffset,
          zigzagOffset = _arc$attribute3$zigza === void 0 ? defaultRouthThemeSpec.zigzagOffset : _arc$attribute3$zigza,
          _arc$attribute3$seed = _arc$attribute3.seed,
          seed = _arc$attribute3$seed === void 0 ? defaultRouthThemeSpec.seed : _arc$attribute3$seed,
          _arc$attribute3$fillL = _arc$attribute3.fillLineDash,
          fillLineDash = _arc$attribute3$fillL === void 0 ? defaultRouthThemeSpec.fillLineDash : _arc$attribute3$fillL,
          _arc$attribute3$fillL2 = _arc$attribute3.fillLineDashOffset,
          fillLineDashOffset = _arc$attribute3$fillL2 === void 0 ? defaultRouthThemeSpec.fillLineDashOffset : _arc$attribute3$fillL2,
          _arc$attribute3$disab = _arc$attribute3.disableMultiStroke,
          disableMultiStroke = _arc$attribute3$disab === void 0 ? defaultRouthThemeSpec.disableMultiStroke : _arc$attribute3$disab,
          _arc$attribute3$disab2 = _arc$attribute3.disableMultiStrokeFill,
          disableMultiStrokeFill = _arc$attribute3$disab2 === void 0 ? defaultRouthThemeSpec.disableMultiStrokeFill : _arc$attribute3$disab2,
          _arc$attribute3$prese = _arc$attribute3.preserveVertices,
          preserveVertices = _arc$attribute3$prese === void 0 ? defaultRouthThemeSpec.preserveVertices : _arc$attribute3$prese,
          _arc$attribute3$fixed = _arc$attribute3.fixedDecimalPlaceDigits,
          fixedDecimalPlaceDigits = _arc$attribute3$fixed === void 0 ? defaultRouthThemeSpec.fixedDecimalPlaceDigits : _arc$attribute3$fixed;
        drawArcPath$1(arc, customPath, x, y, outerRadius, innerRadius), rc.path(customPath.toString(), {
          fill: fill || void 0,
          stroke: stroke || void 0,
          strokeWidth: lineWidth,
          maxRandomnessOffset: maxRandomnessOffset,
          roughness: roughness,
          bowing: bowing,
          curveFitting: curveFitting,
          curveTightness: curveTightness,
          curveStepCount: curveStepCount,
          fillStyle: fillStyle,
          fillWeight: fillWeight,
          hachureAngle: hachureAngle,
          hachureGap: hachureGap,
          simplification: simplification,
          dashOffset: dashOffset,
          dashGap: dashGap,
          zigzagOffset: zigzagOffset,
          seed: seed,
          fillLineDash: fillLineDash,
          fillLineDashOffset: fillLineDashOffset,
          disableMultiStroke: disableMultiStroke,
          disableMultiStrokeFill: disableMultiStrokeFill,
          preserveVertices: preserveVertices,
          fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
        }), context.highPerformanceRestore();
      }
    }, {
      key: "drawShape",
      value: function drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb) {
        if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb);
      }
    }]);
    return RoughCanvasArcRender;
  }();
  RoughCanvasArcRender = __decorate$10([injectable(), __param$z(0, inject(exports.DefaultCanvasArcRender)), __metadata$P("design:paramtypes", [Object])], RoughCanvasArcRender);

  var __decorate$$ = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var RoughCanvasAreaRender = /*#__PURE__*/function (_DefaultCanvasAreaRen) {
    _inherits(RoughCanvasAreaRender, _DefaultCanvasAreaRen);
    var _super = _createSuper(RoughCanvasAreaRender);
    function RoughCanvasAreaRender() {
      var _this;
      _classCallCheck(this, RoughCanvasAreaRender);
      _this = _super.apply(this, arguments), _this.style = "rough";
      return _this;
    }
    _createClass(RoughCanvasAreaRender, [{
      key: "drawSegmentItem",
      value: function drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb) {
        if (fillCb) return _get(_getPrototypeOf(RoughCanvasAreaRender.prototype), "drawSegmentItem", this).call(this, context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb);
        context.highPerformanceSave();
        var canvas = context.canvas.nativeCanvas,
          rc = U.canvas(canvas, {}),
          customPath = new CustomPath2D();
        drawAreaSegments(customPath, cache, clipRange, {
          offsetX: offsetX,
          offsetY: offsetY
        });
        var _attribute$maxRandomn = attribute.maxRandomnessOffset,
          maxRandomnessOffset = _attribute$maxRandomn === void 0 ? defaultRouthThemeSpec.maxRandomnessOffset : _attribute$maxRandomn,
          _attribute$roughness = attribute.roughness,
          roughness = _attribute$roughness === void 0 ? defaultRouthThemeSpec.roughness : _attribute$roughness,
          _attribute$bowing = attribute.bowing,
          bowing = _attribute$bowing === void 0 ? defaultRouthThemeSpec.bowing : _attribute$bowing,
          _attribute$curveFitti = attribute.curveFitting,
          curveFitting = _attribute$curveFitti === void 0 ? defaultRouthThemeSpec.curveFitting : _attribute$curveFitti,
          _attribute$curveTight = attribute.curveTightness,
          curveTightness = _attribute$curveTight === void 0 ? defaultRouthThemeSpec.curveTightness : _attribute$curveTight,
          _attribute$curveStepC = attribute.curveStepCount,
          curveStepCount = _attribute$curveStepC === void 0 ? defaultRouthThemeSpec.curveStepCount : _attribute$curveStepC,
          _attribute$fillStyle = attribute.fillStyle,
          fillStyle = _attribute$fillStyle === void 0 ? defaultRouthThemeSpec.fillStyle : _attribute$fillStyle,
          _attribute$fillWeight = attribute.fillWeight,
          fillWeight = _attribute$fillWeight === void 0 ? defaultRouthThemeSpec.fillWeight : _attribute$fillWeight,
          _attribute$hachureAng = attribute.hachureAngle,
          hachureAngle = _attribute$hachureAng === void 0 ? defaultRouthThemeSpec.hachureAngle : _attribute$hachureAng,
          _attribute$hachureGap = attribute.hachureGap,
          hachureGap = _attribute$hachureGap === void 0 ? defaultRouthThemeSpec.hachureGap : _attribute$hachureGap,
          _attribute$simplifica = attribute.simplification,
          simplification = _attribute$simplifica === void 0 ? defaultRouthThemeSpec.simplification : _attribute$simplifica,
          _attribute$dashOffset = attribute.dashOffset,
          dashOffset = _attribute$dashOffset === void 0 ? defaultRouthThemeSpec.dashOffset : _attribute$dashOffset,
          _attribute$dashGap = attribute.dashGap,
          dashGap = _attribute$dashGap === void 0 ? defaultRouthThemeSpec.dashGap : _attribute$dashGap,
          _attribute$zigzagOffs = attribute.zigzagOffset,
          zigzagOffset = _attribute$zigzagOffs === void 0 ? defaultRouthThemeSpec.zigzagOffset : _attribute$zigzagOffs,
          _attribute$seed = attribute.seed,
          seed = _attribute$seed === void 0 ? defaultRouthThemeSpec.seed : _attribute$seed,
          _attribute$fillLineDa = attribute.fillLineDash,
          fillLineDash = _attribute$fillLineDa === void 0 ? defaultRouthThemeSpec.fillLineDash : _attribute$fillLineDa,
          _attribute$fillLineDa2 = attribute.fillLineDashOffset,
          fillLineDashOffset = _attribute$fillLineDa2 === void 0 ? defaultRouthThemeSpec.fillLineDashOffset : _attribute$fillLineDa2,
          _attribute$disableMul = attribute.disableMultiStroke,
          disableMultiStroke = _attribute$disableMul === void 0 ? defaultRouthThemeSpec.disableMultiStroke : _attribute$disableMul,
          _attribute$disableMul2 = attribute.disableMultiStrokeFill,
          disableMultiStrokeFill = _attribute$disableMul2 === void 0 ? defaultRouthThemeSpec.disableMultiStrokeFill : _attribute$disableMul2,
          _attribute$preserveVe = attribute.preserveVertices,
          preserveVertices = _attribute$preserveVe === void 0 ? defaultRouthThemeSpec.preserveVertices : _attribute$preserveVe,
          _attribute$fixedDecim = attribute.fixedDecimalPlaceDigits,
          fixedDecimalPlaceDigits = _attribute$fixedDecim === void 0 ? defaultRouthThemeSpec.fixedDecimalPlaceDigits : _attribute$fixedDecim;
        var fillColor = attribute.fill,
          strokeColor = attribute.stroke,
          lineWidth = attribute.lineWidth;
        return Array.isArray(defaultAttribute) ? defaultAttribute.forEach(function (item) {
          fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
        }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
          fill: fill ? fillColor : void 0,
          strokeWidth: lineWidth,
          maxRandomnessOffset: maxRandomnessOffset,
          roughness: roughness,
          bowing: bowing,
          curveFitting: curveFitting,
          curveTightness: curveTightness,
          curveStepCount: curveStepCount,
          fillStyle: fillStyle,
          fillWeight: fillWeight,
          hachureAngle: hachureAngle,
          hachureGap: hachureGap,
          simplification: simplification,
          dashOffset: dashOffset,
          dashGap: dashGap,
          zigzagOffset: zigzagOffset,
          seed: seed,
          fillLineDash: fillLineDash,
          fillLineDashOffset: fillLineDashOffset,
          disableMultiStroke: disableMultiStroke,
          disableMultiStrokeFill: disableMultiStrokeFill,
          preserveVertices: preserveVertices,
          fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
        }), context.highPerformanceRestore(), !1;
      }
    }]);
    return RoughCanvasAreaRender;
  }(exports.DefaultCanvasAreaRender);
  RoughCanvasAreaRender = __decorate$$([injectable()], RoughCanvasAreaRender);

  var __decorate$_ = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$O = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$y = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var RoughCanvasCircleRender = /*#__PURE__*/function () {
    function RoughCanvasCircleRender(canvasRenderer) {
      _classCallCheck(this, RoughCanvasCircleRender);
      this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
    }
    _createClass(RoughCanvasCircleRender, [{
      key: "draw",
      value: function draw(circle, renderService, drawContext, params) {
        var context = drawContext.context;
        if (!context) return;
        var canvas = context.canvas.nativeCanvas,
          rc = U.canvas(canvas, {}),
          circleAttribute = getTheme(circle).circle;
        var _circle$attribute = circle.attribute,
          _circle$attribute$x = _circle$attribute.x,
          x = _circle$attribute$x === void 0 ? circleAttribute.x : _circle$attribute$x,
          _circle$attribute$y = _circle$attribute.y,
          y = _circle$attribute$y === void 0 ? circleAttribute.y : _circle$attribute$y;
        circle.transMatrix.onlyTranslate() ? context.onlyTranslate() || context.clearMatrix() : (x = 0, y = 0, context.transformFromMatrix(circle.transMatrix, !0));
        var _circle$attribute2 = circle.attribute,
          _circle$attribute2$ra = _circle$attribute2.radius,
          radius = _circle$attribute2$ra === void 0 ? circleAttribute.radius : _circle$attribute2$ra,
          _circle$attribute2$fi = _circle$attribute2.fill,
          fill = _circle$attribute2$fi === void 0 ? circleAttribute.fill : _circle$attribute2$fi,
          _circle$attribute2$st = _circle$attribute2.stroke,
          stroke = _circle$attribute2$st === void 0 ? circleAttribute.stroke : _circle$attribute2$st,
          _circle$attribute2$li = _circle$attribute2.lineWidth,
          lineWidth = _circle$attribute2$li === void 0 ? circleAttribute.lineWidth : _circle$attribute2$li;
        rc.circle(x, y, radius, {
          fill: fill || void 0,
          stroke: stroke || void 0,
          strokeWidth: lineWidth,
          fillStyle: "zigzag",
          roughness: .5
        });
      }
    }, {
      key: "drawShape",
      value: function drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb) {
        if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb);
      }
    }]);
    return RoughCanvasCircleRender;
  }();
  RoughCanvasCircleRender = __decorate$_([injectable(), __param$y(0, inject(exports.DefaultCanvasCircleRender)), __metadata$O("design:paramtypes", [Object])], RoughCanvasCircleRender);

  var __decorate$Z = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var RoughCanvasLineRender = /*#__PURE__*/function (_DefaultCanvasLineRen) {
    _inherits(RoughCanvasLineRender, _DefaultCanvasLineRen);
    var _super = _createSuper(RoughCanvasLineRender);
    function RoughCanvasLineRender() {
      var _this;
      _classCallCheck(this, RoughCanvasLineRender);
      _this = _super.apply(this, arguments), _this.style = "rough";
      return _this;
    }
    _createClass(RoughCanvasLineRender, [{
      key: "drawSegmentItem",
      value: function drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
        if (fillCb || strokeCb) return _get(_getPrototypeOf(RoughCanvasLineRender.prototype), "drawSegmentItem", this).call(this, context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb);
        context.highPerformanceSave();
        var canvas = context.canvas.nativeCanvas,
          rc = U.canvas(canvas, {}),
          customPath = new CustomPath2D();
        drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
          offsetX: offsetX,
          offsetY: offsetY
        });
        var _attribute$maxRandomn = attribute.maxRandomnessOffset,
          maxRandomnessOffset = _attribute$maxRandomn === void 0 ? defaultRouthThemeSpec.maxRandomnessOffset : _attribute$maxRandomn,
          _attribute$roughness = attribute.roughness,
          roughness = _attribute$roughness === void 0 ? defaultRouthThemeSpec.roughness : _attribute$roughness,
          _attribute$bowing = attribute.bowing,
          bowing = _attribute$bowing === void 0 ? defaultRouthThemeSpec.bowing : _attribute$bowing,
          _attribute$curveFitti = attribute.curveFitting,
          curveFitting = _attribute$curveFitti === void 0 ? defaultRouthThemeSpec.curveFitting : _attribute$curveFitti,
          _attribute$curveTight = attribute.curveTightness,
          curveTightness = _attribute$curveTight === void 0 ? defaultRouthThemeSpec.curveTightness : _attribute$curveTight,
          _attribute$curveStepC = attribute.curveStepCount,
          curveStepCount = _attribute$curveStepC === void 0 ? defaultRouthThemeSpec.curveStepCount : _attribute$curveStepC,
          _attribute$fillStyle = attribute.fillStyle,
          fillStyle = _attribute$fillStyle === void 0 ? defaultRouthThemeSpec.fillStyle : _attribute$fillStyle,
          _attribute$fillWeight = attribute.fillWeight,
          fillWeight = _attribute$fillWeight === void 0 ? defaultRouthThemeSpec.fillWeight : _attribute$fillWeight,
          _attribute$hachureAng = attribute.hachureAngle,
          hachureAngle = _attribute$hachureAng === void 0 ? defaultRouthThemeSpec.hachureAngle : _attribute$hachureAng,
          _attribute$hachureGap = attribute.hachureGap,
          hachureGap = _attribute$hachureGap === void 0 ? defaultRouthThemeSpec.hachureGap : _attribute$hachureGap,
          _attribute$simplifica = attribute.simplification,
          simplification = _attribute$simplifica === void 0 ? defaultRouthThemeSpec.simplification : _attribute$simplifica,
          _attribute$dashOffset = attribute.dashOffset,
          dashOffset = _attribute$dashOffset === void 0 ? defaultRouthThemeSpec.dashOffset : _attribute$dashOffset,
          _attribute$dashGap = attribute.dashGap,
          dashGap = _attribute$dashGap === void 0 ? defaultRouthThemeSpec.dashGap : _attribute$dashGap,
          _attribute$zigzagOffs = attribute.zigzagOffset,
          zigzagOffset = _attribute$zigzagOffs === void 0 ? defaultRouthThemeSpec.zigzagOffset : _attribute$zigzagOffs,
          _attribute$seed = attribute.seed,
          seed = _attribute$seed === void 0 ? defaultRouthThemeSpec.seed : _attribute$seed,
          _attribute$fillLineDa = attribute.fillLineDash,
          fillLineDash = _attribute$fillLineDa === void 0 ? defaultRouthThemeSpec.fillLineDash : _attribute$fillLineDa,
          _attribute$fillLineDa2 = attribute.fillLineDashOffset,
          fillLineDashOffset = _attribute$fillLineDa2 === void 0 ? defaultRouthThemeSpec.fillLineDashOffset : _attribute$fillLineDa2,
          _attribute$disableMul = attribute.disableMultiStroke,
          disableMultiStroke = _attribute$disableMul === void 0 ? defaultRouthThemeSpec.disableMultiStroke : _attribute$disableMul,
          _attribute$disableMul2 = attribute.disableMultiStrokeFill,
          disableMultiStrokeFill = _attribute$disableMul2 === void 0 ? defaultRouthThemeSpec.disableMultiStrokeFill : _attribute$disableMul2,
          _attribute$preserveVe = attribute.preserveVertices,
          preserveVertices = _attribute$preserveVe === void 0 ? defaultRouthThemeSpec.preserveVertices : _attribute$preserveVe,
          _attribute$fixedDecim = attribute.fixedDecimalPlaceDigits,
          fixedDecimalPlaceDigits = _attribute$fixedDecim === void 0 ? defaultRouthThemeSpec.fixedDecimalPlaceDigits : _attribute$fixedDecim;
        var fillColor = attribute.fill,
          strokeColor = attribute.stroke,
          lineWidth = attribute.lineWidth;
        return Array.isArray(defaultAttribute) ? defaultAttribute.forEach(function (item) {
          fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
        }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
          fill: fill ? fillColor : void 0,
          stroke: stroke ? strokeColor : void 0,
          strokeWidth: lineWidth,
          maxRandomnessOffset: maxRandomnessOffset,
          roughness: roughness,
          bowing: bowing,
          curveFitting: curveFitting,
          curveTightness: curveTightness,
          curveStepCount: curveStepCount,
          fillStyle: fillStyle,
          fillWeight: fillWeight,
          hachureAngle: hachureAngle,
          hachureGap: hachureGap,
          simplification: simplification,
          dashOffset: dashOffset,
          dashGap: dashGap,
          zigzagOffset: zigzagOffset,
          seed: seed,
          fillLineDash: fillLineDash,
          fillLineDashOffset: fillLineDashOffset,
          disableMultiStroke: disableMultiStroke,
          disableMultiStrokeFill: disableMultiStrokeFill,
          preserveVertices: preserveVertices,
          fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
        }), context.highPerformanceRestore(), !1;
      }
    }]);
    return RoughCanvasLineRender;
  }(exports.DefaultCanvasLineRender);
  RoughCanvasLineRender = __decorate$Z([injectable()], RoughCanvasLineRender);

  var __decorate$Y = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$N = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$x = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var RoughCanvasPathRender = /*#__PURE__*/function () {
    function RoughCanvasPathRender(canvasRenderer) {
      _classCallCheck(this, RoughCanvasPathRender);
      this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "path", this.numberType = PATH_NUMBER_TYPE;
    }
    _createClass(RoughCanvasPathRender, [{
      key: "draw",
      value: function draw(path, renderService, drawContext, params) {
        var context = drawContext.context;
        if (!context) return;
        var canvas = context.canvas.nativeCanvas,
          rc = U.canvas(canvas, {});
        context.highPerformanceSave();
        var pathAttribute = getTheme(path).path;
        context.transformFromMatrix(path.transMatrix, !0);
        var _path$attribute = path.attribute,
          _path$attribute$fill = _path$attribute.fill,
          fill = _path$attribute$fill === void 0 ? pathAttribute.fill : _path$attribute$fill,
          _path$attribute$strok = _path$attribute.stroke,
          stroke = _path$attribute$strok === void 0 ? pathAttribute.stroke : _path$attribute$strok,
          _path$attribute$lineW = _path$attribute.lineWidth,
          lineWidth = _path$attribute$lineW === void 0 ? pathAttribute.lineWidth : _path$attribute$lineW,
          _path$attribute$path = _path$attribute.path,
          p = _path$attribute$path === void 0 ? pathAttribute.path : _path$attribute$path,
          _path$attribute$maxRa = _path$attribute.maxRandomnessOffset,
          maxRandomnessOffset = _path$attribute$maxRa === void 0 ? defaultRouthThemeSpec.maxRandomnessOffset : _path$attribute$maxRa,
          _path$attribute$rough = _path$attribute.roughness,
          roughness = _path$attribute$rough === void 0 ? defaultRouthThemeSpec.roughness : _path$attribute$rough,
          _path$attribute$bowin = _path$attribute.bowing,
          bowing = _path$attribute$bowin === void 0 ? defaultRouthThemeSpec.bowing : _path$attribute$bowin,
          _path$attribute$curve = _path$attribute.curveFitting,
          curveFitting = _path$attribute$curve === void 0 ? defaultRouthThemeSpec.curveFitting : _path$attribute$curve,
          _path$attribute$curve2 = _path$attribute.curveTightness,
          curveTightness = _path$attribute$curve2 === void 0 ? defaultRouthThemeSpec.curveTightness : _path$attribute$curve2,
          _path$attribute$curve3 = _path$attribute.curveStepCount,
          curveStepCount = _path$attribute$curve3 === void 0 ? defaultRouthThemeSpec.curveStepCount : _path$attribute$curve3,
          _path$attribute$fillS = _path$attribute.fillStyle,
          fillStyle = _path$attribute$fillS === void 0 ? defaultRouthThemeSpec.fillStyle : _path$attribute$fillS,
          _path$attribute$fillW = _path$attribute.fillWeight,
          fillWeight = _path$attribute$fillW === void 0 ? defaultRouthThemeSpec.fillWeight : _path$attribute$fillW,
          _path$attribute$hachu = _path$attribute.hachureAngle,
          hachureAngle = _path$attribute$hachu === void 0 ? defaultRouthThemeSpec.hachureAngle : _path$attribute$hachu,
          _path$attribute$hachu2 = _path$attribute.hachureGap,
          hachureGap = _path$attribute$hachu2 === void 0 ? defaultRouthThemeSpec.hachureGap : _path$attribute$hachu2,
          _path$attribute$simpl = _path$attribute.simplification,
          simplification = _path$attribute$simpl === void 0 ? defaultRouthThemeSpec.simplification : _path$attribute$simpl,
          _path$attribute$dashO = _path$attribute.dashOffset,
          dashOffset = _path$attribute$dashO === void 0 ? defaultRouthThemeSpec.dashOffset : _path$attribute$dashO,
          _path$attribute$dashG = _path$attribute.dashGap,
          dashGap = _path$attribute$dashG === void 0 ? defaultRouthThemeSpec.dashGap : _path$attribute$dashG,
          _path$attribute$zigza = _path$attribute.zigzagOffset,
          zigzagOffset = _path$attribute$zigza === void 0 ? defaultRouthThemeSpec.zigzagOffset : _path$attribute$zigza,
          _path$attribute$seed = _path$attribute.seed,
          seed = _path$attribute$seed === void 0 ? defaultRouthThemeSpec.seed : _path$attribute$seed,
          _path$attribute$fillL = _path$attribute.fillLineDash,
          fillLineDash = _path$attribute$fillL === void 0 ? defaultRouthThemeSpec.fillLineDash : _path$attribute$fillL,
          _path$attribute$fillL2 = _path$attribute.fillLineDashOffset,
          fillLineDashOffset = _path$attribute$fillL2 === void 0 ? defaultRouthThemeSpec.fillLineDashOffset : _path$attribute$fillL2,
          _path$attribute$disab = _path$attribute.disableMultiStroke,
          disableMultiStroke = _path$attribute$disab === void 0 ? defaultRouthThemeSpec.disableMultiStroke : _path$attribute$disab,
          _path$attribute$disab2 = _path$attribute.disableMultiStrokeFill,
          disableMultiStrokeFill = _path$attribute$disab2 === void 0 ? defaultRouthThemeSpec.disableMultiStrokeFill : _path$attribute$disab2,
          _path$attribute$prese = _path$attribute.preserveVertices,
          preserveVertices = _path$attribute$prese === void 0 ? defaultRouthThemeSpec.preserveVertices : _path$attribute$prese,
          _path$attribute$fixed = _path$attribute.fixedDecimalPlaceDigits,
          fixedDecimalPlaceDigits = _path$attribute$fixed === void 0 ? defaultRouthThemeSpec.fixedDecimalPlaceDigits : _path$attribute$fixed;
        "string" == typeof p && rc.path(p, {
          fill: fill || void 0,
          stroke: stroke || void 0,
          strokeWidth: lineWidth,
          maxRandomnessOffset: maxRandomnessOffset,
          roughness: roughness,
          bowing: bowing,
          curveFitting: curveFitting,
          curveTightness: curveTightness,
          curveStepCount: curveStepCount,
          fillStyle: fillStyle,
          fillWeight: fillWeight,
          hachureAngle: hachureAngle,
          hachureGap: hachureGap,
          simplification: simplification,
          dashOffset: dashOffset,
          dashGap: dashGap,
          zigzagOffset: zigzagOffset,
          seed: seed,
          fillLineDash: fillLineDash,
          fillLineDashOffset: fillLineDashOffset,
          disableMultiStroke: disableMultiStroke,
          disableMultiStrokeFill: disableMultiStrokeFill,
          preserveVertices: preserveVertices,
          fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
        }), context.highPerformanceRestore();
      }
    }, {
      key: "drawShape",
      value: function drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb) {
        if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb);
      }
    }]);
    return RoughCanvasPathRender;
  }();
  RoughCanvasPathRender = __decorate$Y([injectable(), __param$x(0, inject(exports.DefaultCanvasPathRender)), __metadata$N("design:paramtypes", [Object])], RoughCanvasPathRender);

  var __decorate$X = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$M = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$w = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var RoughCanvasRectRender = /*#__PURE__*/function () {
    function RoughCanvasRectRender(canvasRenderer) {
      _classCallCheck(this, RoughCanvasRectRender);
      this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
    }
    _createClass(RoughCanvasRectRender, [{
      key: "draw",
      value: function draw(rect, renderService, drawContext, params) {
        var context = drawContext.context;
        if (!context) return;
        var canvas = context.canvas.nativeCanvas,
          rc = U.canvas(canvas);
        context.highPerformanceSave();
        var rectAttribute = getTheme(rect).rect;
        var _rect$attribute = rect.attribute,
          _rect$attribute$x = _rect$attribute.x,
          x = _rect$attribute$x === void 0 ? rectAttribute.x : _rect$attribute$x,
          _rect$attribute$y = _rect$attribute.y,
          y = _rect$attribute$y === void 0 ? rectAttribute.y : _rect$attribute$y;
        if (rect.transMatrix.onlyTranslate()) {
          var _rect$attribute2 = rect.attribute,
            _rect$attribute2$dx = _rect$attribute2.dx,
            dx = _rect$attribute2$dx === void 0 ? rectAttribute.dx : _rect$attribute2$dx,
            _rect$attribute2$dy = _rect$attribute2.dy,
            dy = _rect$attribute2$dy === void 0 ? rectAttribute.dy : _rect$attribute2$dy;
          x += dx, y += dy, context.setTransformForCurrent();
        } else x = 0, y = 0, context.transformFromMatrix(rect.transMatrix, !0);
        var _rect$attribute3 = rect.attribute,
          _rect$attribute3$fill = _rect$attribute3.fill,
          fill = _rect$attribute3$fill === void 0 ? rectAttribute.fill : _rect$attribute3$fill,
          _rect$attribute3$stro = _rect$attribute3.stroke,
          stroke = _rect$attribute3$stro === void 0 ? rectAttribute.stroke : _rect$attribute3$stro,
          _rect$attribute3$fill2 = _rect$attribute3.fillColor,
          fillColor = _rect$attribute3$fill2 === void 0 ? rectAttribute.fill : _rect$attribute3$fill2,
          _rect$attribute3$stro2 = _rect$attribute3.strokeColor,
          strokeColor = _rect$attribute3$stro2 === void 0 ? rectAttribute.stroke : _rect$attribute3$stro2,
          x1 = _rect$attribute3.x1,
          y1 = _rect$attribute3.y1,
          _rect$attribute3$line = _rect$attribute3.lineWidth,
          lineWidth = _rect$attribute3$line === void 0 ? rectAttribute.lineWidth : _rect$attribute3$line,
          _rect$attribute3$maxR = _rect$attribute3.maxRandomnessOffset,
          maxRandomnessOffset = _rect$attribute3$maxR === void 0 ? defaultRouthThemeSpec.maxRandomnessOffset : _rect$attribute3$maxR,
          _rect$attribute3$roug = _rect$attribute3.roughness,
          roughness = _rect$attribute3$roug === void 0 ? defaultRouthThemeSpec.roughness : _rect$attribute3$roug,
          _rect$attribute3$bowi = _rect$attribute3.bowing,
          bowing = _rect$attribute3$bowi === void 0 ? defaultRouthThemeSpec.bowing : _rect$attribute3$bowi,
          _rect$attribute3$curv = _rect$attribute3.curveFitting,
          curveFitting = _rect$attribute3$curv === void 0 ? defaultRouthThemeSpec.curveFitting : _rect$attribute3$curv,
          _rect$attribute3$curv2 = _rect$attribute3.curveTightness,
          curveTightness = _rect$attribute3$curv2 === void 0 ? defaultRouthThemeSpec.curveTightness : _rect$attribute3$curv2,
          _rect$attribute3$curv3 = _rect$attribute3.curveStepCount,
          curveStepCount = _rect$attribute3$curv3 === void 0 ? defaultRouthThemeSpec.curveStepCount : _rect$attribute3$curv3,
          _rect$attribute3$fill3 = _rect$attribute3.fillStyle,
          fillStyle = _rect$attribute3$fill3 === void 0 ? defaultRouthThemeSpec.fillStyle : _rect$attribute3$fill3,
          _rect$attribute3$fill4 = _rect$attribute3.fillWeight,
          fillWeight = _rect$attribute3$fill4 === void 0 ? defaultRouthThemeSpec.fillWeight : _rect$attribute3$fill4,
          _rect$attribute3$hach = _rect$attribute3.hachureAngle,
          hachureAngle = _rect$attribute3$hach === void 0 ? defaultRouthThemeSpec.hachureAngle : _rect$attribute3$hach,
          _rect$attribute3$hach2 = _rect$attribute3.hachureGap,
          hachureGap = _rect$attribute3$hach2 === void 0 ? defaultRouthThemeSpec.hachureGap : _rect$attribute3$hach2,
          _rect$attribute3$simp = _rect$attribute3.simplification,
          simplification = _rect$attribute3$simp === void 0 ? defaultRouthThemeSpec.simplification : _rect$attribute3$simp,
          _rect$attribute3$dash = _rect$attribute3.dashOffset,
          dashOffset = _rect$attribute3$dash === void 0 ? defaultRouthThemeSpec.dashOffset : _rect$attribute3$dash,
          _rect$attribute3$dash2 = _rect$attribute3.dashGap,
          dashGap = _rect$attribute3$dash2 === void 0 ? defaultRouthThemeSpec.dashGap : _rect$attribute3$dash2,
          _rect$attribute3$zigz = _rect$attribute3.zigzagOffset,
          zigzagOffset = _rect$attribute3$zigz === void 0 ? defaultRouthThemeSpec.zigzagOffset : _rect$attribute3$zigz,
          _rect$attribute3$seed = _rect$attribute3.seed,
          seed = _rect$attribute3$seed === void 0 ? defaultRouthThemeSpec.seed : _rect$attribute3$seed,
          _rect$attribute3$fill5 = _rect$attribute3.fillLineDash,
          fillLineDash = _rect$attribute3$fill5 === void 0 ? defaultRouthThemeSpec.fillLineDash : _rect$attribute3$fill5,
          _rect$attribute3$fill6 = _rect$attribute3.fillLineDashOffset,
          fillLineDashOffset = _rect$attribute3$fill6 === void 0 ? defaultRouthThemeSpec.fillLineDashOffset : _rect$attribute3$fill6,
          _rect$attribute3$disa = _rect$attribute3.disableMultiStroke,
          disableMultiStroke = _rect$attribute3$disa === void 0 ? defaultRouthThemeSpec.disableMultiStroke : _rect$attribute3$disa,
          _rect$attribute3$disa2 = _rect$attribute3.disableMultiStrokeFill,
          disableMultiStrokeFill = _rect$attribute3$disa2 === void 0 ? defaultRouthThemeSpec.disableMultiStrokeFill : _rect$attribute3$disa2,
          _rect$attribute3$pres = _rect$attribute3.preserveVertices,
          preserveVertices = _rect$attribute3$pres === void 0 ? defaultRouthThemeSpec.preserveVertices : _rect$attribute3$pres,
          _rect$attribute3$fixe = _rect$attribute3.fixedDecimalPlaceDigits,
          fixedDecimalPlaceDigits = _rect$attribute3$fixe === void 0 ? defaultRouthThemeSpec.fixedDecimalPlaceDigits : _rect$attribute3$fixe;
        var _rect$attribute4 = rect.attribute,
          _rect$attribute4$widt = _rect$attribute4.width,
          width = _rect$attribute4$widt === void 0 ? rectAttribute.width : _rect$attribute4$widt,
          _rect$attribute4$heig = _rect$attribute4.height,
          height = _rect$attribute4$heig === void 0 ? rectAttribute.height : _rect$attribute4$heig;
        width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0, rc.rectangle(x, y, width, height, {
          fill: fill ? fillColor : void 0,
          stroke: stroke ? strokeColor : void 0,
          strokeWidth: lineWidth,
          maxRandomnessOffset: maxRandomnessOffset,
          roughness: roughness,
          bowing: bowing,
          curveFitting: curveFitting,
          curveTightness: curveTightness,
          curveStepCount: curveStepCount,
          fillStyle: fillStyle,
          fillWeight: fillWeight,
          hachureAngle: hachureAngle,
          hachureGap: hachureGap,
          simplification: simplification,
          dashOffset: dashOffset,
          dashGap: dashGap,
          zigzagOffset: zigzagOffset,
          seed: seed,
          fillLineDash: fillLineDash,
          fillLineDashOffset: fillLineDashOffset,
          disableMultiStroke: disableMultiStroke,
          disableMultiStrokeFill: disableMultiStrokeFill,
          preserveVertices: preserveVertices,
          fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
        }), context.highPerformanceRestore();
      }
    }, {
      key: "drawShape",
      value: function drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb) {
        if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb);
      }
    }]);
    return RoughCanvasRectRender;
  }();
  RoughCanvasRectRender = __decorate$X([injectable(), __param$w(0, inject(exports.DefaultCanvasRectRender)), __metadata$M("design:paramtypes", [Object])], RoughCanvasRectRender);

  var __decorate$W = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$L = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$v = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var RoughCanvasSymbolRender = /*#__PURE__*/function (_BaseRender) {
    _inherits(RoughCanvasSymbolRender, _BaseRender);
    var _super = _createSuper(RoughCanvasSymbolRender);
    function RoughCanvasSymbolRender(canvasRenderer) {
      var _this;
      _classCallCheck(this, RoughCanvasSymbolRender);
      _this = _super.call(this), _this.canvasRenderer = canvasRenderer, _this.type = "symbol", _this.numberType = SYMBOL_NUMBER_TYPE, _this.style = "rough";
      return _this;
    }
    _createClass(RoughCanvasSymbolRender, [{
      key: "draw",
      value: function draw(symbol, renderService, drawContext, params) {
        var context = drawContext.context;
        if (!context) return;
        var canvas = context.canvas.nativeCanvas,
          rc = U.canvas(canvas);
        context.highPerformanceSave();
        var symbolAttribute = getTheme(symbol).symbol,
          data = this.transform(symbol, symbolAttribute, context),
          x = data.x,
          y = data.y;
          data.z;
          data.lastModelMatrix;
          var parsedPath = symbol.getParsedPath();
        if (!parsedPath) return;
        var _symbol$attribute = symbol.attribute,
          _symbol$attribute$fil = _symbol$attribute.fill,
          fill = _symbol$attribute$fil === void 0 ? symbolAttribute.fill : _symbol$attribute$fil,
          _symbol$attribute$str = _symbol$attribute.stroke,
          stroke = _symbol$attribute$str === void 0 ? symbolAttribute.stroke : _symbol$attribute$str,
          _symbol$attribute$fil2 = _symbol$attribute.fillColor,
          fillColor = _symbol$attribute$fil2 === void 0 ? symbolAttribute.fill : _symbol$attribute$fil2,
          _symbol$attribute$str2 = _symbol$attribute.strokeColor,
          strokeColor = _symbol$attribute$str2 === void 0 ? symbolAttribute.stroke : _symbol$attribute$str2,
          _symbol$attribute$siz = _symbol$attribute.size,
          size = _symbol$attribute$siz === void 0 ? symbolAttribute.size : _symbol$attribute$siz,
          _symbol$attribute$lin = _symbol$attribute.lineWidth,
          lineWidth = _symbol$attribute$lin === void 0 ? symbolAttribute.lineWidth : _symbol$attribute$lin,
          _symbol$attribute$max = _symbol$attribute.maxRandomnessOffset,
          maxRandomnessOffset = _symbol$attribute$max === void 0 ? defaultRouthThemeSpec.maxRandomnessOffset : _symbol$attribute$max,
          _symbol$attribute$rou = _symbol$attribute.roughness,
          roughness = _symbol$attribute$rou === void 0 ? defaultRouthThemeSpec.roughness : _symbol$attribute$rou,
          _symbol$attribute$bow = _symbol$attribute.bowing,
          bowing = _symbol$attribute$bow === void 0 ? defaultRouthThemeSpec.bowing : _symbol$attribute$bow,
          _symbol$attribute$cur = _symbol$attribute.curveFitting,
          curveFitting = _symbol$attribute$cur === void 0 ? defaultRouthThemeSpec.curveFitting : _symbol$attribute$cur,
          _symbol$attribute$cur2 = _symbol$attribute.curveTightness,
          curveTightness = _symbol$attribute$cur2 === void 0 ? defaultRouthThemeSpec.curveTightness : _symbol$attribute$cur2,
          _symbol$attribute$cur3 = _symbol$attribute.curveStepCount,
          curveStepCount = _symbol$attribute$cur3 === void 0 ? defaultRouthThemeSpec.curveStepCount : _symbol$attribute$cur3,
          _symbol$attribute$fil3 = _symbol$attribute.fillStyle,
          fillStyle = _symbol$attribute$fil3 === void 0 ? defaultRouthThemeSpec.fillStyle : _symbol$attribute$fil3,
          _symbol$attribute$fil4 = _symbol$attribute.fillWeight,
          fillWeight = _symbol$attribute$fil4 === void 0 ? defaultRouthThemeSpec.fillWeight : _symbol$attribute$fil4,
          _symbol$attribute$hac = _symbol$attribute.hachureAngle,
          hachureAngle = _symbol$attribute$hac === void 0 ? defaultRouthThemeSpec.hachureAngle : _symbol$attribute$hac,
          _symbol$attribute$hac2 = _symbol$attribute.hachureGap,
          hachureGap = _symbol$attribute$hac2 === void 0 ? defaultRouthThemeSpec.hachureGap : _symbol$attribute$hac2,
          _symbol$attribute$sim = _symbol$attribute.simplification,
          simplification = _symbol$attribute$sim === void 0 ? defaultRouthThemeSpec.simplification : _symbol$attribute$sim,
          _symbol$attribute$das = _symbol$attribute.dashOffset,
          dashOffset = _symbol$attribute$das === void 0 ? defaultRouthThemeSpec.dashOffset : _symbol$attribute$das,
          _symbol$attribute$das2 = _symbol$attribute.dashGap,
          dashGap = _symbol$attribute$das2 === void 0 ? defaultRouthThemeSpec.dashGap : _symbol$attribute$das2,
          _symbol$attribute$zig = _symbol$attribute.zigzagOffset,
          zigzagOffset = _symbol$attribute$zig === void 0 ? defaultRouthThemeSpec.zigzagOffset : _symbol$attribute$zig,
          _symbol$attribute$see = _symbol$attribute.seed,
          seed = _symbol$attribute$see === void 0 ? defaultRouthThemeSpec.seed : _symbol$attribute$see,
          _symbol$attribute$fil5 = _symbol$attribute.fillLineDash,
          fillLineDash = _symbol$attribute$fil5 === void 0 ? defaultRouthThemeSpec.fillLineDash : _symbol$attribute$fil5,
          _symbol$attribute$fil6 = _symbol$attribute.fillLineDashOffset,
          fillLineDashOffset = _symbol$attribute$fil6 === void 0 ? defaultRouthThemeSpec.fillLineDashOffset : _symbol$attribute$fil6,
          _symbol$attribute$dis = _symbol$attribute.disableMultiStroke,
          disableMultiStroke = _symbol$attribute$dis === void 0 ? defaultRouthThemeSpec.disableMultiStroke : _symbol$attribute$dis,
          _symbol$attribute$dis2 = _symbol$attribute.disableMultiStrokeFill,
          disableMultiStrokeFill = _symbol$attribute$dis2 === void 0 ? defaultRouthThemeSpec.disableMultiStrokeFill : _symbol$attribute$dis2,
          _symbol$attribute$pre = _symbol$attribute.preserveVertices,
          preserveVertices = _symbol$attribute$pre === void 0 ? defaultRouthThemeSpec.preserveVertices : _symbol$attribute$pre,
          _symbol$attribute$fix = _symbol$attribute.fixedDecimalPlaceDigits,
          fixedDecimalPlaceDigits = _symbol$attribute$fix === void 0 ? defaultRouthThemeSpec.fixedDecimalPlaceDigits : _symbol$attribute$fix;
        var svgPath = "";
        if (parsedPath.drawToSvgPath) svgPath = parsedPath.drawToSvgPath(size, x, y);else {
          var customPath = new CustomPath2D();
          parsedPath.draw(customPath, size, x, y) && customPath.closePath(), svgPath = customPath.toString();
        }
        rc.path(svgPath, {
          fill: fill ? fillColor : void 0,
          stroke: stroke ? strokeColor : void 0,
          strokeWidth: lineWidth,
          maxRandomnessOffset: maxRandomnessOffset,
          roughness: roughness,
          bowing: bowing,
          curveFitting: curveFitting,
          curveTightness: curveTightness,
          curveStepCount: curveStepCount,
          fillStyle: fillStyle,
          fillWeight: fillWeight,
          hachureAngle: hachureAngle,
          hachureGap: hachureGap,
          simplification: simplification,
          dashOffset: dashOffset,
          dashGap: dashGap,
          zigzagOffset: zigzagOffset,
          seed: seed,
          fillLineDash: fillLineDash,
          fillLineDashOffset: fillLineDashOffset,
          disableMultiStroke: disableMultiStroke,
          disableMultiStrokeFill: disableMultiStrokeFill,
          preserveVertices: preserveVertices,
          fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
        }), context.highPerformanceRestore();
      }
    }, {
      key: "drawShape",
      value: function drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb) {
        if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb);
      }
    }]);
    return RoughCanvasSymbolRender;
  }(BaseRender);
  RoughCanvasSymbolRender = __decorate$W([injectable(), __param$v(0, inject(exports.DefaultCanvasSymbolRender)), __metadata$L("design:paramtypes", [Object])], RoughCanvasSymbolRender);

  var _roughModule = new ContainerModule(function (bind) {
    bind(RoughCanvasCircleRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasCircleRender), bind(RoughCanvasRectRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasRectRender), bind(RoughCanvasPathRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasPathRender), bind(RoughCanvasSymbolRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasSymbolRender), bind(RoughCanvasLineRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasLineRender), bind(RoughCanvasAreaRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasAreaRender), bind(RoughCanvasArcRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasArcRender);
  });

  var REACT_TO_CANOPUS_EVENTS = {
    onPointerDown: "pointerdown",
    onPointerUp: "pointerup",
    onPointerUpOutside: "pointerupoutside",
    onPointerTap: "pointertap",
    onPointerOver: "pointerover",
    onPointerMove: "pointermove",
    onPointerEnter: "pointerenter",
    onPointerLeave: "pointerleave",
    onPointerOut: "pointerout",
    onMouseDown: "mousedown",
    onMouseUp: "mouseup",
    onMouseUpOutside: "mouseupoutside",
    onMouseMove: "mousemove",
    onMouseOver: "mouseover",
    onMouseOut: "mouseout",
    onMouseEnter: "mouseenter",
    onMouseLeave: "mouseleave",
    onPinch: "pinch",
    onPinchStart: "pinchstart",
    onPinchEnd: "pinchend",
    onPan: "pan",
    onPanStart: "panstart",
    onPanEnd: "panend",
    onDrag: "drag",
    onDragStart: "dragstart",
    onDragEnter: "dragenter",
    onDragLeave: "dragleave",
    onDragOver: "dragover",
    onDragEnd: "dragend",
    onRightDown: "rightdown",
    onRightUp: "rightup",
    onRightUpOutside: "rightupoutside",
    onTouchStart: "touchstart",
    onTouchEnd: "touchend",
    onTouchEndOutside: "touchendoutside",
    onTouchMove: "touchmove",
    onTouchCancel: "touchcancel",
    onPress: "press",
    onPressUp: "pressup",
    onPressEnd: "pressend",
    onSwipe: "swipe",
    onDrop: "drop",
    onWeel: "wheel",
    onClick: "click",
    onDblClick: "dblclick"
  };
  var REACT_TO_CANOPUS_EVENTS_LIST = Object.keys(REACT_TO_CANOPUS_EVENTS);
  function VArc(params) {
    return graphicCreator.arc(params ? params.attribute : {});
  }
  function VArc3d(params) {
    return graphicCreator.arc3d(params ? params.attribute : {});
  }
  function VArea(params) {
    return graphicCreator.area(params ? params.attribute : {});
  }
  function VCircle(params) {
    return graphicCreator.circle(params ? params.attribute : {});
  }
  function VGroup(params) {
    return graphicCreator.group(params ? params.attribute : {});
  }
  function VGlyph(params) {
    return graphicCreator.glyph(params ? params.attribute : {});
  }
  function VImage(params) {
    return graphicCreator.image(params ? params.attribute : {});
  }
  function VLine(params) {
    return graphicCreator.line(params ? params.attribute : {});
  }
  function VPath(params) {
    return graphicCreator.path(params ? params.attribute : {});
  }
  function VPolygon(params) {
    return graphicCreator.polygon(params ? params.attribute : {});
  }
  function VPyramid3d(params) {
    return graphicCreator.pyramid3d(params ? params.attribute : {});
  }
  function VRect(params) {
    return graphicCreator.rect(params ? params.attribute : {});
  }
  function VRect3d(params) {
    return graphicCreator.rect3d(params ? params.attribute : {});
  }
  function VSymbol(params) {
    return graphicCreator.symbol(params ? params.attribute : {});
  }
  function VText(params) {
    return graphicCreator.text(params ? params.attribute : {});
  }
  function VRichText(params) {
    return graphicCreator.richtext(params ? params.attribute : {});
  }
  VRichText.Text = function (params) {
    return Object.assign({
      type: "rich/text"
    }, params);
  }, VRichText.Image = function (params) {
    return Object.assign({
      type: "rich/image"
    }, params);
  };

  var __rest = undefined && undefined.__rest || function (s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
      var i = 0;
      for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
  };
  function flatten(list, out) {
    if (isArray$1(list)) return list.forEach(function (i) {
      return flatten(i, out);
    });
    out.push(list);
  }
  function jsx(type, config) {
    var _a = config || {};
      _a.key;
      _a.name;
      _a.id;
      var attribute = _a.attribute,
      stateProxy = _a.stateProxy,
      props = __rest(_a, ["key", "name", "id", "attribute", "stateProxy"]);
    var c = type;
    isString$1(type) && (c = graphicCreator[type]);
    var childrenList = [];
    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }
    children.length && flatten(1 === children.length ? children[0] : children, childrenList);
    var g = "Group" === c.name ? new c(attribute) : c(config);
    return parseToGraphic$1(g, childrenList, props), stateProxy && (g.stateProxy = stateProxy), g;
  }
  function parseToGraphic$1(g, childrenList, props) {
    var out,
      isGraphic = !1;
    switch (g.type) {
      case "richtext":
      case "rich/image":
        break;
      case "rich/text":
        out = g.attribute || {}, childrenList[0] && (out.text = childrenList[0]);
        break;
      default:
        isGraphic = !0;
    }
    isGraphic ? (childrenList.forEach(function (c) {
      c && g.add(c);
    }), Object.keys(props).forEach(function (k) {
      var en = REACT_TO_CANOPUS_EVENTS[k];
      en && g.on(en, props[k]);
    })) : "richtext" === g.type && (g.attribute.textConfig = childrenList.map(function (item) {
      return item.attribute;
    }).filter(function (item) {
      return item;
    }));
  }
  var Fragment = Group;

  function decodeReactDom(dom) {
    if (!dom || !dom.$$typeof) return dom;
    var type = dom.type,
      _dom$props = dom.props,
      attribute = _dom$props.attribute,
      children = _dom$props.children,
      stateProxy = _dom$props.stateProxy,
      id = _dom$props.id,
      name = _dom$props.name,
      g = type({
        attribute: attribute
      }),
      out = parseToGraphic(g, dom.props, children);
    return out || (stateProxy && (g.stateProxy = stateProxy), g.id = id, g.name = name, parseChildren(children, g), g);
  }
  function parseChildren(children, g) {
    isArray$1(children) ? children.forEach(function (item) {
      if (isArray$1(item)) parseChildren(item, g);else {
        var c = decodeReactDom(item);
        c && c.type && g.add(c);
      }
    }) : children && g.add(decodeReactDom(children));
  }
  function parseToGraphic(g, props, childrenList) {
    var out,
      isGraphic = !1;
    switch (g.type) {
      case "richtext":
        break;
      case "rich/text":
        out = g.attribute || {}, childrenList && (out.text = childrenList), g.attribute = out;
        break;
      case "rich/image":
        out = g.attribute || {};
        break;
      default:
        isGraphic = !0;
    }
    return isGraphic ? Object.keys(props).forEach(function (k) {
      var en = REACT_TO_CANOPUS_EVENTS[k];
      en && g.on(en, props[k]);
    }) : "richtext" === g.type && (g.attribute.textConfig = childrenList.map(function (item) {
      return decodeReactDom(item);
    }).filter(function (item) {
      return item;
    })), out;
  }

  var DragNDrop = /*#__PURE__*/function () {
    function DragNDrop(rootNode) {
      var _this = this;
      _classCallCheck(this, DragNDrop);
      this.onPointerDown = function (event) {
        var target = event.target,
          rootNode = _this.rootNode,
          isRoot = target === rootNode;
        if (target && !isRoot) {
          var handlePointerMove = function handlePointerMove(moveEvent) {
            if (dragstartTriggered || (moveEvent.type = "dragstart", null == target || target.dispatchEvent(moveEvent), dragstartTriggered = !0), moveEvent.type = "drag", null == target || target.dispatchEvent(moveEvent), !isRoot) {
              target.pickable = !1;
              var elemBelow = (null == rootNode ? void 0 : rootNode.pick(moveEvent.global.x, moveEvent.global.y)).graphic;
              target.pickable = !0, currentDroppable !== elemBelow && (currentDroppable && (moveEvent.type = "dragleave", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)), elemBelow && (moveEvent.type = "dragenter", moveEvent.target = elemBelow, elemBelow.dispatchEvent(moveEvent)), currentDroppable = elemBelow, currentDroppable && (moveEvent.type = "dragover", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)));
            }
          };
          var currentDroppable,
            dragstartTriggered = !1;
          null == rootNode || rootNode.addEventListener("pointermove", handlePointerMove);
          var stopDragging = function stopDragging() {
            dragstartTriggered && (currentDroppable && (event.type = "drop", event.target = currentDroppable, currentDroppable.dispatchEvent(event)), event.type = "dragend", target.dispatchEvent(event), dragstartTriggered = !1), null == rootNode || rootNode.removeEventListener("pointermove", handlePointerMove);
          };
          target.addEventListener("pointerup", stopDragging, {
            once: !0
          }), target.addEventListener("pointerupoutside", stopDragging, {
            once: !0
          });
        }
      }, this.rootNode = rootNode, this.initEvents();
    }
    _createClass(DragNDrop, [{
      key: "initEvents",
      value: function initEvents() {
        var _a;
        null === (_a = this.rootNode) || void 0 === _a || _a.addEventListener("pointerdown", this.onPointerDown);
      }
    }, {
      key: "removeEvents",
      value: function removeEvents() {
        var _a;
        null === (_a = this.rootNode) || void 0 === _a || _a.removeEventListener("pointerdown", this.onPointerDown);
      }
    }, {
      key: "release",
      value: function release() {
        this.removeEvents(), this.rootNode = null;
      }
    }]);
    return DragNDrop;
  }();

  var calcDirection = function calcDirection(start, end) {
      var xDistance = end.x - start.x,
        yDistance = end.y - start.y;
      return Math.abs(xDistance) > Math.abs(yDistance) ? xDistance > 0 ? "right" : "left" : yDistance > 0 ? "down" : "up";
    },
    calcDistance = function calcDistance(point1, point2) {
      var xDistance = Math.abs(point2.x - point1.x),
        yDistance = Math.abs(point2.y - point1.y);
      return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
    },
    getCenter = function getCenter(points) {
      var pointersLength = points.length;
      if (1 === pointersLength) return {
        x: Math.round(points[0].x),
        y: Math.round(points[0].y)
      };
      var x = 0,
        y = 0,
        i = 0;
      for (; i < pointersLength;) x += points[i].x, y += points[i].y, i++;
      return {
        x: Math.round(x / pointersLength),
        y: Math.round(y / pointersLength)
      };
    };
  var Gesture = /*#__PURE__*/function (_EventEmitter) {
    _inherits(Gesture, _EventEmitter);
    var _super = _createSuper(Gesture);
    function Gesture(element) {
      var _this;
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _classCallCheck(this, Gesture);
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      _this = _super.call(this), _this.cachedEvents = [], _this.startPoints = [], _this.processEvent = {}, _this.throttleTimer = 0, _this.emitThrottles = [], _this.lastTapTarget = null, _this.onStart = function (ev) {
        _this.reset(), _this.startTime = clock.now();
        var _assertThisInitialize = _assertThisInitialized(_this),
          cachedEvents = _assertThisInitialize.cachedEvents,
          startPoints = _assertThisInitialize.startPoints;
        ev && cachedEvents.push(ev.clone()), startPoints.length = cachedEvents.length;
        for (var i = 0; i < cachedEvents.length; i++) {
          var _cachedEvents$i = cachedEvents[i],
            x = _cachedEvents$i.x,
            y = _cachedEvents$i.y,
            point = {
              x: x,
              y: y
            };
          startPoints[i] = point;
        }
        if (1 !== startPoints.length) _this.startDistance = calcDistance(startPoints[0], startPoints[1]), _this.center = getCenter([startPoints[0], startPoints[1]]);else {
          var event = cachedEvents[0];
          _this.pressTimeout = setTimeout(function () {
            event.direction = "none", event.deltaX = 0, event.deltaY = 0, event.points = startPoints, _this.triggerStartEvent("press", event), _this.triggerEvent("press", event), _this.eventType = "press", _this.direction = "none";
          }, _this.config.press.time);
        }
      }, _this.onMove = function (ev) {
        _this.clearPressTimeout();
        var _assertThisInitialize2 = _assertThisInitialized(_this),
          startPoints = _assertThisInitialize2.startPoints,
          cachedEvents = _assertThisInitialize2.cachedEvents;
        if (!startPoints.length) return;
        var moveEvent = ev.clone(),
          x = moveEvent.x,
          y = moveEvent.y,
          pointerId = moveEvent.pointerId;
        for (var i = 0, len = cachedEvents.length; i < len; i++) if (pointerId === cachedEvents[i].pointerId) {
          cachedEvents[i] = moveEvent;
          break;
        }
        var point = {
            x: x,
            y: y
          },
          points = cachedEvents.map(function (cachedEvent) {
            return {
              x: cachedEvent.x,
              y: cachedEvent.y
            };
          }),
          now = clock.now();
        if (_this.prevMoveTime = _this.lastMoveTime, _this.prevMovePoint = _this.lastMovePoint, _this.lastMoveTime = now, _this.lastMovePoint = point, 1 === startPoints.length) {
          var startPoint = startPoints[0],
            deltaX = x - startPoint.x,
            deltaY = y - startPoint.y,
            direction = _this.direction || calcDirection(startPoint, point);
          _this.direction = direction;
          var eventType = _this.getEventType(point);
          return moveEvent.direction = direction, moveEvent.deltaX = deltaX, moveEvent.deltaY = deltaY, moveEvent.points = points, _this.triggerStartEvent(eventType, moveEvent), void _this.triggerEvent(eventType, moveEvent);
        }
        var _assertThisInitialize3 = _assertThisInitialized(_this),
          startDistance = _assertThisInitialize3.startDistance,
          currentDistance = calcDistance(points[0], points[1]);
        moveEvent.scale = currentDistance / startDistance, moveEvent.center = _this.center, moveEvent.points = points, _this.triggerStartEvent("pinch", moveEvent), _this.triggerEvent("pinch", moveEvent);
      }, _this.onEnd = function (ev) {
        var endEvent = ev.clone(),
          _assertThisInitialize4 = _assertThisInitialized(_this),
          cachedEvents = _assertThisInitialize4.cachedEvents,
          startPoints = _assertThisInitialize4.startPoints,
          points = cachedEvents.map(function (ev) {
            return {
              x: ev.x,
              y: ev.y
            };
          });
        if (endEvent.points = points, _this.triggerEndEvent(endEvent), 1 === cachedEvents.length) {
          var now = clock.now(),
            lastMoveTime = _this.lastMoveTime;
          if (now - lastMoveTime < 100) {
            var intervalTime = lastMoveTime - (_this.prevMoveTime || _this.startTime);
            if (intervalTime > 0) {
              var prevMovePoint = _this.prevMovePoint || startPoints[0],
                lastMovePoint = _this.lastMovePoint || startPoints[0],
                distance = calcDistance(prevMovePoint, lastMovePoint),
                velocity = distance / intervalTime;
              velocity > _this.config.swipe.velocity && distance > _this.config.swipe.threshold && (endEvent.velocity = velocity, endEvent.direction = calcDirection(prevMovePoint, lastMovePoint), _this.triggerEvent("swipe", endEvent));
            }
          }
          now - _this.lastTapTime < _this.config.tap.interval && ev.target === _this.lastTapTarget ? _this.tapCount++ : _this.tapCount = 1, _this.lastTapTime = now, _this.lastTapTarget = ev.target, 1 === _this.tapCount ? _this.triggerEvent("tap", endEvent) : 2 === _this.tapCount && (_this.triggerEvent("doubletap", endEvent), _this.tapCount = 0);
        }
        for (var i = 0, len = cachedEvents.length; i < len; i++) if (cachedEvents[i].pointerId === endEvent.pointerId) {
          cachedEvents.splice(i, 1), startPoints.splice(i, 1);
          break;
        }
        _this.reset(), cachedEvents.length > 0 && _this.onStart();
      }, _this.element = element, _this.tapCount = 0, _this.lastTapTime = 0, _this.config = {
        press: {
          time: null !== (_b = null === (_a = null == config ? void 0 : config.press) || void 0 === _a ? void 0 : _a.time) && void 0 !== _b ? _b : 251,
          threshold: null !== (_d = null === (_c = null == config ? void 0 : config.press) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 9
        },
        swipe: {
          threshold: null !== (_f = null === (_e = null == config ? void 0 : config.swipe) || void 0 === _e ? void 0 : _e.threshold) && void 0 !== _f ? _f : 10,
          velocity: null !== (_h = null === (_g = null == config ? void 0 : config.swipe) || void 0 === _g ? void 0 : _g.velocity) && void 0 !== _h ? _h : .3
        },
        tap: {
          interval: null !== (_k = null === (_j = null == config ? void 0 : config.tap) || void 0 === _j ? void 0 : _j.interval) && void 0 !== _k ? _k : 300
        }
      }, _this.initEvents();
      return _this;
    }
    _createClass(Gesture, [{
      key: "initEvents",
      value: function initEvents() {
        var element = this.element;
        element && (element.addEventListener("pointerdown", this.onStart), element.addEventListener("pointermove", this.onMove), element.addEventListener("pointerup", this.onEnd), element.addEventListener("pointerupoutside", this.onEnd));
      }
    }, {
      key: "removeEvents",
      value: function removeEvents() {
        var element = this.element;
        element && (element.removeEventListener("pointerdown", this.onStart), element.removeEventListener("pointermove", this.onMove), element.removeEventListener("pointerup", this.onEnd), element.removeEventListener("pointerupoutside", this.onEnd));
      }
    }, {
      key: "release",
      value: function release() {
        this.removeEvents(), this.element = null;
      }
    }, {
      key: "getEventType",
      value: function getEventType(point) {
        var eventType = this.eventType,
          startTime = this.startTime,
          startPoints = this.startPoints;
        if (eventType) return eventType;
        var type;
        return type = clock.now() - startTime > this.config.press.time && calcDistance(startPoints[0], point) < this.config.press.threshold ? "press" : "pan", this.eventType = type, type;
      }
    }, {
      key: "enable",
      value: function enable(eventType) {
        this.processEvent[eventType] = !0;
      }
    }, {
      key: "isProcess",
      value: function isProcess(eventType) {
        return this.processEvent[eventType];
      }
    }, {
      key: "pushEvent",
      value: function pushEvent(type, ev) {
        var emitThrottles = this.emitThrottles,
          newEvent = {
            type: type,
            ev: ev
          };
        for (var i = 0, len = emitThrottles.length; i < len; i++) if (emitThrottles[i].type === type) return void emitThrottles.splice(i, 1, newEvent);
        emitThrottles.push(newEvent);
      }
    }, {
      key: "clearPressTimeout",
      value: function clearPressTimeout() {
        this.pressTimeout && (clearTimeout(this.pressTimeout), this.pressTimeout = null);
      }
    }, {
      key: "reset",
      value: function reset() {
        this.clearPressTimeout(), this.startTime = 0, this.startDistance = 0, this.direction = null, this.eventType = null, this.prevMoveTime = 0, this.prevMovePoint = null, this.lastMoveTime = 0, this.lastMovePoint = null;
      }
    }, {
      key: "triggerEvent",
      value: function triggerEvent(type, ev) {
        var _this2 = this;
        this.pushEvent(type, ev);
        var throttleTimer = this.throttleTimer,
          emitThrottles = this.emitThrottles;
        throttleTimer || (this.throttleTimer = application.global.getRequestAnimationFrame()(function () {
          for (var i = 0, len = emitThrottles.length; i < len; i++) {
            var _emitThrottles$i = emitThrottles[i],
              _type = _emitThrottles$i.type,
              _ev = _emitThrottles$i.ev;
            _this2.emitEvent(_type, _ev);
          }
          _this2.throttleTimer = 0, _this2.emitThrottles.length = 0;
        }));
      }
    }, {
      key: "triggerStartEvent",
      value: function triggerStartEvent(type, ev) {
        this.isProcess(type) || (this.enable(type), this.triggerEvent("".concat(type, "start"), ev));
      }
    }, {
      key: "triggerEndEvent",
      value: function triggerEndEvent(ev) {
        var _this3 = this;
        var processEvent = this.processEvent;
        Object.keys(processEvent).forEach(function (type) {
          _this3.triggerEvent("".concat(type, "end"), ev), "press" === type && _this3.triggerEvent("".concat(type, "up"), ev), delete processEvent[type];
        });
      }
    }, {
      key: "emitEvent",
      value: function emitEvent(type, e) {
        var listeners = this.element._events[WILDCARD];
        if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);else for (var i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
        this.emit(type, e);
      }
    }]);
    return Gesture;
  }(EventEmitter);

  var __decorate$V = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$K = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var outP = [0, 0, 0],
    addArcToBezierPath = function addArcToBezierPath(bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) {
      if (clockwise) for (; endAngle > startAngle;) endAngle -= pi2;else for (; endAngle < startAngle;) endAngle += pi2;
      var step = pi / 3 * (endAngle > startAngle ? 1 : -1);
      var sa = startAngle,
        ea = sa;
      for (; ea !== endAngle;) {
        ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);
        var delta = Math.abs(ea - sa),
          len = 4 * Math.tan(delta / 4) / 3,
          dir = ea < sa ? -1 : 1,
          c1 = Math.cos(sa),
          s1 = Math.sin(sa),
          c2 = Math.cos(ea),
          s2 = Math.sin(ea),
          x1 = c1 * rx + cx,
          y1 = s1 * ry + cy,
          x4 = c2 * rx + cx,
          y4 = s2 * ry + cy,
          hx = rx * len * dir,
          hy = ry * len * dir;
        bezierPath.push([x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4]), sa = ea;
      }
    };
  var BrowserContext2d = /*#__PURE__*/function () {
    function BrowserContext2d(canvas, dpr) {
      _classCallCheck(this, BrowserContext2d);
      this.fillAttributes = Object.assign(Object.assign({}, DefaultFillStyle), {
        opacity: 1
      }), this.strokeAttributes = Object.assign(Object.assign({}, DefaultStrokeStyle), {
        opacity: 1
      }), this.textAttributes = Object.assign(Object.assign({}, DefaultTextStyle), {
        opacity: 1
      }), this._clearShadowStyle = !1, this._clearFilterStyle = !1, this._clearGlobalCompositeOperationStyle = !1;
      var context = canvas.nativeCanvas.getContext("2d");
      if (!context) throw new Error("发生错误，获取2d上下文失败");
      this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    }
    _createClass(BrowserContext2d, [{
      key: "fillStyle",
      get: function get() {
        return this.nativeContext.fillStyle;
      },
      set: function set(d) {
        this.nativeContext.fillStyle = d;
      }
    }, {
      key: "font",
      get: function get() {
        return this.nativeContext.font;
      },
      set: function set(d) {
        this.nativeContext.font = d;
      }
    }, {
      key: "globalAlpha",
      get: function get() {
        return this.nativeContext.globalAlpha;
      },
      set: function set(d) {
        this.nativeContext.globalAlpha = d;
      }
    }, {
      key: "lineCap",
      get: function get() {
        return this.nativeContext.lineCap;
      },
      set: function set(d) {
        this.nativeContext.lineCap = d;
      }
    }, {
      key: "lineDashOffset",
      get: function get() {
        return this.nativeContext.lineDashOffset;
      },
      set: function set(d) {
        this.nativeContext.lineDashOffset = d;
      }
    }, {
      key: "lineJoin",
      get: function get() {
        return this.nativeContext.lineJoin;
      },
      set: function set(d) {
        this.nativeContext.lineJoin = d;
      }
    }, {
      key: "lineWidth",
      get: function get() {
        return this.nativeContext.lineWidth;
      },
      set: function set(d) {
        this.nativeContext.lineWidth = d;
      }
    }, {
      key: "miterLimit",
      get: function get() {
        return this.nativeContext.miterLimit;
      },
      set: function set(d) {
        this.nativeContext.miterLimit = d;
      }
    }, {
      key: "shadowBlur",
      get: function get() {
        return this.nativeContext.shadowBlur;
      },
      set: function set(d) {
        this.nativeContext.shadowBlur = d;
      }
    }, {
      key: "shadowColor",
      get: function get() {
        return this.nativeContext.shadowColor;
      },
      set: function set(d) {
        this.nativeContext.shadowColor = d;
      }
    }, {
      key: "shadowOffsetX",
      get: function get() {
        return this.nativeContext.shadowOffsetX;
      },
      set: function set(d) {
        this.nativeContext.shadowOffsetX = d;
      }
    }, {
      key: "shadowOffsetY",
      get: function get() {
        return this.nativeContext.shadowOffsetY;
      },
      set: function set(d) {
        this.nativeContext.shadowOffsetY = d;
      }
    }, {
      key: "strokeStyle",
      get: function get() {
        return this.nativeContext.strokeStyle;
      },
      set: function set(d) {
        this.nativeContext.strokeStyle = d;
      }
    }, {
      key: "textAlign",
      get: function get() {
        return this.nativeContext.textAlign;
      },
      set: function set(d) {
        this.nativeContext.textAlign = d;
      }
    }, {
      key: "textBaseline",
      get: function get() {
        return this.nativeContext.textBaseline;
      },
      set: function set(d) {
        this.nativeContext.textBaseline = d;
      }
    }, {
      key: "inuse",
      get: function get() {
        return !!this._inuse;
      },
      set: function set(use) {
        use !== !!this._inuse && (this._inuse = use, use ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());
      }
    }, {
      key: "reset",
      value: function reset() {
        this.stack.length && Logger.getInstance().warn("可能存在bug，matrix没有清空"), this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0, this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
      }
    }, {
      key: "getCanvas",
      value: function getCanvas() {
        return this.canvas;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.nativeContext;
      }
    }, {
      key: "setTransformForCurrent",
      value: function setTransformForCurrent() {
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
        !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f), this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f));
      }
    }, {
      key: "currentMatrix",
      get: function get() {
        return this.matrix;
      }
    }, {
      key: "cloneMatrix",
      value: function cloneMatrix(m) {
        return matrixAllocate.allocateByObj(m);
      }
    }, {
      key: "clear",
      value: function clear() {
        this.save(), this.resetTransform(), this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height), this.restore();
      }
    }, {
      key: "restore",
      value: function restore() {
        this.nativeContext.restore(), this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent(!0));
      }
    }, {
      key: "highPerformanceRestore",
      value: function highPerformanceRestore() {
        this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
      }
    }, {
      key: "rotate",
      value: function rotate(rad) {
        var setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "save",
      value: function save() {
        var matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix), this.nativeContext.save();
      }
    }, {
      key: "highPerformanceSave",
      value: function highPerformanceSave() {
        var matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
      }
    }, {
      key: "scale",
      value: function scale(sx, sy) {
        var setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "setScale",
      value: function setScale(sx, sy) {
        var setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "scalePoint",
      value: function scalePoint(sx, sy, px, py) {
        var setTransform = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;
        this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "setTransform",
      value: function setTransform(a, b, c, d, e, f) {
        var _setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
        var dpr = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this.dpr;
        this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), _setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "setTransformFromMatrix",
      value: function setTransformFromMatrix(matrix) {
        var setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        var dpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dpr;
        this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "resetTransform",
      value: function resetTransform() {
        var setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        var dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
        this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "transform",
      value: function transform(a, b, c, d, e, f) {
        var setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
        this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "transformFromMatrix",
      value: function transformFromMatrix(matrix, setTransform) {
        this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "translate",
      value: function translate(x, y) {
        var setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
        this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "rotateDegrees",
      value: function rotateDegrees(deg) {
        var setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
        var rad = deg * Math.PI / 180;
        this.rotate(rad, setTransform);
      }
    }, {
      key: "rotateAbout",
      value: function rotateAbout(rad, x, y) {
        var setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
        this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "rotateDegreesAbout",
      value: function rotateDegreesAbout(deg, x, y) {
        var setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
        this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
      }
    }, {
      key: "beginPath",
      value: function beginPath() {
        this.disableBeginPath || this.nativeContext.beginPath();
      }
    }, {
      key: "clip",
      value: function clip(path, fillRule) {
        path ? "string" == typeof path ? this.nativeContext.clip(path) : this.nativeContext.clip(path, fillRule) : this.nativeContext.clip();
      }
    }, {
      key: "arc",
      value: function arc(x, y, radius, startAngle, endAngle, anticlockwise, z) {
        if (z = z || 0, this.camera) {
          var arr = [];
          addArcToBezierPath(arr, startAngle, endAngle, x, y, radius, radius, anticlockwise);
          for (var i = 0; i < arr.length; ++i) {
            var bez = arr[i];
            this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z);
          }
        } else this.nativeContext.arc(x, y, radius, startAngle, endAngle, anticlockwise);
      }
    }, {
      key: "arcTo",
      value: function arcTo(x1, y1, x2, y2, radiusX) {
        this.nativeContext.arcTo(x1, y1, x2, y2, radiusX);
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, z) {
        if (z = z || 0, this.camera) {
          var cp1z = z,
            cp2z = z;
          this.modelMatrix && (transformMat4(outP, [cp1x, cp1y, z], this.modelMatrix), cp1x = outP[0], cp1y = outP[1], cp1z = outP[2], transformMat4(outP, [cp2x, cp2y, z], this.modelMatrix), cp2x = outP[0], cp2y = outP[1], cp2z = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          var data = this.camera.vp(x, y, z);
          x = data.x, y = data.y, data = this.camera.vp(cp1x, cp1y, cp1z), cp1x = data.x, cp1y = data.y, data = this.camera.vp(cp2x, cp2y, cp2z), cp2x = data.x, cp2y = data.y;
        }
        this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      }
    }, {
      key: "closePath",
      value: function closePath() {
        this.nativeContext.closePath();
      }
    }, {
      key: "ellipse",
      value: function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        null == anticlockwise ? this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) : this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          var data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        this.nativeContext.lineTo(x, y);
      }
    }, {
      key: "moveTo",
      value: function moveTo(x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          var data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        this.nativeContext.moveTo(x, y);
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(cpx, cpy, x, y, z) {
        if (z = z || 0, this.camera) {
          var cpz = z;
          this.modelMatrix && (transformMat4(outP, [cpx, cpy, z], this.modelMatrix), cpx = outP[0], cpy = outP[1], cpz = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          var data = this.camera.vp(x, y, z);
          x = data.x, y = data.y, data = this.camera.vp(cpx, cpy, cpz), cpx = data.x, cpy = data.y;
        }
        this.nativeContext.quadraticCurveTo(cpx, cpy, x, y);
      }
    }, {
      key: "rect",
      value: function rect(x, y, w, h, z) {
        z = z || 0, this.camera ? (this.moveTo(x, y, z), this.lineTo(x + w, y, z), this.lineTo(x + w, y + h, z), this.lineTo(x, y + h, z), this.closePath()) : this.nativeContext.rect(x, y, w, h);
      }
    }, {
      key: "createImageData",
      value: function createImageData() {
        var a = arguments;
        return 2 === a.length ? this.nativeContext.createImageData(a[0], a[1]) : 1 === a.length ? this.nativeContext.createImageData(a[0]) : null;
      }
    }, {
      key: "createLinearGradient",
      value: function createLinearGradient(x0, y0, x1, y1) {
        return this.nativeContext.createLinearGradient(x0, y0, x1, y1);
      }
    }, {
      key: "createPattern",
      value: function createPattern(image, repetition) {
        return 0 === image.width || 0 === image.height ? null : this.nativeContext.createPattern(image, repetition);
      }
    }, {
      key: "createRadialGradient",
      value: function createRadialGradient(x0, y0, r0, x1, y1, r1) {
        return this.nativeContext.createRadialGradient(x0, y0, r0, x1, y1, r1);
      }
    }, {
      key: "createConicGradient",
      value: function createConicGradient(x, y, startAngle, endAngle) {
        var pattern,
          edit = !1;
        var ctx = this;
        return {
          stops: [],
          addColorStop: function addColorStop(offset, color) {
            this.stops.push([offset, color]), edit = !0;
          },
          GetPattern: function GetPattern(minW, minH, deltaAngle) {
            return edit && (deltaAngle || (deltaAngle = endAngle - startAngle), pattern = createConicalGradient(ctx, this.stops, x, y, deltaAngle, startAngle, endAngle, minW, minH), edit = !1), pattern;
          }
        };
      }
    }, {
      key: "fill",
      value: function fill(path, fillRule) {
        this.disableFill || (path ? this.nativeContext.fill(path) : this.nativeContext.fill());
      }
    }, {
      key: "fillRect",
      value: function fillRect(x, y, width, height) {
        this.nativeContext.fillRect(x, y, width, height);
      }
    }, {
      key: "clearRect",
      value: function clearRect(x, y, w, h) {
        this.nativeContext.clearRect(x, y, w, h);
      }
    }, {
      key: "project",
      value: function project(x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          var data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        return {
          x: x,
          y: y
        };
      }
    }, {
      key: "view",
      value: function view(x, y, z) {
        return z = z || 0, this.camera ? (this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]), this.camera.view(x, y, z)) : [x, y, z];
      }
    }, {
      key: "fillText",
      value: function fillText(text, x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          var data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        this.nativeContext.fillText(text, x, y);
      }
    }, {
      key: "getImageData",
      value: function getImageData(sx, sy, sw, sh) {
        return this.nativeContext.getImageData(sx, sy, sw, sh);
      }
    }, {
      key: "getLineDash",
      value: function getLineDash() {
        return this.nativeContext.getLineDash();
      }
    }, {
      key: "isPointInPath",
      value: function isPointInPath(x, y) {
        return this.nativeContext.isPointInPath(x, y);
      }
    }, {
      key: "isPointInStroke",
      value: function isPointInStroke(x, y) {
        return this.nativeContext.isPointInStroke(x, y);
      }
    }, {
      key: "measureText",
      value: function measureText(text) {
        var _this = this;
        var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : application.global.measureTextMethod;
        var _a, _b;
        if (!method || "native" === method) return this.nativeContext.measureText(text);
        this.mathTextMeasure || (this.mathTextMeasure = application.graphicUtil.createTextMeasureInstance({}, {}, function () {
          return _this.canvas.nativeCanvas;
        }));
        var fontFamily = null !== (_a = this.fontFamily) && void 0 !== _a ? _a : DefaultTextStyle.fontFamily,
          fontSize = null !== (_b = this.fontSize) && void 0 !== _b ? _b : DefaultTextStyle.fontSize;
        return this.mathTextMeasure.textSpec.fontFamily === fontFamily && this.mathTextMeasure.textSpec.fontSize === fontSize || (this.mathTextMeasure.textSpec.fontFamily = fontFamily, this.mathTextMeasure.textSpec.fontSize = fontSize, this.mathTextMeasure._numberCharSize = null, this.mathTextMeasure._fullCharSize = null, this.mathTextMeasure._letterCharSize = null, this.mathTextMeasure._specialCharSizeMap = {}), this.mathTextMeasure.measure(text, method);
      }
    }, {
      key: "putImageData",
      value: function putImageData(imagedata, dx, dy) {
        this.nativeContext.putImageData(imagedata, dx, dy);
      }
    }, {
      key: "setLineDash",
      value: function setLineDash(segments) {
        var a = arguments,
          _context = this.nativeContext;
        this.nativeContext.setLineDash ? _context.setLineDash(a[0]) : "mozDash" in _context ? _context.mozDash = a[0] : "webkitLineDash" in _context && (_context.webkitLineDash = a[0]);
      }
    }, {
      key: "stroke",
      value: function stroke(path) {
        this.disableStroke || (path ? this.nativeContext.stroke(path) : this.nativeContext.stroke());
      }
    }, {
      key: "strokeRect",
      value: function strokeRect(x, y, width, height) {
        this.nativeContext.strokeRect(x, y, width, height);
      }
    }, {
      key: "strokeText",
      value: function strokeText(text, x, y, z) {
        if (z = z || 0, this.camera) {
          this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
          var data = this.camera.vp(x, y, z);
          x = data.x, y = data.y;
        }
        this.nativeContext.strokeText(text, x, y);
      }
    }, {
      key: "drawImage",
      value: function drawImage() {
        var _context = this.nativeContext,
          a = arguments;
        3 === a.length ? _context.drawImage(a[0], a[1], a[2]) : 5 === a.length ? _context.drawImage(a[0], a[1], a[2], a[3], a[4]) : 9 === a.length && _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
      }
    }, {
      key: "setCommonStyle",
      value: function setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
        if (Array.isArray(defaultParams)) {
          if (defaultParams.length <= 1) return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
          var dp = Object.create(defaultParams[0]);
          return defaultParams.forEach(function (p, i) {
            0 !== i && Object.assign(dp, p);
          }), this._setCommonStyle(params, attribute, offsetX, offsetY, dp);
        }
        return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams);
      }
    }, {
      key: "_setCommonStyle",
      value: function _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.fillAttributes);
        var _attribute$fillOpacit = attribute.fillOpacity,
          fillOpacity = _attribute$fillOpacit === void 0 ? defaultParams.fillOpacity : _attribute$fillOpacit,
          _attribute$opacity = attribute.opacity,
          opacity = _attribute$opacity === void 0 ? defaultParams.opacity : _attribute$opacity,
          _attribute$fill = attribute.fill,
          fill = _attribute$fill === void 0 ? defaultParams.fill : _attribute$fill;
        fillOpacity > 1e-12 && opacity > 1e-12 ? (_context.globalAlpha = fillOpacity * opacity, _context.fillStyle = createColor(this, fill, params, offsetX, offsetY)) : _context.globalAlpha = fillOpacity * opacity;
      }
    }, {
      key: "setShadowBlendStyle",
      value: function setShadowBlendStyle(params, attribute, defaultParams) {
        if (Array.isArray(defaultParams)) {
          if (defaultParams.length <= 1) return this._setShadowBlendStyle(params, defaultParams[0]);
          var dp = Object.create(defaultParams[0]);
          return defaultParams.forEach(function (p, i) {
            0 !== i && Object.assign(dp, p);
          }), this._setShadowBlendStyle(params, attribute, dp);
        }
        return this._setShadowBlendStyle(params, attribute, defaultParams);
      }
    }, {
      key: "_setShadowBlendStyle",
      value: function _setShadowBlendStyle(params, attribute, defaultParams) {
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.fillAttributes);
        var _attribute$opacity2 = attribute.opacity,
          opacity = _attribute$opacity2 === void 0 ? defaultParams.opacity : _attribute$opacity2,
          _attribute$shadowBlur = attribute.shadowBlur,
          shadowBlur = _attribute$shadowBlur === void 0 ? defaultParams.shadowBlur : _attribute$shadowBlur,
          _attribute$shadowColo = attribute.shadowColor,
          shadowColor = _attribute$shadowColo === void 0 ? defaultParams.shadowColor : _attribute$shadowColo,
          _attribute$shadowOffs = attribute.shadowOffsetX,
          shadowOffsetX = _attribute$shadowOffs === void 0 ? defaultParams.shadowOffsetX : _attribute$shadowOffs,
          _attribute$shadowOffs2 = attribute.shadowOffsetY,
          shadowOffsetY = _attribute$shadowOffs2 === void 0 ? defaultParams.shadowOffsetY : _attribute$shadowOffs2,
          _attribute$blur = attribute.blur,
          blur = _attribute$blur === void 0 ? defaultParams.blur : _attribute$blur,
          _attribute$globalComp = attribute.globalCompositeOperation,
          globalCompositeOperation = _attribute$globalComp === void 0 ? defaultParams.globalCompositeOperation : _attribute$globalComp;
        opacity <= 1e-12 || (shadowBlur || shadowOffsetX || shadowOffsetY ? (_context.shadowBlur = shadowBlur * this.dpr, _context.shadowColor = shadowColor, _context.shadowOffsetX = shadowOffsetX * this.dpr, _context.shadowOffsetY = shadowOffsetY * this.dpr, this._clearShadowStyle = !0) : this._clearShadowStyle && (_context.shadowBlur = 0, _context.shadowOffsetX = 0, _context.shadowOffsetY = 0), blur ? (_context.filter = "blur(".concat(blur, "px)"), this._clearFilterStyle = !0) : this._clearFilterStyle && (_context.filter = "blur(0px)", this._clearFilterStyle = !1), globalCompositeOperation ? (_context.globalCompositeOperation = globalCompositeOperation, this._clearGlobalCompositeOperationStyle = !0) : this._clearGlobalCompositeOperationStyle && (_context.globalCompositeOperation = "source-over", this._clearGlobalCompositeOperationStyle = !1));
      }
    }, {
      key: "setStrokeStyle",
      value: function setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        if (Array.isArray(defaultParams)) {
          if (defaultParams.length <= 1) return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
          var dp = Object.create(defaultParams[0]);
          return defaultParams.forEach(function (p, i) {
            0 !== i && Object.assign(dp, p);
          }), this._setStrokeStyle(params, attribute, offsetX, offsetY, dp);
        }
        return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams);
      }
    }, {
      key: "_setStrokeStyle",
      value: function _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.strokeAttributes);
        var _attribute$strokeOpac = attribute.strokeOpacity,
          strokeOpacity = _attribute$strokeOpac === void 0 ? defaultParams.strokeOpacity : _attribute$strokeOpac,
          _attribute$opacity3 = attribute.opacity,
          opacity = _attribute$opacity3 === void 0 ? defaultParams.opacity : _attribute$opacity3;
        if (strokeOpacity > 1e-12 && opacity > 1e-12) {
          var _attribute$lineWidth = attribute.lineWidth,
            lineWidth = _attribute$lineWidth === void 0 ? defaultParams.lineWidth : _attribute$lineWidth,
            _attribute$stroke = attribute.stroke,
            stroke = _attribute$stroke === void 0 ? defaultParams.stroke : _attribute$stroke,
            _attribute$lineJoin = attribute.lineJoin,
            lineJoin = _attribute$lineJoin === void 0 ? defaultParams.lineJoin : _attribute$lineJoin,
            _attribute$lineDash = attribute.lineDash,
            lineDash = _attribute$lineDash === void 0 ? defaultParams.lineDash : _attribute$lineDash,
            _attribute$lineCap = attribute.lineCap,
            lineCap = _attribute$lineCap === void 0 ? defaultParams.lineCap : _attribute$lineCap,
            _attribute$miterLimit = attribute.miterLimit,
            miterLimit = _attribute$miterLimit === void 0 ? defaultParams.miterLimit : _attribute$miterLimit;
          _context.globalAlpha = strokeOpacity * opacity, _context.lineWidth = getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke, params, offsetX, offsetY), _context.lineJoin = lineJoin, _context.setLineDash(lineDash), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
        }
      }
    }, {
      key: "setTextStyleWithoutAlignBaseline",
      value: function setTextStyleWithoutAlignBaseline(params, defaultParams, z) {
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes);
        var _params$scaleIn3d = params.scaleIn3d,
          scaleIn3d = _params$scaleIn3d === void 0 ? defaultParams.scaleIn3d : _params$scaleIn3d;
        params.font ? _context.font = params.font : _context.font = getContextFont(params, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z));
        var _params$fontFamily = params.fontFamily,
          fontFamily = _params$fontFamily === void 0 ? defaultParams.fontFamily : _params$fontFamily,
          _params$fontSize = params.fontSize,
          fontSize = _params$fontSize === void 0 ? defaultParams.fontSize : _params$fontSize;
        this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
      }
    }, {
      key: "setTextStyle",
      value: function setTextStyle(params, defaultParams, z) {
        var _a, _b;
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = getContextFont(params, defaultParams, this.camera && this.camera.getProjectionScale(z));
        var _params$fontFamily2 = params.fontFamily,
          fontFamily = _params$fontFamily2 === void 0 ? defaultParams.fontFamily : _params$fontFamily2,
          _params$fontSize2 = params.fontSize,
          fontSize = _params$fontSize2 === void 0 ? defaultParams.fontSize : _params$fontSize2;
        this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
      }
    }, {
      key: "draw",
      value: function draw() {}
    }, {
      key: "clearMatrix",
      value: function clearMatrix() {
        var setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
        var dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
        this.setTransformFromMatrix(this._clearMatrix, setTransform, dpr);
      }
    }, {
      key: "setClearMatrix",
      value: function setClearMatrix(a, b, c, d, e, f) {
        this._clearMatrix.setValue(a, b, c, d, e, f);
      }
    }, {
      key: "onlyTranslate",
      value: function onlyTranslate() {
        var dpr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dpr;
        return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
      }
    }, {
      key: "release",
      value: function release() {
        this.stack.forEach(function (m) {
          return matrixAllocate.free(m);
        }), this.stack.length = 0;
      }
    }]);
    return BrowserContext2d;
  }();
  BrowserContext2d.env = "browser", BrowserContext2d = __decorate$V([injectable(), __metadata$K("design:paramtypes", [Object, Number])], BrowserContext2d);

  var __decorate$U = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$J = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var BrowserCanvas = /*#__PURE__*/function (_BaseCanvas) {
    _inherits(BrowserCanvas, _BaseCanvas);
    var _super = _createSuper(BrowserCanvas);
    function BrowserCanvas(params) {
      _classCallCheck(this, BrowserCanvas);
      return _super.call(this, params);
    }
    _createClass(BrowserCanvas, [{
      key: "init",
      value: function init(params) {
        var container = params.container;
        if ("string" == typeof container) {
          var _c = application.global.getElementById(container);
          _c && (this._container = _c);
        } else this._container = container;
        this._context = new BrowserContext2d(this, this._dpr), this.initStyle();
      }
    }, {
      key: "initStyle",
      value: function initStyle() {
        if (!this.controled) return;
        var nativeCanvas = this.nativeCanvas;
        nativeCanvas.width = this._pixelWidth, nativeCanvas.height = this._pixelHeight;
        !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight), this._container && this._container.appendChild(nativeCanvas), this.visiable || this.hide();
      }
    }, {
      key: "hide",
      value: function hide() {
        this._nativeCanvas && (this._nativeCanvas.style.display = "none");
      }
    }, {
      key: "show",
      value: function show() {
        this._nativeCanvas && (this._nativeCanvas.style.display = "block");
      }
    }, {
      key: "applyPosition",
      value: function applyPosition() {
        var canvas = this._nativeCanvas;
        canvas.style.position = "absolute", canvas.style.top = "".concat(this._y, "px"), canvas.style.left = "".concat(this._x, "px");
      }
    }, {
      key: "resetStyle",
      value: function resetStyle(params) {
        if (!this.controled) return;
        var _params$width = params.width,
          width = _params$width === void 0 ? this._displayWidth : _params$width,
          _params$height = params.height,
          height = _params$height === void 0 ? this._displayHeight : _params$height,
          _params$dpr = params.dpr,
          dpr = _params$dpr === void 0 ? this._dpr : _params$dpr,
          _params$x = params.x,
          x = _params$x === void 0 ? this._x : _params$x,
          _params$y = params.y,
          y = _params$y === void 0 ? this._y : _params$y,
          nativeCanvas = this.nativeCanvas;
        nativeCanvas.width = width * dpr, nativeCanvas.height = height * dpr;
        !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, x, y, width, height), params.id && (nativeCanvas.id = params.id), this.visiable || this.hide();
      }
    }, {
      key: "setCanvasStyle",
      value: function setCanvasStyle(canvas, x, y, w, h) {
        this.controled && (canvas.style.width = "".concat(w, "px"), canvas.style.height = "".concat(h, "px"));
      }
    }, {
      key: "toDataURL",
      value: function toDataURL(mimeType, quality) {
        return "image/jpeg" === mimeType ? this._nativeCanvas.toDataURL(mimeType, quality) : "image/png" === mimeType ? this._nativeCanvas.toDataURL(mimeType) : this._nativeCanvas.toDataURL(mimeType, quality);
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        if (!this.controled) return;
        this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.style && (this._nativeCanvas.style.width = "".concat(width, "px"), this._nativeCanvas.style.height = "".concat(height, "px")), this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight;
        this._context.dpr = this._dpr;
      }
    }]);
    return BrowserCanvas;
  }(exports.BaseCanvas);
  BrowserCanvas.env = "browser", BrowserCanvas = __decorate$U([injectable(), __metadata$J("design:paramtypes", [Object])], BrowserCanvas);

  function createModule(CanvasConstructor, ContextConstructor) {
    return new ContainerModule(function (bind) {
      bind(CanvasFactory).toDynamicValue(function () {
        return function (params) {
          return new CanvasConstructor(params);
        };
      }).whenTargetNamed(CanvasConstructor.env), bind(Context2dFactory).toDynamicValue(function () {
        return function (params, dpr) {
          return new ContextConstructor(params, dpr);
        };
      }).whenTargetNamed(ContextConstructor.env);
    });
  }

  var browserCanvasModule = createModule(BrowserCanvas, BrowserContext2d);

  var MathPickerContribution = Symbol["for"]("MathPickerContribution");
  var MathArcPicker = Symbol["for"]("MathArcPicker");
  var MathAreaPicker = Symbol["for"]("MathAreaPicker");
  var MathCirclePicker = Symbol["for"]("MathCirclePicker");
  var MathImagePicker = Symbol["for"]("MathImagePicker");
  var MathLinePicker = Symbol["for"]("MathLinePicker");
  var MathPathPicker = Symbol["for"]("MathPathPicker");
  var MathRectPicker = Symbol["for"]("MathRectPicker");
  var MathSymbolPicker = Symbol["for"]("MathSymbolPicker");
  var MathTextPicker = Symbol["for"]("MathTextPicker");
  var MathPolygonPicker = Symbol["for"]("MathPolygonPicker");
  var MathGlyphPicker = Symbol["for"]("MathGlyphPicker");
  var CanvasArcPicker = Symbol["for"]("CanvasArcPicker");
  var CanvasArc3dPicker = Symbol["for"]("CanvasArc3dPicker");
  var CanvasAreaPicker = Symbol["for"]("CanvasAreaPicker");
  var CanvasCirclePicker = Symbol["for"]("CanvasCirclePicker");
  var CanvasImagePicker = Symbol["for"]("CanvasImagePicker");
  var CanvasLinePicker = Symbol["for"]("CanvasLinePicker");
  var CanvasPathPicker = Symbol["for"]("CanvasPathPicker");
  var CanvasRectPicker = Symbol["for"]("CanvasRectPicker");
  var CanvasRect3dPicker = Symbol["for"]("CanvasRect3dPicker");
  var CanvasSymbolPicker = Symbol["for"]("CanvasSymbolPicker");
  var CanvasTextPicker = Symbol["for"]("CanvasTextPicker");
  var CanvasPolygonPicker = Symbol["for"]("CanvasPolygonPicker");
  var CanvasPyramid3dPicker = Symbol["for"]("CanvasPyramid3dPicker");
  var CanvasRichTextPicker = Symbol["for"]("CanvasRichTextPicker");
  var CanvasGlyphPicker = Symbol["for"]("CanvasGlyphPicker");
  var CanvasGroupPicker = Symbol["for"]("CanvasGroupPicker");
  var CanvasPickerContribution = Symbol["for"]("CanvasPickerContribution");

  var __decorate$T = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$I = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$u = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasPickerService = /*#__PURE__*/function (_DefaultPickService) {
    _inherits(DefaultCanvasPickerService, _DefaultPickService);
    var _super = _createSuper(DefaultCanvasPickerService);
    function DefaultCanvasPickerService(contributions, drawContribution, pickItemInterceptorContributions) {
      var _this;
      _classCallCheck(this, DefaultCanvasPickerService);
      _this = _super.call(this, pickItemInterceptorContributions), _this.contributions = contributions, _this.drawContribution = drawContribution, _this.pickItemInterceptorContributions = pickItemInterceptorContributions, _this.global.hooks.onSetEnv.tap("canvas-picker-service", function (_, env, global) {
        _this.configure(global, env);
      }), _this.configure(_this.global, _this.global.env), _this.pickerMap = new Map(), _this.init();
      return _this;
    }
    _createClass(DefaultCanvasPickerService, [{
      key: "init",
      value: function init() {
        var _this2 = this;
        this.contributions.getContributions().forEach(function (item) {
          _this2.pickerMap.set(item.numberType, item);
        }), _get(_getPrototypeOf(DefaultCanvasPickerService.prototype), "_init", this).call(this);
      }
    }, {
      key: "configure",
      value: function configure(global, env) {
        this.pickCanvas = canvasAllocate.shareCanvas(), this.pickContext = this.pickCanvas.getContext("2d");
      }
    }, {
      key: "pickItem",
      value: function pickItem(graphic, point, parentMatrix, params) {
        if (!1 === graphic.attribute.pickable) return null;
        if (this.InterceptorContributions.length) for (var i = 0; i < this.InterceptorContributions.length; i++) {
          var drawContribution = this.InterceptorContributions[i];
          if (drawContribution.beforePickItem) {
            var ret = drawContribution.beforePickItem(graphic, this, point, params, {
              parentMatrix: parentMatrix
            });
            if (ret) return ret;
          }
        }
        var picker = this.pickerMap.get(graphic.numberType);
        if (!picker) return null;
        var g = picker.contains(graphic, point, params) ? graphic : null,
          data = {
            graphic: g
          };
        if (g) return data;
        if (this.InterceptorContributions.length) for (var _i = 0; _i < this.InterceptorContributions.length; _i++) {
          var _drawContribution = this.InterceptorContributions[_i];
          if (_drawContribution.afterPickItem) {
            var _ret = _drawContribution.afterPickItem(graphic, this, point, params, {
              parentMatrix: parentMatrix
            });
            if (_ret) return _ret;
          }
        }
        return data;
      }
    }]);
    return DefaultCanvasPickerService;
  }(exports.DefaultPickService);
  DefaultCanvasPickerService = __decorate$T([injectable(), __param$u(0, inject(ContributionProvider)), __param$u(0, named(CanvasPickerContribution)), __param$u(1, inject(DrawContribution)), __param$u(2, inject(ContributionProvider)), __param$u(2, named(PickItemInterceptor)), __metadata$I("design:paramtypes", [Object, Object, Object])], DefaultCanvasPickerService);

  var __decorate$S = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultCanvasGroupPicker = /*#__PURE__*/function () {
    function DefaultCanvasGroupPicker() {
      _classCallCheck(this, DefaultCanvasGroupPicker);
      this.type = "group", this.numberType = GROUP_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasGroupPicker, [{
      key: "contains",
      value: function contains(group, point, params) {
        return !1;
      }
    }]);
    return DefaultCanvasGroupPicker;
  }();
  DefaultCanvasGroupPicker = __decorate$S([injectable()], DefaultCanvasGroupPicker);

  var m$1 = new ContainerModule(function (bind, unbind, isBound, rebind) {
    m$1.__vloaded || (m$1.__vloaded = !0, bind(CanvasGroupPicker).to(DefaultCanvasGroupPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGroupPicker), bindContributionProvider(bind, CanvasPickerContribution));
  });
  m$1.__vloaded = !1;
  var canvasModule = m$1;

  var canvasPickerModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    isBound(DefaultCanvasPickerService) || bind(DefaultCanvasPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultCanvasPickerService) : bind(PickerService).toService(DefaultCanvasPickerService);
  });
  function loadCanvasPicker(c) {
    c.load(canvasModule), c.load(canvasPickerModule);
  }

  var _BrowserWindowHandlerContribution_,
    __decorate$R = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$H = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var BrowserWindowHandlerContribution = _BrowserWindowHandlerContribution_ = /*#__PURE__*/function (_BaseWindowHandlerCon) {
    _inherits(BrowserWindowHandlerContribution_1, _BaseWindowHandlerCon);
    var _super = _createSuper(BrowserWindowHandlerContribution_1);
    function BrowserWindowHandlerContribution_1() {
      var _this;
      _classCallCheck(this, BrowserWindowHandlerContribution_1);
      _this = _super.call(this), _this.type = "browser", _this._canvasIsIntersecting = !0, _this.global = application.global, _this.viewBox = new AABBBounds(), _this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
      return _this;
    }
    _createClass(BrowserWindowHandlerContribution_1, [{
      key: "container",
      get: function get() {
        return this.canvas.nativeCanvas.parentElement;
      }
    }, {
      key: "getTitle",
      value: function getTitle() {
        return this.canvas.id && this.canvas.id.toString();
      }
    }, {
      key: "getWH",
      value: function getWH() {
        return {
          width: this.canvas.width / (this.canvas.dpr || 1),
          height: this.canvas.height / (this.canvas.dpr || 1)
        };
      }
    }, {
      key: "getXY",
      value: function getXY() {
        return this.canvas.nativeCanvas.getBoundingClientRect();
      }
    }, {
      key: "createWindow",
      value: function createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params), this.postInit();
      }
    }, {
      key: "postInit",
      value: function postInit() {
        if (this.global.optimizeVisible) try {
          this.observerCanvas();
        } catch (err) {
          console.error("发生错误，该环境不存在IntersectionObserver");
        }
      }
    }, {
      key: "isElementVisible",
      value: function isElementVisible(el) {
        var rect = el.getBoundingClientRect(),
          vWidth = window.innerWidth || document.documentElement.clientWidth,
          vHeight = window.innerHeight || document.documentElement.clientHeight;
        return !(rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight);
      }
    }, {
      key: "observerCanvas",
      value: function observerCanvas() {
        var _this2 = this;
        this._canvasIsIntersecting = this.isElementVisible(this.canvas.nativeCanvas);
        var observer = new IntersectionObserver(function (entries, observer) {
          entries.forEach(function (entry) {
            _this2._canvasIsIntersecting !== entry.isIntersecting ? (_this2._canvasIsIntersecting = entry.isIntersecting, _this2._onVisibleChangeCb && _this2._onVisibleChangeCb(entry.isIntersecting)) : _this2._canvasIsIntersecting = entry.isIntersecting;
          });
        });
        observer && observer.observe(this.canvas.nativeCanvas);
      }
    }, {
      key: "createWindowByConfig",
      value: function createWindowByConfig(params) {
        var nativeCanvas = this.global.createCanvas({
          width: params.width,
          height: params.height
        });
        var container;
        if (container = "string" == typeof params.container ? this.global.getElementById(params.container) : params.container ? params.container : this.global.getRootElement(), !container) throw new Error("发生错误，containerId可能传入有误");
        params.offscreen ? container = null : container.appendChild(nativeCanvas);
        var options = {
          width: params.width,
          height: params.height,
          dpr: params.dpr,
          nativeCanvas: nativeCanvas,
          container: container,
          id: _BrowserWindowHandlerContribution_.GenerateCanvasId(),
          canvasControled: !0
        };
        this.canvas = new BrowserCanvas(options);
      }
    }, {
      key: "createWindowByCanvas",
      value: function createWindowByCanvas(params) {
        var _a;
        var canvas;
        if ("string" == typeof params.canvas) {
          if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        if (!canvas) throw new Error("发生错误，传入的canvas不正确");
        var width = params.width,
          height = params.height;
        if (null == width || null == height || !params.canvasControled) {
          var data = canvas.getBoundingClientRect();
          width = data.width, height = data.height;
        }
        var dpr = params.dpr;
        if (null == dpr) {
          dpr = null !== (_a = canvas.getContext("2d").pixelRatio) && void 0 !== _a ? _a : canvas.width / width;
        }
        this.canvas = new BrowserCanvas({
          width: width,
          height: height,
          dpr: dpr,
          nativeCanvas: canvas,
          canvasControled: params.canvasControled
        });
      }
    }, {
      key: "releaseWindow",
      value: function releaseWindow() {
        this.canvas.release();
      }
    }, {
      key: "resizeWindow",
      value: function resizeWindow(width, height) {
        this.canvas.resize(width, height);
      }
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.canvas.getContext();
      }
    }, {
      key: "getNativeHandler",
      value: function getNativeHandler() {
        return this.canvas;
      }
    }, {
      key: "getDpr",
      value: function getDpr() {
        return this.canvas.dpr;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        return this.canvas.nativeCanvas.addEventListener(type, listener, options);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        return this.canvas.nativeCanvas.removeEventListener(type, listener, options);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return this.canvas.nativeCanvas.dispatchEvent(event);
      }
    }, {
      key: "getStyle",
      value: function getStyle() {
        var _a;
        return null !== (_a = this.canvas.nativeCanvas.style) && void 0 !== _a ? _a : {};
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {
        this.canvas.nativeCanvas.style = style;
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        var c = this.canvas.nativeCanvas,
          wh = this.getWH();
        return c.parentElement ? this.canvas.nativeCanvas.getBoundingClientRect() : {
          x: 0,
          y: 0,
          width: wh.width,
          height: wh.height,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
      }
    }, {
      key: "clearViewBox",
      value: function clearViewBox(color) {
        var vb = this.viewBox,
          context = this.getContext(),
          dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
      }
    }, {
      key: "isVisible",
      value: function isVisible(bbox) {
        return this._canvasIsIntersecting;
      }
    }, {
      key: "onVisibleChange",
      value: function onVisibleChange(cb) {
        this._onVisibleChangeCb = cb;
      }
    }, {
      key: "getTopLeft",
      value: function getTopLeft(baseWindow) {
        return this.global.getElementTopLeft(this.canvas.nativeCanvas, baseWindow);
      }
    }], [{
      key: "GenerateCanvasId",
      value: function GenerateCanvasId() {
        return "".concat(_BrowserWindowHandlerContribution_.idprefix, "_").concat(_BrowserWindowHandlerContribution_.prefix_count++);
      }
    }]);
    return BrowserWindowHandlerContribution_1;
  }(exports.BaseWindowHandlerContribution);
  BrowserWindowHandlerContribution.env = "browser", BrowserWindowHandlerContribution.idprefix = "visactor_window", BrowserWindowHandlerContribution.prefix_count = 0, BrowserWindowHandlerContribution = _BrowserWindowHandlerContribution_ = __decorate$R([injectable(), __metadata$H("design:paramtypes", [])], BrowserWindowHandlerContribution);
  var browserWindowModule = new ContainerModule(function (bind) {
    bind(BrowserWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(function (ctx) {
      return ctx.container.get(BrowserWindowHandlerContribution);
    }).whenTargetNamed(BrowserWindowHandlerContribution.env);
  });

  var __decorate$Q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$G = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var DynamicB = /*#__PURE__*/function () {
    function DynamicB(dom) {
      _classCallCheck(this, DynamicB);
      this.dom = dom;
    }
    _createClass(DynamicB, [{
      key: "x1",
      get: function get() {
        return this.dom.getBoundingClientRect().left;
      }
    }, {
      key: "x2",
      get: function get() {
        return this.dom.getBoundingClientRect().right;
      }
    }, {
      key: "y1",
      get: function get() {
        return this.dom.getBoundingClientRect().top;
      }
    }, {
      key: "y2",
      get: function get() {
        return this.dom.getBoundingClientRect().bottom;
      }
    }, {
      key: "width",
      get: function get() {
        return this.dom.getBoundingClientRect().width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.dom.getBoundingClientRect().height;
      }
    }]);
    return DynamicB;
  }();
  function createImageElement$1(src) {
    var isSvg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var img = document.createElement("img");
    if (img.crossOrigin = "anonymous", isSvg) {
      var data = new Blob([src], {
        type: "image/svg+xml"
      });
      src = window.URL.createObjectURL(data);
    }
    if (img.src = src, img.complete) return Promise.resolve(img);
    return new Promise(function (resolve, reject) {
      img.onload = function () {
        resolve(img);
      }, img.onerror = function () {
        reject(new Error("加载失败"));
      };
    });
  }
  var BrowserEnvContribution = /*#__PURE__*/function (_BaseEnvContribution) {
    _inherits(BrowserEnvContribution, _BaseEnvContribution);
    var _super = _createSuper(BrowserEnvContribution);
    function BrowserEnvContribution() {
      var _this;
      _classCallCheck(this, BrowserEnvContribution);
      _this = _super.call(this), _this.type = "browser", _this.supportEvent = !0;
      try {
        _this.supportsTouchEvents = "ontouchstart" in globalThis, _this.supportsPointerEvents = !!globalThis.PointerEvent, _this.supportsMouseEvents = !!globalThis.MouseEvent;
      } catch (err) {
        _this.supportsTouchEvents = !1, _this.supportsPointerEvents = !1, _this.supportsPointerEvents = !1;
      }
      _this.applyStyles = !0;
      return _this;
    }
    _createClass(BrowserEnvContribution, [{
      key: "mapToCanvasPoint",
      value: function mapToCanvasPoint(nativeEvent, domElement) {
        var _a, _b;
        var clientX = 0,
          clientY = 0,
          offsetX = 0,
          offsetY = 0;
        if (nativeEvent.changedTouches) {
          var data = null !== (_a = nativeEvent.changedTouches[0]) && void 0 !== _a ? _a : {};
          clientX = data.clientX || 0, clientY = data.clientY || 0, offsetX = clientX, offsetY = clientY;
        } else clientX = nativeEvent.clientX || 0, clientY = nativeEvent.clientY || 0, offsetX = nativeEvent.offsetX || 0, offsetY = nativeEvent.offsetY || 0;
        if (domElement) {
          var x = clientX,
            y = clientY,
            rect = domElement.getBoundingClientRect(),
            nativeCanvas = null === (_b = domElement.getNativeHandler) || void 0 === _b ? void 0 : _b.call(domElement).nativeCanvas;
          var scaleX, scaleY;
          return nativeCanvas && (scaleX = rect.width / nativeCanvas.offsetWidth, scaleY = rect.height / nativeCanvas.offsetHeight), {
            x: (x - rect.left) / (isValidNumber$1(scaleX) ? scaleX : 1),
            y: (y - rect.top) / (isValidNumber$1(scaleY) ? scaleY : 1)
          };
        }
        return {
          x: offsetX,
          y: offsetY
        };
      }
    }, {
      key: "getNativeAABBBounds",
      value: function getNativeAABBBounds(_dom) {
        var dom = _dom;
        if ("string" == typeof _dom && (dom = new DOMParser().parseFromString(_dom, "text/html").firstChild, dom.lastChild && (dom = dom.lastChild.firstChild)), dom.getBoundingClientRect) {
          var b = dom.getBoundingClientRect();
          return new DynamicB(b);
        }
        return new AABBBounds();
      }
    }, {
      key: "removeDom",
      value: function removeDom(dom) {
        return dom.parentElement.removeChild(dom), !0;
      }
    }, {
      key: "createDom",
      value: function createDom(params) {
        var _params$tagName = params.tagName,
          tagName = _params$tagName === void 0 ? "div" : _params$tagName,
          width = params.width,
          height = params.height,
          style = params.style,
          parent = params.parent,
          element = document.createElement(tagName);
        if (style && (isString$1(style) ? element.setAttribute("style", style) : Object.keys(style).forEach(function (k) {
          element.setAttribute(k, style[k]);
        })), null != width && (element.style.width = "".concat(width, "px")), null != height && (element.style.height = "".concat(height, "px")), parent) {
          var pd = isString$1(parent) ? this.getElementById(parent) : parent;
          pd && pd.appendChild && pd.appendChild(element);
        }
        return element;
      }
    }, {
      key: "loadImage",
      value: function loadImage(url) {
        return createImageElement$1(url, !1).then(function (img) {
          return {
            data: img,
            loadState: "success"
          };
        })["catch"](function () {
          return {
            data: null,
            loadState: "fail"
          };
        });
      }
    }, {
      key: "loadSvg",
      value: function loadSvg(url) {
        return createImageElement$1(url, !0).then(function (img) {
          return {
            data: img,
            loadState: "success"
          };
        })["catch"](function () {
          return {
            data: null,
            loadState: "fail"
          };
        });
      }
    }, {
      key: "createCanvas",
      value: function createCanvas(params) {
        var _a, _b;
        var canvas = document.createElement("canvas");
        params.id && (canvas.id = null !== (_a = params.id) && void 0 !== _a ? _a : Generator.GenAutoIncrementId().toString());
        var dpr = null !== (_b = params.dpr) && void 0 !== _b ? _b : window.devicePixelRatio;
        return params.width && params.height && (canvas.style.width = "".concat(params.width, "px"), canvas.style.height = "".concat(params.height, "px"), canvas.width = params.width * dpr, canvas.height = params.height * dpr), canvas;
      }
    }, {
      key: "createOffscreenCanvas",
      value: function createOffscreenCanvas(params) {
        var _a;
        var dpr = null !== (_a = params.dpr) && void 0 !== _a ? _a : window.devicePixelRatio;
        return new OffscreenCanvas(params.width * dpr, params.height * dpr);
      }
    }, {
      key: "releaseCanvas",
      value: function releaseCanvas(canvas) {
        var c;
        c = "string" == typeof canvas ? document.getElementById(canvas) : canvas, c && c.parentElement && c.parentElement.removeChild(c);
      }
    }, {
      key: "getDevicePixelRatio",
      value: function getDevicePixelRatio() {
        return window.devicePixelRatio;
      }
    }, {
      key: "getRequestAnimationFrame",
      value: function getRequestAnimationFrame() {
        return window.requestAnimationFrame;
      }
    }, {
      key: "getCancelAnimationFrame",
      value: function getCancelAnimationFrame() {
        return window.cancelAnimationFrame;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        return document.addEventListener(type, listener, options);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        return document.removeEventListener(type, listener, options);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return document.dispatchEvent(event);
      }
    }, {
      key: "getElementById",
      value: function getElementById(str) {
        return document.getElementById(str);
      }
    }, {
      key: "getRootElement",
      value: function getRootElement() {
        return document.body;
      }
    }, {
      key: "getDocument",
      value: function getDocument() {
        return document;
      }
    }, {
      key: "release",
      value: function release() {}
    }, {
      key: "getElementTop",
      value: function getElementTop(element, baseWindow) {
        var actualTop = element.offsetTop,
          current = element.offsetParent;
        for (; null !== current;) actualTop += current.offsetTop, current = current.offsetParent;
        return actualTop;
      }
    }, {
      key: "getElementLeft",
      value: function getElementLeft(element, baseWindow) {
        var actualLeft = element.offsetLeft,
          current = element.offsetParent;
        for (; null !== current;) actualLeft += current.offsetLeft, current = current.offsetParent;
        return actualLeft;
      }
    }, {
      key: "getElementTopLeft",
      value: function getElementTopLeft(element, baseWindow) {
        var actualTop = element.offsetTop,
          actualLeft = element.offsetLeft,
          current = element.offsetParent;
        for (; null !== current;) actualTop += current.offsetTop, actualLeft += current.offsetLeft, current = current.offsetParent;
        return {
          top: actualTop,
          left: actualLeft
        };
      }
    }]);
    return BrowserEnvContribution;
  }(exports.BaseEnvContribution);
  BrowserEnvContribution = __decorate$Q([injectable(), __metadata$G("design:paramtypes", [])], BrowserEnvContribution);

  var browserEnvModule = new ContainerModule(function (bind) {
    browserEnvModule.isBrowserBound || (browserEnvModule.isBrowserBound = !0, bind(BrowserEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(BrowserEnvContribution));
  });
  browserEnvModule.isBrowserBound = !1;
  function loadBrowserEnv(container) {
    var loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    loadBrowserEnv.__loaded || (loadBrowserEnv.__loaded = !0, container.load(browserEnvModule), container.load(browserCanvasModule), container.load(browserWindowModule), loadPicker && loadCanvasPicker(container));
  }
  loadBrowserEnv.__loaded = !1;
  function initBrowserEnv() {
    loadBrowserEnv(container);
  }

  var __decorate$P = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var FeishuContext2d = /*#__PURE__*/function (_BrowserContext2d) {
    _inherits(FeishuContext2d, _BrowserContext2d);
    var _super = _createSuper(FeishuContext2d);
    function FeishuContext2d() {
      _classCallCheck(this, FeishuContext2d);
      return _super.apply(this, arguments);
    }
    _createClass(FeishuContext2d, [{
      key: "globalAlpha",
      get: function get() {
        return this._globalAlpha;
      },
      set: function set(ga) {
        this.nativeContext.globalAlpha = ga, this._globalAlpha = ga;
      }
    }, {
      key: "getImageData",
      value: function getImageData(sx, sy, sw, sh) {
        var _this = this;
        return new Promise(function (resolve, reject) {
          var _a;
          try {
            tt.canvasGetImageData({
              canvasId: null !== (_a = _this.canvas.nativeCanvas.id) && void 0 !== _a ? _a : _this.canvas.id,
              x: sx,
              y: sy,
              width: sw,
              height: sh,
              success: function success(res) {
                resolve(res);
              }
            });
          } catch (err) {
            reject(err);
          }
        });
      }
    }, {
      key: "draw",
      value: function draw() {
        var _this2 = this;
        var _context = this.nativeContext;
        _context.draw && (this.drawPromise = new Promise(function (resolve) {
          _context.draw(!0, function () {
            _this2.drawPromise = null, resolve(null);
          });
        }));
      }
    }, {
      key: "createPattern",
      value: function createPattern(image, repetition) {
        return null;
      }
    }]);
    return FeishuContext2d;
  }(BrowserContext2d);
  FeishuContext2d.env = "feishu", FeishuContext2d = __decorate$P([injectable()], FeishuContext2d);

  var __decorate$O = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$F = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var FeishuCanvas = /*#__PURE__*/function (_BaseCanvas) {
    _inherits(FeishuCanvas, _BaseCanvas);
    var _super = _createSuper(FeishuCanvas);
    function FeishuCanvas(params) {
      _classCallCheck(this, FeishuCanvas);
      return _super.call(this, params);
    }
    _createClass(FeishuCanvas, [{
      key: "init",
      value: function init() {
        this._context = new FeishuContext2d(this, this._dpr);
      }
    }, {
      key: "release",
      value: function release() {}
    }]);
    return FeishuCanvas;
  }(exports.BaseCanvas);
  FeishuCanvas.env = "feishu", FeishuCanvas = __decorate$O([injectable(), __metadata$F("design:paramtypes", [Object])], FeishuCanvas);

  var feishuCanvasModule = createModule(FeishuCanvas, FeishuContext2d);

  var __decorate$N = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$E = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$t = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var MiniAppEventManager$4 = /*#__PURE__*/function () {
    function MiniAppEventManager() {
      _classCallCheck(this, MiniAppEventManager);
      this.cache = {};
    }
    _createClass(MiniAppEventManager, [{
      key: "addEventListener",
      value: function addEventListener(type, func) {
        type && func && (this.cache[type] = this.cache[type] || {
          listener: []
        }, this.cache[type].listener.push(func));
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, func) {
        if (!type || !func) return;
        if (!this.cache[type]) return;
        var index = this.cache[type].listener.findIndex(function (f) {
          return f === func;
        });
        index >= 0 && this.cache[type].listener.splice(index, 1);
      }
    }, {
      key: "cleanEvent",
      value: function cleanEvent() {
        this.cache = {};
      }
    }]);
    return MiniAppEventManager;
  }();
  var FeishuWindowHandlerContribution = /*#__PURE__*/function (_BaseWindowHandlerCon) {
    _inherits(FeishuWindowHandlerContribution, _BaseWindowHandlerCon);
    var _super = _createSuper(FeishuWindowHandlerContribution);
    function FeishuWindowHandlerContribution(global) {
      var _this;
      _classCallCheck(this, FeishuWindowHandlerContribution);
      _this = _super.call(this), _this.global = global, _this.type = "feishu", _this.eventManager = new MiniAppEventManager$4();
      return _this;
    }
    _createClass(FeishuWindowHandlerContribution, [{
      key: "container",
      get: function get() {
        return null;
      }
    }, {
      key: "getTitle",
      value: function getTitle() {
        return this.canvas.id.toString();
      }
    }, {
      key: "getWH",
      value: function getWH() {
        return {
          width: this.canvas.width / (this.canvas.dpr || 1),
          height: this.canvas.height / (this.canvas.dpr || 1)
        };
      }
    }, {
      key: "getXY",
      value: function getXY() {
        return {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "createWindow",
      value: function createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
      }
    }, {
      key: "createWindowByConfig",
      value: function createWindowByConfig(params) {
        var nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
          }),
          options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: Generator.GenAutoIncrementId().toString(),
            canvasControled: !1
          };
        this.canvas = new FeishuCanvas(options);
      }
    }, {
      key: "createWindowByCanvas",
      value: function createWindowByCanvas(params) {
        var canvas;
        if ("string" == typeof params.canvas) {
          if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        var width = params.width,
          height = params.height;
        if (null == width || null == height || !params.canvasControled) {
          var data = canvas.getBoundingClientRect();
          width = data.width, height = data.height;
        }
        var dpr = params.dpr;
        null == dpr && (dpr = canvas.width / width), this.canvas = new FeishuCanvas({
          width: width,
          height: height,
          dpr: dpr,
          nativeCanvas: canvas,
          canvasControled: params.canvasControled
        });
      }
    }, {
      key: "releaseWindow",
      value: function releaseWindow() {}
    }, {
      key: "resizeWindow",
      value: function resizeWindow(width, height) {}
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.canvas.getContext();
      }
    }, {
      key: "getNativeHandler",
      value: function getNativeHandler() {
        return this.canvas;
      }
    }, {
      key: "getDpr",
      value: function getDpr() {
        return this.canvas.dpr;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        this.eventManager.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        this.eventManager.removeEventListener(type, listener);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        var type = event.type;
        return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = function () {}, event.stopPropagation = function () {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(function (f) {
          f(event);
        }), !0);
      }
    }, {
      key: "getStyle",
      value: function getStyle() {
        return {};
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {}
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        var wh = this.getWH();
        return {
          x: 0,
          y: 0,
          width: wh.width,
          height: wh.height,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
      }
    }, {
      key: "clearViewBox",
      value: function clearViewBox(color) {
        var vb = this.viewBox,
          context = this.getContext(),
          dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
      }
    }]);
    return FeishuWindowHandlerContribution;
  }(exports.BaseWindowHandlerContribution);
  FeishuWindowHandlerContribution.env = "feishu", FeishuWindowHandlerContribution = __decorate$N([injectable(), __param$t(0, inject(VGlobal)), __metadata$E("design:paramtypes", [Object])], FeishuWindowHandlerContribution);
  var feishuWindowModule = new ContainerModule(function (bind) {
    bind(FeishuWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(function (ctx) {
      return ctx.container.get(FeishuWindowHandlerContribution);
    }).whenTargetNamed(FeishuWindowHandlerContribution.env);
  });

  var __decorate$M = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$D = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$s = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultMathPickerService = /*#__PURE__*/function (_DefaultPickService) {
    _inherits(DefaultMathPickerService, _DefaultPickService);
    var _super = _createSuper(DefaultMathPickerService);
    function DefaultMathPickerService(contributions, pickItemInterceptorContributions) {
      var _this;
      _classCallCheck(this, DefaultMathPickerService);
      _this = _super.call(this, pickItemInterceptorContributions), _this.contributions = contributions, _this.pickItemInterceptorContributions = pickItemInterceptorContributions, _this.global.hooks.onSetEnv.tap("math-picker-service", function (lastEnv, env, global) {
        _this.configure(global, env);
      }), _this.configure(_this.global, _this.global.env), _this.pickerMap = new Map(), _this.init();
      return _this;
    }
    _createClass(DefaultMathPickerService, [{
      key: "init",
      value: function init() {
        var _this2 = this;
        this.contributions.getContributions().forEach(function (item) {
          _this2.pickerMap.set(item.numberType, item);
        }), _get(_getPrototypeOf(DefaultMathPickerService.prototype), "_init", this).call(this);
      }
    }, {
      key: "configure",
      value: function configure(global, env) {
        this.pickContext = new exports.EmptyContext2d(null, 1);
      }
    }, {
      key: "pickItem",
      value: function pickItem(graphic, point, parentMatrix, params) {
        if (!1 === graphic.attribute.pickable) return null;
        var picker = this.pickerMap.get(graphic.numberType);
        if (!picker) return null;
        var g = picker.contains(graphic, point, params) ? graphic : null;
        return g ? {
          graphic: g
        } : null;
      }
    }]);
    return DefaultMathPickerService;
  }(exports.DefaultPickService);
  DefaultMathPickerService = __decorate$M([injectable(), __param$s(0, inject(ContributionProvider)), __param$s(0, named(MathPickerContribution)), __param$s(1, inject(ContributionProvider)), __param$s(1, named(PickItemInterceptor)), __metadata$D("design:paramtypes", [Object, Object])], DefaultMathPickerService);

  var m = new ContainerModule(function (bind) {
    m.__vloaded || (m.__vloaded = !0, bindContributionProvider(bind, MathPickerContribution));
  });
  m.__vloaded = !1;
  var mathModule = m;

  var mathPickerModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    isBound(DefaultMathPickerService) || bind(DefaultMathPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultMathPickerService) : bind(PickerService).toService(DefaultMathPickerService);
  });
  function loadMathPicker(c) {
    c.load(mathModule), c.load(mathPickerModule);
  }

  var CanvasWrapDisableWH = /*#__PURE__*/function () {
    function CanvasWrapDisableWH(nativeCanvas, ctx, dpr, w, h, id) {
      _classCallCheck(this, CanvasWrapDisableWH);
      this.nativeCanvas = nativeCanvas, this.ctx = ctx, this._w = w, this._h = h, this.id = id, nativeCanvas.id = id, this.dpr = dpr;
    }
    _createClass(CanvasWrapDisableWH, [{
      key: "width",
      get: function get() {
        return this._w * this.dpr;
      },
      set: function set(w) {}
    }, {
      key: "height",
      get: function get() {
        return this._h * this.dpr;
      },
      set: function set(h) {}
    }, {
      key: "offsetWidth",
      get: function get() {
        return this._w;
      },
      set: function set(w) {}
    }, {
      key: "offsetHeight",
      get: function get() {
        return this._h;
      },
      set: function set(h) {}
    }, {
      key: "getContext",
      value: function getContext() {
        return this.ctx;
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        return {
          width: this._w,
          height: this._h
        };
      }
    }]);
    return CanvasWrapDisableWH;
  }();
  var CanvasWrapEnableWH = /*#__PURE__*/function () {
    function CanvasWrapEnableWH(nativeCanvas, ctx, dpr, w, h, id) {
      _classCallCheck(this, CanvasWrapEnableWH);
      this.nativeCanvas = nativeCanvas, this.ctx = ctx, this._w = w, this._h = h, this.id = id, nativeCanvas.id = id, this.dpr = dpr;
    }
    _createClass(CanvasWrapEnableWH, [{
      key: "width",
      get: function get() {
        return this._w * this.dpr;
      },
      set: function set(w) {
        this._w = w / this.dpr, this.nativeCanvas.width = w;
      }
    }, {
      key: "height",
      get: function get() {
        return this._h * this.dpr;
      },
      set: function set(h) {
        this._h = h / this.dpr, this.nativeCanvas.height = h;
      }
    }, {
      key: "offsetWidth",
      get: function get() {
        return this._w;
      },
      set: function set(w) {
        this._w = w, this.nativeCanvas.width = w * this.dpr;
      }
    }, {
      key: "offsetHeight",
      get: function get() {
        return this._h;
      },
      set: function set(h) {
        this._h = h, this.nativeCanvas.height = h * this.dpr;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.ctx;
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        return {
          width: this._w,
          height: this._h
        };
      }
    }]);
    return CanvasWrapEnableWH;
  }();

  var __decorate$L = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$C = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  function makeUpCanvas$4(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, pixelRatio) {
    var dpr = null != pixelRatio ? pixelRatio : tt.getSystemInfoSync().pixelRatio;
    canvasIdLists.forEach(function (id, i) {
      var ctx = tt.createCanvasContext(id),
        canvas = new CanvasWrapDisableWH(ctx.canvas || {}, ctx, dpr, domref.width, domref.height, id);
      ctx.canvas = canvas, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas);
    });
  }
  var FeishuEnvContribution = /*#__PURE__*/function (_BaseEnvContribution) {
    _inherits(FeishuEnvContribution, _BaseEnvContribution);
    var _super = _createSuper(FeishuEnvContribution);
    function FeishuEnvContribution() {
      var _this;
      _classCallCheck(this, FeishuEnvContribution);
      _this = _super.call(this), _this.type = "feishu", _this.supportEvent = !0, _this.canvasMap = new Map(), _this.freeCanvasList = [], _this.canvasIdx = 0, _this.supportsTouchEvents = !0;
      try {
        _this.supportsPointerEvents = !!globalThis.PointerEvent, _this.supportsMouseEvents = !!globalThis.MouseEvent;
      } catch (err) {
        _this.supportsPointerEvents = !1, _this.supportsMouseEvents = !1;
      }
      _this.applyStyles = !0;
      return _this;
    }
    _createClass(FeishuEnvContribution, [{
      key: "getDynamicCanvasCount",
      value: function getDynamicCanvasCount() {
        return this.freeCanvasList.length;
      }
    }, {
      key: "getStaticCanvasCount",
      value: function getStaticCanvasCount() {
        return 9999;
      }
    }, {
      key: "configure",
      value: function configure(service, params) {
        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas$4(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.pixelRatio));
      }
    }, {
      key: "loadImage",
      value: function loadImage(url) {
        return Promise.resolve({
          data: url,
          loadState: "success"
        });
      }
    }, {
      key: "loadSvg",
      value: function loadSvg(url) {
        return Promise.reject();
      }
    }, {
      key: "createCanvas",
      value: function createCanvas(params) {
        var result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
      }
    }, {
      key: "createOffscreenCanvas",
      value: function createOffscreenCanvas(params) {}
    }, {
      key: "releaseCanvas",
      value: function releaseCanvas(canvas) {}
    }, {
      key: "getDevicePixelRatio",
      value: function getDevicePixelRatio() {
        return tt.getSystemInfoSync().pixelRatio;
      }
    }, {
      key: "getRequestAnimationFrame",
      value: function getRequestAnimationFrame() {
        return function (callback) {
          return rafBasedSto.call(callback);
        };
      }
    }, {
      key: "getCancelAnimationFrame",
      value: function getCancelAnimationFrame() {
        return function (h) {
          rafBasedSto.clear(h);
        };
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return null;
      }
    }, {
      key: "getElementById",
      value: function getElementById(str) {
        return this.canvasMap.get(str);
      }
    }, {
      key: "getRootElement",
      value: function getRootElement() {
        return null;
      }
    }, {
      key: "getDocument",
      value: function getDocument() {
        return null;
      }
    }, {
      key: "release",
      value: function release() {}
    }, {
      key: "mapToCanvasPoint",
      value: function mapToCanvasPoint(event) {
        var _a;
        return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
      }
    }]);
    return FeishuEnvContribution;
  }(exports.BaseEnvContribution);
  FeishuEnvContribution = __decorate$L([injectable(), __metadata$C("design:paramtypes", [])], FeishuEnvContribution);

  var feishuEnvModule = new ContainerModule(function (bind) {
    feishuEnvModule.isFeishuBound || (feishuEnvModule.isFeishuBound = !0, bind(FeishuEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(FeishuEnvContribution));
  });
  feishuEnvModule.isFeishuBound = !1;
  function loadFeishuEnv(container) {
    var loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    loadFeishuEnv.__loaded || (loadFeishuEnv.__loaded = !0, container.load(feishuEnvModule), container.load(feishuCanvasModule), container.load(feishuWindowModule), loadPicker && loadMathPicker(container));
  }
  loadFeishuEnv.__loaded = !1;
  function initFeishuEnv() {
    loadFeishuEnv(container);
  }

  var __decorate$K = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var LynxContext2d = /*#__PURE__*/function (_BrowserContext2d) {
    _inherits(LynxContext2d, _BrowserContext2d);
    var _super = _createSuper(LynxContext2d);
    function LynxContext2d() {
      _classCallCheck(this, LynxContext2d);
      return _super.apply(this, arguments);
    }
    _createClass(LynxContext2d, [{
      key: "globalAlpha",
      get: function get() {
        return this._globalAlpha;
      },
      set: function set(ga) {
        this.nativeContext.globalAlpha = ga, this._globalAlpha = ga;
      }
    }, {
      key: "setLineDash",
      value: function setLineDash(segments) {
        var a = arguments,
          _context = this.nativeContext;
        if (this.nativeContext.setLineDash) {
          var lineDash = a[0];
          if (0 === lineDash[0] && 0 === lineDash[1]) return;
          _context.setLineDash(lineDash);
        }
      }
    }, {
      key: "_setStrokeStyle",
      value: function _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.strokeAttributes);
        var _attribute$strokeOpac = attribute.strokeOpacity,
          strokeOpacity = _attribute$strokeOpac === void 0 ? defaultParams.strokeOpacity : _attribute$strokeOpac,
          _attribute$opacity = attribute.opacity,
          opacity = _attribute$opacity === void 0 ? defaultParams.opacity : _attribute$opacity;
        if (strokeOpacity > 1e-12 && opacity > 1e-12) {
          var _attribute$lineWidth = attribute.lineWidth,
            lineWidth = _attribute$lineWidth === void 0 ? defaultParams.lineWidth : _attribute$lineWidth,
            _attribute$stroke = attribute.stroke,
            stroke = _attribute$stroke === void 0 ? defaultParams.stroke : _attribute$stroke,
            _attribute$lineJoin = attribute.lineJoin,
            lineJoin = _attribute$lineJoin === void 0 ? defaultParams.lineJoin : _attribute$lineJoin,
            _attribute$lineDash = attribute.lineDash,
            lineDash = _attribute$lineDash === void 0 ? defaultParams.lineDash : _attribute$lineDash,
            _attribute$lineCap = attribute.lineCap,
            lineCap = _attribute$lineCap === void 0 ? defaultParams.lineCap : _attribute$lineCap,
            _attribute$miterLimit = attribute.miterLimit,
            miterLimit = _attribute$miterLimit === void 0 ? defaultParams.miterLimit : _attribute$miterLimit;
          _context.globalAlpha = strokeOpacity * opacity, _context.lineWidth = getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke, params, offsetX, offsetY), _context.lineJoin = lineJoin, 0 === lineDash[0] && 0 === lineDash[1] || _context.setLineDash(lineDash), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
        }
      }
    }, {
      key: "measureText",
      value: function measureText(text) {
        var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : application.global.measureTextMethod;
        this.setTransform(1, 0, 0, 1, 0, 0, !0, application.global.devicePixelRatio);
        return _get(_getPrototypeOf(LynxContext2d.prototype), "measureText", this).call(this, text, method);
      }
    }, {
      key: "createPattern",
      value: function createPattern(image, repetition) {
        return null;
      }
    }, {
      key: "draw",
      value: function draw() {
        var _this = this;
        var _context = this.nativeContext;
        _context.draw && (this.drawPromise = new Promise(function (resolve) {
          _context.draw(!0, function () {
            _this.drawPromise = null, resolve(null);
          });
        }));
      }
    }]);
    return LynxContext2d;
  }(BrowserContext2d);
  LynxContext2d.env = "lynx", LynxContext2d = __decorate$K([injectable()], LynxContext2d);

  var __decorate$J = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$B = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var LynxCanvas = /*#__PURE__*/function (_BaseCanvas) {
    _inherits(LynxCanvas, _BaseCanvas);
    var _super = _createSuper(LynxCanvas);
    function LynxCanvas(params) {
      _classCallCheck(this, LynxCanvas);
      return _super.call(this, params);
    }
    _createClass(LynxCanvas, [{
      key: "init",
      value: function init() {
        this._context = new LynxContext2d(this, this._dpr);
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight, this._nativeCanvas.nativeCanvas && (this._nativeCanvas.nativeCanvas.width = this._pixelWidth, this._nativeCanvas.nativeCanvas.height = this._pixelHeight);
        this._context.dpr = this._dpr;
      }
    }, {
      key: "release",
      value: function release() {}
    }]);
    return LynxCanvas;
  }(exports.BaseCanvas);
  LynxCanvas.env = "lynx", LynxCanvas = __decorate$J([injectable(), __metadata$B("design:paramtypes", [Object])], LynxCanvas);

  var __decorate$I = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$A = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$r = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var MiniAppEventManager$3 = /*#__PURE__*/function () {
    function MiniAppEventManager() {
      _classCallCheck(this, MiniAppEventManager);
      this.cache = {};
    }
    _createClass(MiniAppEventManager, [{
      key: "addEventListener",
      value: function addEventListener(type, func) {
        type && func && (this.cache[type] = this.cache[type] || {
          listener: []
        }, this.cache[type].listener.push(func));
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, func) {
        if (!type || !func) return;
        if (!this.cache[type]) return;
        var index = this.cache[type].listener.findIndex(function (f) {
          return f === func;
        });
        index >= 0 && this.cache[type].listener.splice(index, 1);
      }
    }, {
      key: "cleanEvent",
      value: function cleanEvent() {
        this.cache = {};
      }
    }]);
    return MiniAppEventManager;
  }();
  var LynxWindowHandlerContribution = /*#__PURE__*/function (_BaseWindowHandlerCon) {
    _inherits(LynxWindowHandlerContribution, _BaseWindowHandlerCon);
    var _super = _createSuper(LynxWindowHandlerContribution);
    function LynxWindowHandlerContribution(global) {
      var _this;
      _classCallCheck(this, LynxWindowHandlerContribution);
      _this = _super.call(this), _this.global = global, _this.type = "lynx", _this.eventManager = new MiniAppEventManager$3();
      return _this;
    }
    _createClass(LynxWindowHandlerContribution, [{
      key: "container",
      get: function get() {
        return null;
      }
    }, {
      key: "getTitle",
      value: function getTitle() {
        return this.canvas.id && this.canvas.id.toString();
      }
    }, {
      key: "getWH",
      value: function getWH() {
        return {
          width: this.canvas.width / (this.canvas.dpr || 1),
          height: this.canvas.height / (this.canvas.dpr || 1)
        };
      }
    }, {
      key: "getXY",
      value: function getXY() {
        return {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "createWindow",
      value: function createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
      }
    }, {
      key: "createWindowByConfig",
      value: function createWindowByConfig(params) {
        var nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
          }),
          options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: Generator.GenAutoIncrementId().toString(),
            canvasControled: !1
          };
        this.canvas = new LynxCanvas(options);
      }
    }, {
      key: "createWindowByCanvas",
      value: function createWindowByCanvas(params) {
        var canvas;
        if ("string" == typeof params.canvas) {
          if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        var width = params.width,
          height = params.height;
        if (null == width || null == height || !params.canvasControled) {
          var data = canvas.getBoundingClientRect();
          width = data.width, height = data.height;
        }
        var dpr = params.dpr;
        null == dpr && (dpr = canvas.width / width), this.canvas = new LynxCanvas({
          width: width,
          height: height,
          dpr: dpr,
          nativeCanvas: canvas,
          canvasControled: params.canvasControled
        });
      }
    }, {
      key: "releaseWindow",
      value: function releaseWindow() {}
    }, {
      key: "resizeWindow",
      value: function resizeWindow(width, height) {
        this.canvas.resize(width, height);
      }
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.canvas.getContext();
      }
    }, {
      key: "getNativeHandler",
      value: function getNativeHandler() {
        return this.canvas;
      }
    }, {
      key: "getDpr",
      value: function getDpr() {
        return this.canvas.dpr;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        this.eventManager.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        this.eventManager.removeEventListener(type, listener);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        var type = event.type;
        return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = function () {}, event.stopPropagation = function () {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(function (f) {
          f(event);
        }), !0);
      }
    }, {
      key: "getStyle",
      value: function getStyle() {
        return {};
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {}
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        var wh = this.getWH();
        return {
          x: 0,
          y: 0,
          width: wh.width,
          height: wh.height,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
      }
    }, {
      key: "clearViewBox",
      value: function clearViewBox(color) {
        var vb = this.viewBox,
          context = this.getContext(),
          dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
      }
    }]);
    return LynxWindowHandlerContribution;
  }(exports.BaseWindowHandlerContribution);
  LynxWindowHandlerContribution.env = "lynx", LynxWindowHandlerContribution = __decorate$I([injectable(), __param$r(0, inject(VGlobal)), __metadata$A("design:paramtypes", [Object])], LynxWindowHandlerContribution);
  var lynxWindowModule = new ContainerModule(function (bind) {
    bind(LynxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(function (ctx) {
      return ctx.container.get(LynxWindowHandlerContribution);
    }).whenTargetNamed(LynxWindowHandlerContribution.env);
  });

  var lynxCanvasModule = createModule(LynxCanvas, LynxContext2d);

  var __decorate$H = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$z = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var ng = !1;
  try {
    ng = !!lynx.createCanvasNG;
  } catch (err) {}
  function makeUpCanvas$3(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, offscreen, pixelRatio) {
    var dpr = null != pixelRatio ? pixelRatio : SystemInfo.pixelRatio;
    canvasIdLists.forEach(function (id, i) {
      var _canvas;
      offscreen ? _canvas = lynx.createOffscreenCanvas() : (_canvas = ng ? lynx.createCanvasNG(id) : lynx.createCanvas(id), ng && _canvas.attachToCanvasView(id)), _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr;
      var ctx = _canvas.getContext("2d"),
        canvas = new CanvasWrapEnableWH(_canvas, ctx, dpr, domref.width, domref.height, id);
      canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas);
    });
  }
  function createImageElement(src) {
    var isSvg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    if (isSvg) return Promise.reject();
    var img = lynx.createImage(src);
    return new Promise(function (resolve, reject) {
      img.onload = function () {
        resolve(img);
      }, img.onerror = function () {
        reject(new Error("加载失败"));
      };
    });
  }
  var LynxEnvContribution = /*#__PURE__*/function (_BaseEnvContribution) {
    _inherits(LynxEnvContribution, _BaseEnvContribution);
    var _super = _createSuper(LynxEnvContribution);
    function LynxEnvContribution() {
      var _this;
      _classCallCheck(this, LynxEnvContribution);
      _this = _super.call(this), _this.type = "lynx", _this.supportEvent = !0, _this.canvasMap = new Map(), _this.freeCanvasList = [], _this.canvasIdx = 0, _this.supportsTouchEvents = !0;
      try {
        _this.supportsPointerEvents = !!globalThis.PointerEvent, _this.supportsMouseEvents = !!globalThis.MouseEvent;
      } catch (err) {
        _this.supportsPointerEvents = !1, _this.supportsMouseEvents = !1;
      }
      _this.applyStyles = !0;
      return _this;
    }
    _createClass(LynxEnvContribution, [{
      key: "configure",
      value: function configure(service, params) {
        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas$3(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, !!params.offscreen, params.pixelRatio));
      }
    }, {
      key: "getDynamicCanvasCount",
      value: function getDynamicCanvasCount() {
        return this.freeCanvasList.length;
      }
    }, {
      key: "getStaticCanvasCount",
      value: function getStaticCanvasCount() {
        return 9999;
      }
    }, {
      key: "loadImage",
      value: function loadImage(url) {
        return createImageElement(url, !1).then(function (img) {
          return {
            data: img,
            loadState: "success"
          };
        })["catch"](function () {
          return {
            data: null,
            loadState: "fail"
          };
        });
      }
    }, {
      key: "loadSvg",
      value: function loadSvg(url) {
        return Promise.reject();
      }
    }, {
      key: "createCanvas",
      value: function createCanvas(params) {
        var result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
      }
    }, {
      key: "createOffscreenCanvas",
      value: function createOffscreenCanvas(params) {}
    }, {
      key: "releaseCanvas",
      value: function releaseCanvas(canvas) {}
    }, {
      key: "getDevicePixelRatio",
      value: function getDevicePixelRatio() {
        return SystemInfo.pixelRatio;
      }
    }, {
      key: "getRequestAnimationFrame",
      value: function getRequestAnimationFrame() {
        return function (callback) {
          return rafBasedSto.call(callback);
        };
      }
    }, {
      key: "getCancelAnimationFrame",
      value: function getCancelAnimationFrame() {
        return function (h) {
          rafBasedSto.clear(h);
        };
      }
    }, {
      key: "mapToCanvasPoint",
      value: function mapToCanvasPoint(event) {
        var _a;
        return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return null;
      }
    }, {
      key: "getElementById",
      value: function getElementById(str) {
        return this.canvasMap.get(str);
      }
    }, {
      key: "getRootElement",
      value: function getRootElement() {
        return null;
      }
    }, {
      key: "getDocument",
      value: function getDocument() {
        return null;
      }
    }, {
      key: "release",
      value: function release() {}
    }]);
    return LynxEnvContribution;
  }(exports.BaseEnvContribution);
  LynxEnvContribution = __decorate$H([injectable(), __metadata$z("design:paramtypes", [])], LynxEnvContribution);

  var lynxEnvModule = new ContainerModule(function (bind) {
    lynxEnvModule.isLynxBound || (lynxEnvModule.isLynxBound = !0, bind(LynxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(LynxEnvContribution));
  });
  lynxEnvModule.isLynxBound = !1;
  function loadLynxEnv(container) {
    var loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    loadLynxEnv.__loaded || (loadLynxEnv.__loaded = !0, container.load(lynxEnvModule), container.load(lynxCanvasModule), container.load(lynxWindowModule), loadPicker && loadMathPicker(container));
  }
  loadLynxEnv.__loaded = !1;
  function initLynxEnv() {
    loadLynxEnv(container);
  }

  var __decorate$G = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$y = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var NodeContext2d = /*#__PURE__*/function (_BrowserContext2d) {
    _inherits(NodeContext2d, _BrowserContext2d);
    var _super = _createSuper(NodeContext2d);
    function NodeContext2d(canvas, dpr) {
      var _this;
      _classCallCheck(this, NodeContext2d);
      _this = _super.call(this, canvas, dpr);
      var context = canvas.nativeCanvas.getContext("2d");
      if (!context) throw new Error("发生错误，获取2d上下文失败");
      _this.nativeContext = context, _this.canvas = canvas, _this.matrix = new Matrix(1, 0, 0, 1, 0, 0), _this.stack = [], _this.dpr = null != dpr ? dpr : 1;
      return _this;
    }
    _createClass(NodeContext2d, [{
      key: "release",
      value: function release() {}
    }]);
    return NodeContext2d;
  }(BrowserContext2d);
  NodeContext2d.env = "node", NodeContext2d = __decorate$G([injectable(), __metadata$y("design:paramtypes", [Object, Number])], NodeContext2d);

  var __decorate$F = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$x = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var NodeCanvas = /*#__PURE__*/function (_BaseCanvas) {
    _inherits(NodeCanvas, _BaseCanvas);
    var _super = _createSuper(NodeCanvas);
    function NodeCanvas(params) {
      _classCallCheck(this, NodeCanvas);
      return _super.call(this, params);
    }
    _createClass(NodeCanvas, [{
      key: "init",
      value: function init() {
        this._context = new NodeContext2d(this, this._dpr), this.nativeCanvas.width = this._pixelWidth, this.nativeCanvas.height = this._pixelHeight;
      }
    }, {
      key: "release",
      value: function release() {
        this._nativeCanvas.release && isFunction$1(this._nativeCanvas.release) && this._nativeCanvas.release();
      }
    }]);
    return NodeCanvas;
  }(exports.BaseCanvas);
  NodeCanvas.env = "node", NodeCanvas = __decorate$F([injectable(), __metadata$x("design:paramtypes", [Object])], NodeCanvas);

  var nodeCanvasModule = createModule(NodeCanvas, NodeContext2d);

  var __decorate$E = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$w = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$q = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var NodeWindowHandlerContribution = /*#__PURE__*/function (_BaseWindowHandlerCon) {
    _inherits(NodeWindowHandlerContribution, _BaseWindowHandlerCon);
    var _super = _createSuper(NodeWindowHandlerContribution);
    function NodeWindowHandlerContribution(global) {
      var _this;
      _classCallCheck(this, NodeWindowHandlerContribution);
      _this = _super.call(this), _this.global = global, _this.type = "node";
      return _this;
    }
    _createClass(NodeWindowHandlerContribution, [{
      key: "container",
      get: function get() {
        return null;
      }
    }, {
      key: "getTitle",
      value: function getTitle() {
        return "";
      }
    }, {
      key: "getWH",
      value: function getWH() {
        return {
          width: this.canvas.displayWidth,
          height: this.canvas.displayHeight
        };
      }
    }, {
      key: "getXY",
      value: function getXY() {
        return {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "createWindow",
      value: function createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
      }
    }, {
      key: "createWindowByConfig",
      value: function createWindowByConfig(params) {
        var nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
          }),
          options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: Generator.GenAutoIncrementId().toString(),
            canvasControled: !0
          };
        this.canvas = new NodeCanvas(options);
      }
    }, {
      key: "createWindowByCanvas",
      value: function createWindowByCanvas(params) {
        var canvas = params.canvas;
        var width = params.width,
          height = params.height;
        null != width && null != height && params.canvasControled || (width = canvas.width, height = canvas.height), this.canvas = new NodeCanvas({
          width: width,
          height: height,
          dpr: 1,
          nativeCanvas: canvas,
          canvasControled: params.canvasControled
        });
      }
    }, {
      key: "releaseWindow",
      value: function releaseWindow() {
        this.canvas.release();
      }
    }, {
      key: "resizeWindow",
      value: function resizeWindow(width, height) {
        this.canvas.resize(width, height);
      }
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.canvas.getContext();
      }
    }, {
      key: "getNativeHandler",
      value: function getNativeHandler() {
        return this.canvas;
      }
    }, {
      key: "getDpr",
      value: function getDpr() {
        return this.canvas.dpr;
      }
    }, {
      key: "getImageBuffer",
      value: function getImageBuffer() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "image/png";
        return this.canvas.nativeCanvas.toBuffer(type);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {}
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return !0;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {}
    }, {
      key: "getStyle",
      value: function getStyle() {}
    }, {
      key: "setStyle",
      value: function setStyle(style) {}
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        return null;
      }
    }, {
      key: "clearViewBox",
      value: function clearViewBox(color) {}
    }]);
    return NodeWindowHandlerContribution;
  }(exports.BaseWindowHandlerContribution);
  NodeWindowHandlerContribution.env = "node", NodeWindowHandlerContribution = __decorate$E([injectable(), __param$q(0, inject(VGlobal)), __metadata$w("design:paramtypes", [Object])], NodeWindowHandlerContribution);
  var nodeWindowModule = new ContainerModule(function (bind) {
    bind(NodeWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(function (ctx) {
      return ctx.container.get(NodeWindowHandlerContribution);
    }).whenTargetNamed(NodeWindowHandlerContribution.env);
  });

  var __decorate$D = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var NodeEnvContribution = /*#__PURE__*/function (_BaseEnvContribution) {
    _inherits(NodeEnvContribution, _BaseEnvContribution);
    var _super = _createSuper(NodeEnvContribution);
    function NodeEnvContribution() {
      var _this;
      _classCallCheck(this, NodeEnvContribution);
      _this = _super.apply(this, arguments), _this.type = "node", _this._lastTime = 0, _this.supportEvent = !1;
      return _this;
    }
    _createClass(NodeEnvContribution, [{
      key: "configure",
      value: function configure(service, pkg) {
        service.env === this.type && (service.setActiveEnvContribution(this), this.pkg = pkg);
      }
    }, {
      key: "getDynamicCanvasCount",
      value: function getDynamicCanvasCount() {
        return 0;
      }
    }, {
      key: "getStaticCanvasCount",
      value: function getStaticCanvasCount() {
        return 999;
      }
    }, {
      key: "loadJson",
      value: function loadJson(url) {
        var jsonPromise = fetch(url).then(function (data) {
          return data.json();
        });
        return jsonPromise.then(function (json) {
          return {
            data: json,
            state: "success"
          };
        })["catch"](function () {
          return {
            data: null,
            state: "fail"
          };
        }), jsonPromise;
      }
    }, {
      key: "loadArrayBuffer",
      value: function loadArrayBuffer(url) {
        return fetch(url).then(function (data) {
          return data.arrayBuffer();
        }).then(function (arrayBuffer) {
          return {
            data: arrayBuffer,
            loadState: "success"
          };
        })["catch"](function () {
          return {
            data: null,
            loadState: "fail"
          };
        });
      }
    }, {
      key: "loadImage",
      value: function loadImage(url) {
        var loadImage = this.pkg.loadImage;
        return loadImage ? loadImage(url).then(function (image) {
          return {
            loadState: image ? "success" : "fail",
            data: image
          };
        })["catch"](function () {
          return {
            loadState: "fail",
            data: null
          };
        }) : Promise.reject(new Error("node-canvas loadImage could not be found!"));
      }
    }, {
      key: "loadSvg",
      value: function loadSvg(svgStr) {
        var Resvg = this.pkg.Resvg;
        if (!Resvg) return Promise.reject(new Error("@resvg/resvg-js svgParser could not be found!"));
        var pngData = new Resvg(svgStr).render().asPng();
        return this.loadImage(pngData);
      }
    }, {
      key: "createCanvas",
      value: function createCanvas(params) {
        return this.pkg.createCanvas(params.width, params.height);
      }
    }, {
      key: "releaseCanvas",
      value: function releaseCanvas(canvas) {}
    }, {
      key: "getDevicePixelRatio",
      value: function getDevicePixelRatio() {
        return 1;
      }
    }, {
      key: "getRequestAnimationFrame",
      value: function getRequestAnimationFrame() {
        return function (callback) {
          return rafBasedSto.call(callback);
        };
      }
    }, {
      key: "getCancelAnimationFrame",
      value: function getCancelAnimationFrame() {
        return function (h) {
          rafBasedSto.clear(h);
        };
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {}
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {}
    }, {
      key: "getElementById",
      value: function getElementById(str) {
        return null;
      }
    }, {
      key: "getRootElement",
      value: function getRootElement() {
        return null;
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {}
    }, {
      key: "release",
      value: function release() {}
    }, {
      key: "createOffscreenCanvas",
      value: function createOffscreenCanvas(params) {}
    }]);
    return NodeEnvContribution;
  }(exports.BaseEnvContribution);
  NodeEnvContribution = __decorate$D([injectable()], NodeEnvContribution);

  var nodeEnvModule = new ContainerModule(function (bind) {
    nodeEnvModule.isNodeBound || (nodeEnvModule.isNodeBound = !0, bind(NodeEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(NodeEnvContribution));
  });
  nodeEnvModule.isNodeBound = !1;
  function loadNodeEnv(container) {
    loadNodeEnv.__loaded || (loadNodeEnv.__loaded = !0, container.load(nodeEnvModule), container.load(nodeCanvasModule), container.load(nodeWindowModule));
  }
  loadNodeEnv.__loaded = !1;
  function initNodeEnv() {
    loadNodeEnv(container);
  }

  var __decorate$C = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var TaroContext2d = /*#__PURE__*/function (_BrowserContext2d) {
    _inherits(TaroContext2d, _BrowserContext2d);
    var _super = _createSuper(TaroContext2d);
    function TaroContext2d() {
      _classCallCheck(this, TaroContext2d);
      return _super.apply(this, arguments);
    }
    _createClass(TaroContext2d, [{
      key: "globalAlpha",
      get: function get() {
        return this._globalAlpha;
      },
      set: function set(ga) {
        this.nativeContext.setGlobalAlpha(ga), this._globalAlpha = ga;
      }
    }, {
      key: "draw",
      value: function draw() {
        this.nativeContext.draw();
      }
    }, {
      key: "strokeText",
      value: function strokeText(text, x, y) {}
    }, {
      key: "_setCommonStyle",
      value: function _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.fillAttributes);
        var _attribute$fillOpacit = attribute.fillOpacity,
          fillOpacity = _attribute$fillOpacit === void 0 ? defaultParams.fillOpacity : _attribute$fillOpacit,
          _attribute$opacity = attribute.opacity,
          opacity = _attribute$opacity === void 0 ? defaultParams.opacity : _attribute$opacity,
          _attribute$fill = attribute.fill,
          fill = _attribute$fill === void 0 ? defaultParams.fill : _attribute$fill;
        fillOpacity > 1e-12 && opacity > 1e-12 && (_context.setGlobalAlpha(fillOpacity * opacity), _context.setFillStyle(createColor(this, fill, params, offsetX, offsetY)));
      }
    }, {
      key: "_setStrokeStyle",
      value: function _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.strokeAttributes);
        var _attribute$strokeOpac = attribute.strokeOpacity,
          strokeOpacity = _attribute$strokeOpac === void 0 ? defaultParams.strokeOpacity : _attribute$strokeOpac,
          _attribute$opacity2 = attribute.opacity,
          opacity = _attribute$opacity2 === void 0 ? defaultParams.opacity : _attribute$opacity2;
        if (strokeOpacity > 1e-12 && opacity > 1e-12) {
          var _attribute$lineWidth = attribute.lineWidth,
            lineWidth = _attribute$lineWidth === void 0 ? defaultParams.lineWidth : _attribute$lineWidth,
            _attribute$stroke = attribute.stroke,
            stroke = _attribute$stroke === void 0 ? defaultParams.stroke : _attribute$stroke,
            _attribute$lineJoin = attribute.lineJoin,
            lineJoin = _attribute$lineJoin === void 0 ? defaultParams.lineJoin : _attribute$lineJoin,
            _attribute$lineDash = attribute.lineDash,
            lineDash = _attribute$lineDash === void 0 ? defaultParams.lineDash : _attribute$lineDash,
            _attribute$lineCap = attribute.lineCap,
            lineCap = _attribute$lineCap === void 0 ? defaultParams.lineCap : _attribute$lineCap,
            _attribute$miterLimit = attribute.miterLimit,
            miterLimit = _attribute$miterLimit === void 0 ? defaultParams.miterLimit : _attribute$miterLimit;
          _context.setGlobalAlpha(strokeOpacity * opacity), _context.setLineWidth(getScaledStroke(this, lineWidth, this.dpr)), _context.setStrokeStyle(createColor(this, stroke, params, offsetX, offsetY)), _context.setLineJoin(lineJoin), _context.setLineDash(lineDash), _context.setLineCap(lineCap), _context.setMiterLimit(miterLimit);
        }
      }
    }, {
      key: "setTextStyleWithoutAlignBaseline",
      value: function setTextStyleWithoutAlignBaseline(params, defaultParams) {
        var _a;
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = getContextFont(params, defaultParams), _context.setFontSize(null !== (_a = params.fontSize) && void 0 !== _a ? _a : defaultParams.fontSize);
      }
    }, {
      key: "setTextStyle",
      value: function setTextStyle(params, defaultParams) {
        var _a, _b;
        var _context = this.nativeContext;
        defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = getContextFont(params, defaultParams), _context.setTextAlign(null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign), _context.setTextBaseline(null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline);
      }
    }, {
      key: "createConicGradient",
      value: function createConicGradient(x, y, startAngle, endAngle) {
        return null;
      }
    }, {
      key: "createPattern",
      value: function createPattern(image, repetition) {
        return null;
      }
    }, {
      key: "getImageData",
      value: function getImageData(sx, sy, sw, sh) {
        var _this = this;
        var ctx = this.nativeContext,
          taro = ctx.taro;
        if (ctx && taro) return !ctx.getImageData && taro.canvasGetImageData ? new Promise(function (resolve, reject) {
          try {
            taro.canvasGetImageData({
              canvasId: _this.canvas.nativeCanvas.id,
              sx: sx,
              sy: sy,
              sw: sw,
              sh: sh,
              success: function success(res) {
                resolve(res);
              }
            });
          } catch (err) {
            reject(err);
          }
        }) : void 0;
      }
    }, {
      key: "createRadialGradient",
      value: function createRadialGradient(x0, y0, r0, x1, y1, r1) {
        return this.nativeContext.createCircularGradient && this.nativeContext.createCircularGradient(x0, y0, r0, x1, y1, r1);
      }
    }]);
    return TaroContext2d;
  }(BrowserContext2d);
  TaroContext2d.env = "taro", TaroContext2d = __decorate$C([injectable()], TaroContext2d);

  var __decorate$B = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$v = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var TaroCanvas = /*#__PURE__*/function (_BaseCanvas) {
    _inherits(TaroCanvas, _BaseCanvas);
    var _super = _createSuper(TaroCanvas);
    function TaroCanvas(params) {
      _classCallCheck(this, TaroCanvas);
      return _super.call(this, params);
    }
    _createClass(TaroCanvas, [{
      key: "init",
      value: function init() {
        this._context = new TaroContext2d(this, this._dpr);
      }
    }, {
      key: "release",
      value: function release() {}
    }]);
    return TaroCanvas;
  }(exports.BaseCanvas);
  TaroCanvas.env = "taro", TaroCanvas = __decorate$B([injectable(), __metadata$v("design:paramtypes", [Object])], TaroCanvas);

  var taroCanvasModule = createModule(TaroCanvas, TaroContext2d);

  var __decorate$A = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$u = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$p = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var MiniAppEventManager$2 = /*#__PURE__*/function () {
    function MiniAppEventManager() {
      _classCallCheck(this, MiniAppEventManager);
      this.cache = {};
    }
    _createClass(MiniAppEventManager, [{
      key: "addEventListener",
      value: function addEventListener(type, func) {
        type && func && (this.cache[type] = this.cache[type] || {
          listener: []
        }, this.cache[type].listener.push(func));
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, func) {
        if (!type || !func) return;
        if (!this.cache[type]) return;
        var index = this.cache[type].listener.findIndex(function (f) {
          return f === func;
        });
        index >= 0 && this.cache[type].listener.splice(index, 1);
      }
    }, {
      key: "cleanEvent",
      value: function cleanEvent() {
        this.cache = {};
      }
    }]);
    return MiniAppEventManager;
  }();
  var TaroWindowHandlerContribution = /*#__PURE__*/function (_BaseWindowHandlerCon) {
    _inherits(TaroWindowHandlerContribution, _BaseWindowHandlerCon);
    var _super = _createSuper(TaroWindowHandlerContribution);
    function TaroWindowHandlerContribution(global) {
      var _this;
      _classCallCheck(this, TaroWindowHandlerContribution);
      _this = _super.call(this), _this.global = global, _this.type = "taro", _this.eventManager = new MiniAppEventManager$2();
      return _this;
    }
    _createClass(TaroWindowHandlerContribution, [{
      key: "container",
      get: function get() {
        return null;
      }
    }, {
      key: "getTitle",
      value: function getTitle() {
        return this.canvas.id.toString();
      }
    }, {
      key: "getWH",
      value: function getWH() {
        return {
          width: this.canvas.width / (this.canvas.dpr || 1),
          height: this.canvas.height / (this.canvas.dpr || 1)
        };
      }
    }, {
      key: "getXY",
      value: function getXY() {
        return {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "createWindow",
      value: function createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
      }
    }, {
      key: "createWindowByConfig",
      value: function createWindowByConfig(params) {
        var nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
          }),
          options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: Generator.GenAutoIncrementId().toString(),
            canvasControled: !1
          };
        this.canvas = new TaroCanvas(options);
      }
    }, {
      key: "createWindowByCanvas",
      value: function createWindowByCanvas(params) {
        var canvas;
        if ("string" == typeof params.canvas) {
          if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        var width = params.width,
          height = params.height;
        if (null == width || null == height || !params.canvasControled) {
          var data = canvas.getBoundingClientRect();
          width = data.width, height = data.height;
        }
        var dpr = params.dpr;
        null == dpr && (dpr = canvas.width / width), this.canvas = new TaroCanvas({
          width: width,
          height: height,
          dpr: dpr,
          nativeCanvas: canvas,
          canvasControled: params.canvasControled
        });
      }
    }, {
      key: "releaseWindow",
      value: function releaseWindow() {}
    }, {
      key: "resizeWindow",
      value: function resizeWindow(width, height) {}
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.canvas.getContext();
      }
    }, {
      key: "getNativeHandler",
      value: function getNativeHandler() {
        return this.canvas;
      }
    }, {
      key: "getDpr",
      value: function getDpr() {
        return this.canvas.dpr;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        this.eventManager.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        this.eventManager.removeEventListener(type, listener);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        var type = event.type;
        return !!this.eventManager.cache[type] && (event.changedTouches.length > 0 && (event.changedTouches.forEach(function (d, i) {
          event.changedTouches[i] = Object.assign(Object.assign({}, event.changedTouches[i]), {
            offsetX: d.x,
            offsetY: d.y
          });
        }), event.offsetX = event.changedTouches[0].offsetX, event.offsetY = event.changedTouches[0].offsetY), event.touches.length > 0 && event.touches.forEach(function (d, i) {
          event.touches[i] = Object.assign(Object.assign({}, event.touches[i]), {
            offsetX: d.x,
            offsetY: d.y
          });
        }), event.preventDefault = function () {}, event.stopPropagation = function () {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(function (f) {
          f(event);
        }), !0);
      }
    }, {
      key: "getStyle",
      value: function getStyle() {
        return {};
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {}
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        var wh = this.getWH();
        return {
          x: 0,
          y: 0,
          width: wh.width,
          height: wh.height,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
      }
    }, {
      key: "clearViewBox",
      value: function clearViewBox(color) {
        var vb = this.viewBox,
          context = this.getContext(),
          dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
      }
    }]);
    return TaroWindowHandlerContribution;
  }(exports.BaseWindowHandlerContribution);
  TaroWindowHandlerContribution.env = "taro", TaroWindowHandlerContribution = __decorate$A([injectable(), __param$p(0, inject(VGlobal)), __metadata$u("design:paramtypes", [Object])], TaroWindowHandlerContribution);
  var taroWindowModule = new ContainerModule(function (bind) {
    bind(TaroWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(function (ctx) {
      return ctx.container.get(TaroWindowHandlerContribution);
    }).whenTargetNamed(TaroWindowHandlerContribution.env);
  });

  var __decorate$z = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$t = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  function makeUpCanvas$2(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, taro, dpr) {
    canvasIdLists.forEach(function (id, i) {
      var ctx = taro.createCanvasContext(id),
        canvas = new CanvasWrapDisableWH(ctx.canvas || {}, ctx, dpr, domref.width, domref.height, id);
      return ctx.canvas = canvas, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), canvas;
    });
  }
  var TaroEnvContribution = /*#__PURE__*/function (_BaseEnvContribution) {
    _inherits(TaroEnvContribution, _BaseEnvContribution);
    var _super = _createSuper(TaroEnvContribution);
    function TaroEnvContribution() {
      var _this;
      _classCallCheck(this, TaroEnvContribution);
      _this = _super.call(this), _this.type = "taro", _this.supportEvent = !0, _this.canvasMap = new Map(), _this.freeCanvasList = [], _this.canvasIdx = 0, _this.supportsTouchEvents = !0;
      try {
        _this.supportsPointerEvents = !!globalThis.PointerEvent, _this.supportsMouseEvents = !!globalThis.MouseEvent;
      } catch (err) {
        _this.supportsPointerEvents = !1, _this.supportsMouseEvents = !1;
      }
      _this.applyStyles = !0;
      return _this;
    }
    _createClass(TaroEnvContribution, [{
      key: "getDynamicCanvasCount",
      value: function getDynamicCanvasCount() {
        return this.freeCanvasList.length;
      }
    }, {
      key: "getStaticCanvasCount",
      value: function getStaticCanvasCount() {
        return 9999;
      }
    }, {
      key: "mapToCanvasPoint",
      value: function mapToCanvasPoint(event) {
        var _a;
        return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
      }
    }, {
      key: "configure",
      value: function configure(service, params) {
        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas$2(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.taro, params.pixelRatio), this.taro = params.taro, this.pixelRatio = params.pixelRatio);
      }
    }, {
      key: "loadImage",
      value: function loadImage(url) {
        return Promise.resolve({
          data: url,
          loadState: "success"
        });
      }
    }, {
      key: "loadSvg",
      value: function loadSvg(svgStr) {
        var _window = window || globalThis;
        if (_window.DOMParser) {
          var svg = new _window.DOMParser().parseFromString(svgStr, "image/svg+xml").children[0],
            data = new XMLSerializer().serializeToString(svg),
            url = "data:image/svg+xml;charset=utf-8,".concat(encodeURIComponent(data));
          return Promise.resolve({
            data: url,
            loadState: "success"
          });
        }
        if (_window.Blob) {
          var _data = new _window.Blob([svgStr], {
              type: "image/svg+xml"
            }),
            _url = _window.URL.createObjectURL(_data);
          return Promise.resolve({
            data: _url,
            loadState: "success"
          });
        }
        return Promise.reject();
      }
    }, {
      key: "createCanvas",
      value: function createCanvas(params) {
        var result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
      }
    }, {
      key: "createOffscreenCanvas",
      value: function createOffscreenCanvas(params) {}
    }, {
      key: "releaseCanvas",
      value: function releaseCanvas(canvas) {}
    }, {
      key: "getDevicePixelRatio",
      value: function getDevicePixelRatio() {
        return this.pixelRatio;
      }
    }, {
      key: "getRequestAnimationFrame",
      value: function getRequestAnimationFrame() {
        return requestAnimationFrame;
      }
    }, {
      key: "getCancelAnimationFrame",
      value: function getCancelAnimationFrame() {
        return cancelAnimationFrame;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return null;
      }
    }, {
      key: "getElementById",
      value: function getElementById(str) {
        return this.canvasMap.get(str);
      }
    }, {
      key: "getRootElement",
      value: function getRootElement() {
        return null;
      }
    }, {
      key: "getDocument",
      value: function getDocument() {
        return null;
      }
    }, {
      key: "release",
      value: function release() {}
    }]);
    return TaroEnvContribution;
  }(exports.BaseEnvContribution);
  TaroEnvContribution = __decorate$z([injectable(), __metadata$t("design:paramtypes", [])], TaroEnvContribution);

  var taroEnvModule = new ContainerModule(function (bind) {
    taroEnvModule.isTaroBound || (taroEnvModule.isTaroBound = !0, bind(TaroEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(TaroEnvContribution));
  });
  taroEnvModule.isTaroBound = !1;
  function loadTaroEnv(container) {
    var loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    loadTaroEnv.__loaded || (loadTaroEnv.__loaded = !0, container.load(taroEnvModule), container.load(taroCanvasModule), container.load(taroWindowModule), loadPicker && loadMathPicker(container));
  }
  loadTaroEnv.__loaded = !1;
  function initTaroEnv() {
    loadTaroEnv(container);
  }

  var __decorate$y = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var WxContext2d = /*#__PURE__*/function (_BrowserContext2d) {
    _inherits(WxContext2d, _BrowserContext2d);
    var _super = _createSuper(WxContext2d);
    function WxContext2d() {
      _classCallCheck(this, WxContext2d);
      return _super.apply(this, arguments);
    }
    _createClass(WxContext2d, [{
      key: "draw",
      value: function draw() {}
    }, {
      key: "createPattern",
      value: function createPattern(image, repetition) {
        return null;
      }
    }]);
    return WxContext2d;
  }(BrowserContext2d);
  WxContext2d.env = "wx", WxContext2d = __decorate$y([injectable()], WxContext2d);

  var __decorate$x = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$s = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var WxCanvas = /*#__PURE__*/function (_BaseCanvas) {
    _inherits(WxCanvas, _BaseCanvas);
    var _super = _createSuper(WxCanvas);
    function WxCanvas(params) {
      _classCallCheck(this, WxCanvas);
      return _super.call(this, params);
    }
    _createClass(WxCanvas, [{
      key: "init",
      value: function init() {
        this._context = new WxContext2d(this, this._dpr);
      }
    }, {
      key: "release",
      value: function release() {}
    }]);
    return WxCanvas;
  }(exports.BaseCanvas);
  WxCanvas.env = "wx", WxCanvas = __decorate$x([injectable(), __metadata$s("design:paramtypes", [Object])], WxCanvas);

  var wxCanvasModule = createModule(WxCanvas, WxContext2d);

  var __decorate$w = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$r = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$o = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var MiniAppEventManager$1 = /*#__PURE__*/function () {
    function MiniAppEventManager() {
      _classCallCheck(this, MiniAppEventManager);
      this.cache = {};
    }
    _createClass(MiniAppEventManager, [{
      key: "addEventListener",
      value: function addEventListener(type, func) {
        type && func && (this.cache[type] = this.cache[type] || {
          listener: []
        }, this.cache[type].listener.push(func));
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, func) {
        if (!type || !func) return;
        if (!this.cache[type]) return;
        var index = this.cache[type].listener.findIndex(function (f) {
          return f === func;
        });
        index >= 0 && this.cache[type].listener.splice(index, 1);
      }
    }, {
      key: "cleanEvent",
      value: function cleanEvent() {
        this.cache = {};
      }
    }]);
    return MiniAppEventManager;
  }();
  var WxWindowHandlerContribution = /*#__PURE__*/function (_BaseWindowHandlerCon) {
    _inherits(WxWindowHandlerContribution, _BaseWindowHandlerCon);
    var _super = _createSuper(WxWindowHandlerContribution);
    function WxWindowHandlerContribution(global) {
      var _this;
      _classCallCheck(this, WxWindowHandlerContribution);
      _this = _super.call(this), _this.global = global, _this.type = "wx", _this.eventManager = new MiniAppEventManager$1();
      return _this;
    }
    _createClass(WxWindowHandlerContribution, [{
      key: "container",
      get: function get() {
        return null;
      }
    }, {
      key: "getTitle",
      value: function getTitle() {
        return this.canvas.id.toString();
      }
    }, {
      key: "getWH",
      value: function getWH() {
        return {
          width: this.canvas.width / (this.canvas.dpr || 1),
          height: this.canvas.height / (this.canvas.dpr || 1)
        };
      }
    }, {
      key: "getXY",
      value: function getXY() {
        return {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "createWindow",
      value: function createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
      }
    }, {
      key: "createWindowByConfig",
      value: function createWindowByConfig(params) {
        var nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
          }),
          options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: Generator.GenAutoIncrementId().toString(),
            canvasControled: !1
          };
        this.canvas = new WxCanvas(options);
      }
    }, {
      key: "createWindowByCanvas",
      value: function createWindowByCanvas(params) {
        var canvas;
        if ("string" == typeof params.canvas) {
          if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        var width = params.width,
          height = params.height;
        if (null == width || null == height || !params.canvasControled) {
          var data = canvas.getBoundingClientRect();
          width = data.width, height = data.height;
        }
        var dpr = params.dpr;
        null == dpr && (dpr = canvas.width / width), this.canvas = new WxCanvas({
          width: width,
          height: height,
          dpr: dpr,
          nativeCanvas: canvas,
          canvasControled: params.canvasControled
        });
      }
    }, {
      key: "releaseWindow",
      value: function releaseWindow() {}
    }, {
      key: "resizeWindow",
      value: function resizeWindow(width, height) {}
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.canvas.getContext();
      }
    }, {
      key: "getNativeHandler",
      value: function getNativeHandler() {
        return this.canvas;
      }
    }, {
      key: "getDpr",
      value: function getDpr() {
        return this.canvas.dpr;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        this.eventManager.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        this.eventManager.removeEventListener(type, listener);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        var _a, _b, _c, _d;
        var type = event.type;
        return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = null !== (_a = event.changedTouches[0].x) && void 0 !== _a ? _a : event.changedTouches[0].pageX, event.changedTouches[0].clientX = null !== (_b = event.changedTouches[0].x) && void 0 !== _b ? _b : event.changedTouches[0].pageX, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = null !== (_c = event.changedTouches[0].y) && void 0 !== _c ? _c : event.changedTouches[0].pageY, event.changedTouches[0].clientY = null !== (_d = event.changedTouches[0].y) && void 0 !== _d ? _d : event.changedTouches[0].pageY), event.preventDefault = function () {}, event.stopPropagation = function () {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(function (f) {
          f(event);
        }), !0);
      }
    }, {
      key: "getStyle",
      value: function getStyle() {
        return {};
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {}
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        var wh = this.getWH();
        return {
          x: 0,
          y: 0,
          width: wh.width,
          height: wh.height,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
      }
    }, {
      key: "clearViewBox",
      value: function clearViewBox(color) {
        var vb = this.viewBox,
          context = this.getContext(),
          dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
      }
    }]);
    return WxWindowHandlerContribution;
  }(exports.BaseWindowHandlerContribution);
  WxWindowHandlerContribution.env = "wx", WxWindowHandlerContribution = __decorate$w([injectable(), __param$o(0, inject(VGlobal)), __metadata$r("design:paramtypes", [Object])], WxWindowHandlerContribution);
  var wxWindowModule = new ContainerModule(function (bind) {
    bind(WxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(function (ctx) {
      return ctx.container.get(WxWindowHandlerContribution);
    }).whenTargetNamed(WxWindowHandlerContribution.env);
  });

  var __decorate$v = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$q = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
  function makeUpCanvas$1(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component) {
    return __awaiter$1(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var dpr, _loop, i;
      return _regeneratorRuntime().wrap(function _callee$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            dpr = wx.getSystemInfoSync().pixelRatio;
            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(i) {
              var id;
              return _regeneratorRuntime().wrap(function _loop$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    id = canvasIdLists[i];
                    _context.next = 3;
                    return new Promise(function (resolve) {
                      var data = wx.createSelectorQuery();
                      component && (data = data["in"](component)), data.select("#".concat(id)).fields({
                        node: !0,
                        size: !0
                      }).exec(function (res) {
                        if (!res[0]) return;
                        var canvas = res[0].node,
                          width = res[0].width,
                          height = res[0].height;
                        canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
                      });
                    });
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }, _loop);
            });
            i = 0;
          case 3:
            if (!(i < canvasIdLists.length)) {
              _context2.next = 8;
              break;
            }
            return _context2.delegateYield(_loop(i), "t0", 5);
          case 5:
            i++;
            _context2.next = 3;
            break;
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee);
    }));
  }
  var WxEnvContribution = /*#__PURE__*/function (_BaseEnvContribution) {
    _inherits(WxEnvContribution, _BaseEnvContribution);
    var _super = _createSuper(WxEnvContribution);
    function WxEnvContribution() {
      var _this;
      _classCallCheck(this, WxEnvContribution);
      _this = _super.call(this), _this.type = "wx", _this.supportEvent = !0, _this.canvasMap = new Map(), _this.freeCanvasList = [], _this.canvasIdx = 0, _this.supportsTouchEvents = !0;
      try {
        _this.supportsPointerEvents = !!globalThis.PointerEvent, _this.supportsMouseEvents = !!globalThis.MouseEvent;
      } catch (err) {
        _this.supportsPointerEvents = !1, _this.supportsMouseEvents = !1;
      }
      _this.applyStyles = !0;
      return _this;
    }
    _createClass(WxEnvContribution, [{
      key: "configure",
      value: function configure(service, params) {
        if (service.env === this.type) return service.setActiveEnvContribution(this), makeUpCanvas$1(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.component).then(function () {});
      }
    }, {
      key: "loadImage",
      value: function loadImage(url) {
        return Promise.resolve({
          data: url,
          loadState: "success"
        });
      }
    }, {
      key: "loadSvg",
      value: function loadSvg(url) {
        return Promise.reject();
      }
    }, {
      key: "createCanvas",
      value: function createCanvas(params) {
        var result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
      }
    }, {
      key: "createOffscreenCanvas",
      value: function createOffscreenCanvas(params) {}
    }, {
      key: "releaseCanvas",
      value: function releaseCanvas(canvas) {}
    }, {
      key: "getDevicePixelRatio",
      value: function getDevicePixelRatio() {
        return wx.getSystemInfoSync().pixelRatio;
      }
    }, {
      key: "getRequestAnimationFrame",
      value: function getRequestAnimationFrame() {
        return function (callback) {
          return rafBasedSto.call(callback);
        };
      }
    }, {
      key: "getCancelAnimationFrame",
      value: function getCancelAnimationFrame() {
        return function (h) {
          rafBasedSto.clear(h);
        };
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return null;
      }
    }, {
      key: "getElementById",
      value: function getElementById(str) {
        return this.canvasMap.get(str);
      }
    }, {
      key: "getRootElement",
      value: function getRootElement() {
        return null;
      }
    }, {
      key: "getDocument",
      value: function getDocument() {
        return null;
      }
    }, {
      key: "release",
      value: function release() {}
    }, {
      key: "mapToCanvasPoint",
      value: function mapToCanvasPoint(event) {
        var _a;
        return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
      }
    }]);
    return WxEnvContribution;
  }(exports.BaseEnvContribution);
  WxEnvContribution = __decorate$v([injectable(), __metadata$q("design:paramtypes", [])], WxEnvContribution);

  var wxEnvModule = new ContainerModule(function (bind) {
    wxEnvModule._isWxBound || (wxEnvModule._isWxBound = !0, bind(WxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(WxEnvContribution));
  });
  wxEnvModule._isWxBound = !1;
  function loadWxEnv(container) {
    var loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    loadWxEnv.__loaded || (loadWxEnv.__loaded = !0, container.load(wxEnvModule), container.load(wxCanvasModule), container.load(wxWindowModule), loadPicker && loadMathPicker(container));
  }
  loadWxEnv.__loaded = !1;
  function initWxEnv() {
    loadWxEnv(container);
  }

  function loadAllEnv(container) {
    loadAllModule(container);
  }
  function loadAllModule(container) {
    loadAllModule.__loaded || (loadAllModule.__loaded = !0, loadBrowserEnv(container, !1), loadFeishuEnv(container, !1), loadLynxEnv(container, !1), loadNodeEnv(container), loadTaroEnv(container, !1), loadWxEnv(container, !1), loadCanvasPicker(container), vglobal.hooks.onSetEnv.tap("loadMathPicker", function (lastEnv, env) {
      "browser" !== env && loadMathPicker(container);
    }));
  }
  loadAllModule.__loaded = !1;
  function initAllEnv() {
    loadAllEnv(container);
  }

  var __decorate$u = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var TTContext2d = /*#__PURE__*/function (_FeishuContext2d) {
    _inherits(TTContext2d, _FeishuContext2d);
    var _super = _createSuper(TTContext2d);
    function TTContext2d() {
      _classCallCheck(this, TTContext2d);
      return _super.apply(this, arguments);
    }
    return _createClass(TTContext2d);
  }(FeishuContext2d);
  TTContext2d.env = "tt", TTContext2d = __decorate$u([injectable()], TTContext2d);

  var __decorate$t = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$p = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    };
  var TTCanvas = /*#__PURE__*/function (_BaseCanvas) {
    _inherits(TTCanvas, _BaseCanvas);
    var _super = _createSuper(TTCanvas);
    function TTCanvas(params) {
      _classCallCheck(this, TTCanvas);
      return _super.call(this, params);
    }
    _createClass(TTCanvas, [{
      key: "init",
      value: function init() {
        this._context = new TTContext2d(this, this._dpr);
      }
    }, {
      key: "release",
      value: function release() {}
    }]);
    return TTCanvas;
  }(exports.BaseCanvas);
  TTCanvas.env = "tt", TTCanvas = __decorate$t([injectable(), __metadata$p("design:paramtypes", [Object])], TTCanvas);

  var ttCanvasModule = createModule(TTCanvas, TTContext2d);

  var __decorate$s = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$o = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$n = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var MiniAppEventManager = /*#__PURE__*/function () {
    function MiniAppEventManager() {
      _classCallCheck(this, MiniAppEventManager);
      this.cache = {};
    }
    _createClass(MiniAppEventManager, [{
      key: "addEventListener",
      value: function addEventListener(type, func) {
        type && func && (this.cache[type] = this.cache[type] || {
          listener: []
        }, this.cache[type].listener.push(func));
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, func) {
        if (!type || !func) return;
        if (!this.cache[type]) return;
        var index = this.cache[type].listener.findIndex(function (f) {
          return f === func;
        });
        index >= 0 && this.cache[type].listener.splice(index, 1);
      }
    }, {
      key: "cleanEvent",
      value: function cleanEvent() {
        this.cache = {};
      }
    }]);
    return MiniAppEventManager;
  }();
  var TTWindowHandlerContribution = /*#__PURE__*/function (_BaseWindowHandlerCon) {
    _inherits(TTWindowHandlerContribution, _BaseWindowHandlerCon);
    var _super = _createSuper(TTWindowHandlerContribution);
    function TTWindowHandlerContribution(global) {
      var _this;
      _classCallCheck(this, TTWindowHandlerContribution);
      _this = _super.call(this), _this.global = global, _this.type = "tt", _this.eventManager = new MiniAppEventManager();
      return _this;
    }
    _createClass(TTWindowHandlerContribution, [{
      key: "container",
      get: function get() {
        return null;
      }
    }, {
      key: "getTitle",
      value: function getTitle() {
        return this.canvas.id.toString();
      }
    }, {
      key: "getWH",
      value: function getWH() {
        return {
          width: this.canvas.width / (this.canvas.dpr || 1),
          height: this.canvas.height / (this.canvas.dpr || 1)
        };
      }
    }, {
      key: "getXY",
      value: function getXY() {
        return {
          x: 0,
          y: 0
        };
      }
    }, {
      key: "createWindow",
      value: function createWindow(params) {
        params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
      }
    }, {
      key: "createWindowByConfig",
      value: function createWindowByConfig(params) {
        var nativeCanvas = this.global.createCanvas({
            width: params.width,
            height: params.height
          }),
          options = {
            width: params.width,
            height: params.height,
            dpr: params.dpr,
            nativeCanvas: nativeCanvas,
            id: Generator.GenAutoIncrementId().toString(),
            canvasControled: !1
          };
        this.canvas = new TTCanvas(options);
      }
    }, {
      key: "createWindowByCanvas",
      value: function createWindowByCanvas(params) {
        var canvas;
        if ("string" == typeof params.canvas) {
          if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
        } else canvas = params.canvas;
        var width = params.width,
          height = params.height;
        if (null == width || null == height || !params.canvasControled) {
          var data = canvas.getBoundingClientRect();
          width = data.width, height = data.height;
        }
        var dpr = params.dpr;
        null == dpr && (dpr = canvas.width / width), this.canvas = new TTCanvas({
          width: width,
          height: height,
          dpr: dpr,
          nativeCanvas: canvas,
          canvasControled: params.canvasControled
        });
      }
    }, {
      key: "releaseWindow",
      value: function releaseWindow() {}
    }, {
      key: "resizeWindow",
      value: function resizeWindow(width, height) {}
    }, {
      key: "setDpr",
      value: function setDpr(dpr) {
        this.canvas.dpr = dpr;
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.canvas.getContext();
      }
    }, {
      key: "getNativeHandler",
      value: function getNativeHandler() {
        return this.canvas;
      }
    }, {
      key: "getDpr",
      value: function getDpr() {
        return this.canvas.dpr;
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        this.eventManager.addEventListener(type, listener);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        this.eventManager.removeEventListener(type, listener);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        var type = event.type;
        return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = function () {}, event.stopPropagation = function () {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(function (f) {
          f(event);
        }), !0);
      }
    }, {
      key: "getStyle",
      value: function getStyle() {
        return {};
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {}
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        var wh = this.getWH();
        return {
          x: 0,
          y: 0,
          width: wh.width,
          height: wh.height,
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        };
      }
    }, {
      key: "clearViewBox",
      value: function clearViewBox(color) {
        var vb = this.viewBox,
          context = this.getContext(),
          dpr = this.getDpr();
        context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
      }
    }]);
    return TTWindowHandlerContribution;
  }(exports.BaseWindowHandlerContribution);
  TTWindowHandlerContribution.env = "tt", TTWindowHandlerContribution = __decorate$s([injectable(), __param$n(0, inject(VGlobal)), __metadata$o("design:paramtypes", [Object])], TTWindowHandlerContribution);
  var ttWindowModule = new ContainerModule(function (bind) {
    bind(TTWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(function (ctx) {
      return ctx.container.get(TTWindowHandlerContribution);
    }).whenTargetNamed(TTWindowHandlerContribution.env);
  });

  var __decorate$r = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$n = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          var value;
          result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
            resolve(value);
          })).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
  function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var dpr, _loop, i;
      return _regeneratorRuntime().wrap(function _callee$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            dpr = tt.getSystemInfoSync().pixelRatio;
            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(i) {
              var id;
              return _regeneratorRuntime().wrap(function _loop$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    id = canvasIdLists[i];
                    _context.next = 3;
                    return new Promise(function (resolve) {
                      var data = tt.createSelectorQuery();
                      component && (data = data["in"](component)), data.select("#".concat(id)).fields({
                        node: !0,
                        size: !0
                      }).exec(function (res) {
                        if (!res[0]) return;
                        var canvas = res[0].node,
                          width = res[0].width,
                          height = res[0].height;
                        canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
                      });
                    });
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }, _loop);
            });
            i = 0;
          case 3:
            if (!(i < canvasIdLists.length)) {
              _context2.next = 8;
              break;
            }
            return _context2.delegateYield(_loop(i), "t0", 5);
          case 5:
            i++;
            _context2.next = 3;
            break;
          case 8:
          case "end":
            return _context2.stop();
        }
      }, _callee);
    }));
  }
  var TTEnvContribution = /*#__PURE__*/function (_BaseEnvContribution) {
    _inherits(TTEnvContribution, _BaseEnvContribution);
    var _super = _createSuper(TTEnvContribution);
    function TTEnvContribution() {
      var _this;
      _classCallCheck(this, TTEnvContribution);
      _this = _super.call(this), _this.type = "tt", _this.supportEvent = !0, _this.canvasMap = new Map(), _this.freeCanvasList = [], _this.canvasIdx = 0, _this.supportsTouchEvents = !0;
      try {
        _this.supportsPointerEvents = !!globalThis.PointerEvent, _this.supportsMouseEvents = !!globalThis.MouseEvent;
      } catch (err) {
        _this.supportsPointerEvents = !1, _this.supportsMouseEvents = !1;
      }
      _this.applyStyles = !0;
      return _this;
    }
    _createClass(TTEnvContribution, [{
      key: "configure",
      value: function configure(service, params) {
        if (service.env === this.type) return service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.component).then(function () {});
      }
    }, {
      key: "loadImage",
      value: function loadImage(url) {
        return Promise.resolve({
          data: url,
          loadState: "success"
        });
      }
    }, {
      key: "loadSvg",
      value: function loadSvg(url) {
        return Promise.reject();
      }
    }, {
      key: "createCanvas",
      value: function createCanvas(params) {
        var result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
      }
    }, {
      key: "createOffscreenCanvas",
      value: function createOffscreenCanvas(params) {}
    }, {
      key: "releaseCanvas",
      value: function releaseCanvas(canvas) {}
    }, {
      key: "getDevicePixelRatio",
      value: function getDevicePixelRatio() {
        return tt.getSystemInfoSync().pixelRatio;
      }
    }, {
      key: "getRequestAnimationFrame",
      value: function getRequestAnimationFrame() {
        return function (callback) {
          return rafBasedSto.call(callback);
        };
      }
    }, {
      key: "getCancelAnimationFrame",
      value: function getCancelAnimationFrame() {
        return function (h) {
          rafBasedSto.clear(h);
        };
      }
    }, {
      key: "addEventListener",
      value: function addEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener, options) {
        return null;
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        return null;
      }
    }, {
      key: "getElementById",
      value: function getElementById(str) {
        return this.canvasMap.get(str);
      }
    }, {
      key: "getRootElement",
      value: function getRootElement() {
        return null;
      }
    }, {
      key: "getDocument",
      value: function getDocument() {
        return null;
      }
    }, {
      key: "release",
      value: function release() {}
    }, {
      key: "mapToCanvasPoint",
      value: function mapToCanvasPoint(event) {
        var _a;
        return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
      }
    }]);
    return TTEnvContribution;
  }(exports.BaseEnvContribution);
  TTEnvContribution = __decorate$r([injectable(), __metadata$n("design:paramtypes", [])], TTEnvContribution);

  var ttEnvModule = new ContainerModule(function (bind) {
    ttEnvModule.isTTBound || (ttEnvModule.isTTBound = !0, bind(TTEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(TTEnvContribution));
  });
  ttEnvModule.isTTBound = !1;
  function loadTTEnv(container) {
    var loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    loadTTEnv.__loaded || (loadTTEnv.__loaded = !0, container.load(ttEnvModule), container.load(ttCanvasModule), container.load(ttWindowModule), loadPicker && loadMathPicker(container));
  }
  loadTTEnv.__loaded = !1;
  function initTTEnv() {
    loadTTEnv(container);
  }

  var __decorate$q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$m = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$m = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasArcPicker = /*#__PURE__*/function () {
    function DefaultCanvasArcPicker(canvasRenderer) {
      _classCallCheck(this, DefaultCanvasArcPicker);
      this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasArcPicker, [{
      key: "contains",
      value: function contains(arc, point, params) {
        if (!arc.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === arc.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var arcAttribute = getTheme(arc).arc;
        pickContext.highPerformanceSave();
        var _arc$attribute = arc.attribute,
          _arc$attribute$x = _arc$attribute.x,
          x = _arc$attribute$x === void 0 ? arcAttribute.x : _arc$attribute$x,
          _arc$attribute$y = _arc$attribute.y,
          y = _arc$attribute$y === void 0 ? arcAttribute.y : _arc$attribute$y;
        if (arc.transMatrix.onlyTranslate()) {
          var _point = arc.getOffsetXY(arcAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(arc.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, function (context, arcAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, arcAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = arcAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasArcPicker;
  }();
  DefaultCanvasArcPicker = __decorate$q([injectable(), __param$m(0, inject(ArcRender)), __metadata$m("design:paramtypes", [Object])], DefaultCanvasArcPicker);

  var loadArcPick$1 = !1;
  var arcCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadArcPick$1 || (loadArcPick$1 = !0, bind(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArcPicker));
  });

  var __decorate$p = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$l = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$l = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultMathArcPicker = /*#__PURE__*/function () {
    function DefaultMathArcPicker(canvasRenderer) {
      _classCallCheck(this, DefaultMathArcPicker);
      this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
    }
    _createClass(DefaultMathArcPicker, [{
      key: "contains",
      value: function contains(arc, point, params) {
        if (!arc.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === arc.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var arcAttribute = getTheme(arc).arc;
        pickContext.highPerformanceSave();
        var _arc$attribute = arc.attribute,
          _arc$attribute$x = _arc$attribute.x,
          x = _arc$attribute$x === void 0 ? arcAttribute.x : _arc$attribute$x,
          _arc$attribute$y = _arc$attribute.y,
          y = _arc$attribute$y === void 0 ? arcAttribute.y : _arc$attribute$y;
        if (arc.transMatrix.onlyTranslate()) {
          var _point = arc.getOffsetXY(arcAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(arc.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, function (context, arcAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, arcAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = arcAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultMathArcPicker;
  }();
  DefaultMathArcPicker = __decorate$p([injectable(), __param$l(0, inject(ArcRender)), __metadata$l("design:paramtypes", [Object])], DefaultMathArcPicker);

  var loadArcPick = !1;
  var arcMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadArcPick || (loadArcPick = !0, bind(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathArcPicker));
  });

  var __decorate$o = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$k = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$k = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var _bounds$1 = new AABBBounds();
  var DefaultCanvasRectPicker = /*#__PURE__*/function () {
    function DefaultCanvasRectPicker(canvasRenderer) {
      _classCallCheck(this, DefaultCanvasRectPicker);
      this.canvasRenderer = canvasRenderer, this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasRectPicker, [{
      key: "contains",
      value: function contains(rect, point, params) {
        if (!rect.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === rect.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var rectAttribute = getTheme(rect).rect,
          _rect$attribute$corne = rect.attribute.cornerRadius,
          cornerRadius = _rect$attribute$corne === void 0 ? rectAttribute.cornerRadius : _rect$attribute$corne;
        var _rect$attribute = rect.attribute,
          _rect$attribute$x = _rect$attribute.x,
          x = _rect$attribute$x === void 0 ? rectAttribute.x : _rect$attribute$x,
          _rect$attribute$y = _rect$attribute.y,
          y = _rect$attribute$y === void 0 ? rectAttribute.y : _rect$attribute$y;
        pickContext.highPerformanceSave();
        var onlyTranslate = !0;
        if (rect.transMatrix.onlyTranslate()) {
          var _point = rect.getOffsetXY(rectAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);
        var picked = !0;
        if (!onlyTranslate || rect.shadowRoot || isNumber$1(cornerRadius, !0) && 0 !== cornerRadius || isArray$1(cornerRadius) && cornerRadius.some(function (num) {
          return 0 !== num;
        })) picked = !1, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, function (context, rectAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, rectAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = rectAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), picked;
        });else {
          var _rect$attribute2 = rect.attribute,
            _rect$attribute2$fill = _rect$attribute2.fill,
            fill = _rect$attribute2$fill === void 0 ? rectAttribute.fill : _rect$attribute2$fill,
            _rect$attribute2$stro = _rect$attribute2.stroke,
            stroke = _rect$attribute2$stro === void 0 ? rectAttribute.stroke : _rect$attribute2$stro,
            _rect$attribute2$line = _rect$attribute2.lineWidth,
            lineWidth = _rect$attribute2$line === void 0 ? rectAttribute.lineWidth : _rect$attribute2$line;
          if (fill) picked = !0;else if (stroke) {
            var bounds = rect.AABBBounds;
            _bounds$1.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds$1.expand(-lineWidth / 2), picked = !_bounds$1.containsPoint(point);
          }
        }
        return pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasRectPicker;
  }();
  DefaultCanvasRectPicker = __decorate$o([injectable(), __param$k(0, inject(RectRender)), __metadata$k("design:paramtypes", [Object])], DefaultCanvasRectPicker);

  var loadRectPick$1 = !1;
  var rectCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadRectPick$1 || (loadRectPick$1 = !0, bind(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRectPicker));
  });

  var __decorate$n = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$j = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$j = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var _bounds = new AABBBounds();
  var DefaultMathRectPicker = /*#__PURE__*/function () {
    function DefaultMathRectPicker(canvasRenderer) {
      _classCallCheck(this, DefaultMathRectPicker);
      this.canvasRenderer = canvasRenderer, this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
    }
    _createClass(DefaultMathRectPicker, [{
      key: "contains",
      value: function contains(rect, point, params) {
        if (!rect.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === rect.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var rectAttribute = getTheme(rect).rect,
          _rect$attribute$corne = rect.attribute.cornerRadius,
          cornerRadius = _rect$attribute$corne === void 0 ? rectAttribute.cornerRadius : _rect$attribute$corne;
        var _rect$attribute = rect.attribute,
          _rect$attribute$x = _rect$attribute.x,
          x = _rect$attribute$x === void 0 ? rectAttribute.x : _rect$attribute$x,
          _rect$attribute$y = _rect$attribute.y,
          y = _rect$attribute$y === void 0 ? rectAttribute.y : _rect$attribute$y;
        pickContext.highPerformanceSave();
        var onlyTranslate = !0;
        if (rect.transMatrix.onlyTranslate()) {
          var _point = rect.getOffsetXY(rectAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);
        var picked = !0;
        if (!onlyTranslate || isNumber$1(cornerRadius, !0) && 0 !== cornerRadius || isArray$1(cornerRadius) && cornerRadius.some(function (num) {
          return 0 !== num;
        })) picked = !1, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, function (context, rectAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, rectAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = rectAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point.x, point.y), picked;
        });else if (picked) {
          var _rect$attribute2 = rect.attribute,
            _rect$attribute2$fill = _rect$attribute2.fill,
            fill = _rect$attribute2$fill === void 0 ? rectAttribute.fill : _rect$attribute2$fill,
            _rect$attribute2$stro = _rect$attribute2.stroke,
            stroke = _rect$attribute2$stro === void 0 ? rectAttribute.stroke : _rect$attribute2$stro,
            _rect$attribute2$line = _rect$attribute2.lineWidth,
            lineWidth = _rect$attribute2$line === void 0 ? rectAttribute.lineWidth : _rect$attribute2$line;
          if (fill) picked = !0;else if (stroke) {
            var bounds = rect.AABBBounds;
            _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), picked = !_bounds.containsPoint(point);
          }
        }
        return pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultMathRectPicker;
  }();
  DefaultMathRectPicker = __decorate$n([injectable(), __param$j(0, inject(RectRender)), __metadata$j("design:paramtypes", [Object])], DefaultMathRectPicker);

  var loadRectPick = !1;
  var rectMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadRectPick || (loadRectPick = !0, bind(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathRectPicker));
  });

  var __decorate$m = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var BasePicker = /*#__PURE__*/function (_BaseRender) {
    _inherits(BasePicker, _BaseRender);
    var _super = _createSuper(BasePicker);
    function BasePicker() {
      _classCallCheck(this, BasePicker);
      return _super.apply(this, arguments);
    }
    return _createClass(BasePicker);
  }(BaseRender);
  BasePicker = __decorate$m([injectable()], BasePicker);

  var __decorate$l = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$i = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$i = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasLinePicker = /*#__PURE__*/function (_BasePicker) {
    _inherits(DefaultCanvasLinePicker, _BasePicker);
    var _super = _createSuper(DefaultCanvasLinePicker);
    function DefaultCanvasLinePicker(canvasRenderer) {
      var _this;
      _classCallCheck(this, DefaultCanvasLinePicker);
      _this = _super.call(this), _this.canvasRenderer = canvasRenderer, _this.type = "line", _this.numberType = LINE_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasLinePicker, [{
      key: "contains",
      value: function contains(line, point, params) {
        if (!line.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === line.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        pickContext.highPerformanceSave();
        var lineAttribute = getTheme(line).line,
          data = this.transform(line, lineAttribute, pickContext),
          x = data.x,
          y = data.y,
          z = data.z,
          lastModelMatrix = data.lastModelMatrix;
        var pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          var globalMatrix = line.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        var picked = !1;
        return this.canvasRenderer.drawShape(line, pickContext, x, y, {}, null, function (context) {
          return !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked);
        }, function (context, lineAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = lineAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = lineAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
        }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasLinePicker;
  }(BasePicker);
  DefaultCanvasLinePicker = __decorate$l([injectable(), __param$i(0, inject(LineRender)), __metadata$i("design:paramtypes", [Object])], DefaultCanvasLinePicker);

  var loadLinePick$1 = !1;
  var lineCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadLinePick$1 || (loadLinePick$1 = !0, bind(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLinePicker));
  });

  var __decorate$k = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$h = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$h = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultMathLinePicker = /*#__PURE__*/function () {
    function DefaultMathLinePicker(canvasRenderer) {
      _classCallCheck(this, DefaultMathLinePicker);
      this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
    }
    _createClass(DefaultMathLinePicker, [{
      key: "contains",
      value: function contains(line, point, params) {
        if (!line.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === line.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var lineAttribute = getTheme(line).line;
        var _line$attribute = line.attribute,
          _line$attribute$x = _line$attribute.x,
          x = _line$attribute$x === void 0 ? lineAttribute.x : _line$attribute$x,
          _line$attribute$y = _line$attribute.y,
          y = _line$attribute$y === void 0 ? lineAttribute.y : _line$attribute$y;
        if (pickContext.highPerformanceSave(), line.transMatrix.onlyTranslate()) {
          var _point = line.getOffsetXY(lineAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(line.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(line, pickContext, x, y, {}, null, function (context) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, circleAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = circleAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultMathLinePicker;
  }();
  DefaultMathLinePicker = __decorate$k([injectable(), __param$h(0, inject(LineRender)), __metadata$h("design:paramtypes", [Object])], DefaultMathLinePicker);

  var loadLinePick = !1;
  var lineMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadLinePick || (loadLinePick = !0, bind(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathLinePicker));
  });

  var __decorate$j = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$g = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$g = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasAreaPicker = /*#__PURE__*/function () {
    function DefaultCanvasAreaPicker(canvasRenderer) {
      _classCallCheck(this, DefaultCanvasAreaPicker);
      this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasAreaPicker, [{
      key: "contains",
      value: function contains(area, point, params) {
        if (!area.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === area.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var areaAttribute = getTheme(area).area;
        var _area$attribute = area.attribute,
          _area$attribute$x = _area$attribute.x,
          x = _area$attribute$x === void 0 ? areaAttribute.x : _area$attribute$x,
          _area$attribute$y = _area$attribute.y,
          y = _area$attribute$y === void 0 ? areaAttribute.y : _area$attribute$y;
        var _area$attribute2 = area.attribute,
          _area$attribute2$fill = _area$attribute2.fillPickable,
          fillPickable = _area$attribute2$fill === void 0 ? areaAttribute.fillPickable : _area$attribute2$fill,
          _area$attribute2$stro = _area$attribute2.strokePickable,
          strokePickable = _area$attribute2$stro === void 0 ? areaAttribute.strokePickable : _area$attribute2$stro;
        if (pickContext.highPerformanceSave(), area.transMatrix.onlyTranslate()) {
          var _point = area.getOffsetXY(areaAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(area.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(area, pickContext, x, y, {}, null, function (context) {
          return !!picked || !!fillPickable && (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, areaAttribute, themeAttribute) {
          if (picked) return !0;
          if (!strokePickable) return !1;
          var lineWidth = areaAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = areaAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasAreaPicker;
  }();
  DefaultCanvasAreaPicker = __decorate$j([injectable(), __param$g(0, inject(AreaRender)), __metadata$g("design:paramtypes", [Object])], DefaultCanvasAreaPicker);

  var loadAreaPick$1 = !1;
  var areaCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadAreaPick$1 || (loadAreaPick$1 = !0, bind(CanvasAreaPicker).to(DefaultCanvasAreaPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasAreaPicker));
  });

  var __decorate$i = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$f = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$f = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultMathAreaPicker = /*#__PURE__*/function () {
    function DefaultMathAreaPicker(canvasRenderer) {
      _classCallCheck(this, DefaultMathAreaPicker);
      this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
    }
    _createClass(DefaultMathAreaPicker, [{
      key: "contains",
      value: function contains(area, point, params) {
        if (!area.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === area.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var areaAttribute = getTheme(area).area;
        var _area$attribute = area.attribute,
          _area$attribute$x = _area$attribute.x,
          x = _area$attribute$x === void 0 ? areaAttribute.x : _area$attribute$x,
          _area$attribute$y = _area$attribute.y,
          y = _area$attribute$y === void 0 ? areaAttribute.y : _area$attribute$y;
        if (pickContext.highPerformanceSave(), area.transMatrix.onlyTranslate()) {
          var _point = area.getOffsetXY(areaAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(area.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(area, pickContext, x, y, {}, null, function (context) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultMathAreaPicker;
  }();
  DefaultMathAreaPicker = __decorate$i([injectable(), __param$f(0, inject(AreaRender)), __metadata$f("design:paramtypes", [Object])], DefaultMathAreaPicker);

  var loadAreaPick = !1;
  var areaMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadAreaPick || (loadAreaPick = !0, bind(MathAreaPicker).to(DefaultMathAreaPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathAreaPicker));
  });

  var __decorate$h = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$e = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$e = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasSymbolPicker = /*#__PURE__*/function (_BasePicker) {
    _inherits(DefaultCanvasSymbolPicker, _BasePicker);
    var _super = _createSuper(DefaultCanvasSymbolPicker);
    function DefaultCanvasSymbolPicker(canvasRenderer) {
      var _this;
      _classCallCheck(this, DefaultCanvasSymbolPicker);
      _this = _super.call(this), _this.canvasRenderer = canvasRenderer, _this.type = "symbol", _this.numberType = SYMBOL_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasSymbolPicker, [{
      key: "contains",
      value: function contains(symbol, point, params) {
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var parsedPath = symbol.getParsedPath();
        if (!pickContext.camera) {
          if (!symbol.AABBBounds.containsPoint(point)) return !1;
          if (parsedPath.isSvg || "imprecise" === symbol.attribute.pickMode) return !0;
        }
        pickContext.highPerformanceSave();
        var symbolAttribute = getTheme(symbol).symbol,
          data = this.transform(symbol, symbolAttribute, pickContext),
          x = data.x,
          y = data.y,
          z = data.z,
          lastModelMatrix = data.lastModelMatrix;
        var pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          var globalMatrix = symbol.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        var picked = !1;
        return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, function (context, symbolAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked);
        }, function (context, symbolAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = symbolAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
        }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasSymbolPicker;
  }(BasePicker);
  DefaultCanvasSymbolPicker = __decorate$h([injectable(), __param$e(0, inject(SymbolRender)), __metadata$e("design:paramtypes", [Object])], DefaultCanvasSymbolPicker);

  var loadSymbolPick$1 = !1;
  var symbolCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadSymbolPick$1 || (loadSymbolPick$1 = !0, bind(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasSymbolPicker));
  });

  var __decorate$g = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$d = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$d = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultMathSymbolPicker = /*#__PURE__*/function () {
    function DefaultMathSymbolPicker(canvasRenderer) {
      _classCallCheck(this, DefaultMathSymbolPicker);
      this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
    }
    _createClass(DefaultMathSymbolPicker, [{
      key: "contains",
      value: function contains(symbol, point, params) {
        if (!symbol.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === symbol.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var symbolAttribute = getTheme(symbol).symbol;
        var _symbol$attribute = symbol.attribute,
          _symbol$attribute$x = _symbol$attribute.x,
          x = _symbol$attribute$x === void 0 ? symbolAttribute.x : _symbol$attribute$x,
          _symbol$attribute$y = _symbol$attribute.y,
          y = _symbol$attribute$y === void 0 ? symbolAttribute.y : _symbol$attribute$y;
        if (pickContext.highPerformanceSave(), symbol.transMatrix.onlyTranslate()) {
          var _point = symbol.getOffsetXY(symbolAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(symbol.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, function (context, symbolAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, symbolAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = symbolAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultMathSymbolPicker;
  }();
  DefaultMathSymbolPicker = __decorate$g([injectable(), __param$d(0, inject(SymbolRender)), __metadata$d("design:paramtypes", [Object])], DefaultMathSymbolPicker);

  var loadSymbolPick = !1;
  var symbolMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadSymbolPick || (loadSymbolPick = !0, bind(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathSymbolPicker));
  });

  var __decorate$f = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$c = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$c = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasCirclePicker = /*#__PURE__*/function () {
    function DefaultCanvasCirclePicker(canvasRenderer) {
      _classCallCheck(this, DefaultCanvasCirclePicker);
      this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasCirclePicker, [{
      key: "contains",
      value: function contains(circle, point, params) {
        if (!circle.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === circle.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var circleAttribute = getTheme(circle).circle;
        var _circle$attribute = circle.attribute,
          _circle$attribute$x = _circle$attribute.x,
          x = _circle$attribute$x === void 0 ? circleAttribute.x : _circle$attribute$x,
          _circle$attribute$y = _circle$attribute.y,
          y = _circle$attribute$y === void 0 ? circleAttribute.y : _circle$attribute$y;
        if (pickContext.highPerformanceSave(), circle.transMatrix.onlyTranslate()) {
          var _point = circle.getOffsetXY(circleAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(circle.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(circle, pickContext, x, y, {}, null, function (context, circleAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, circleAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = circleAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasCirclePicker;
  }();
  DefaultCanvasCirclePicker = __decorate$f([injectable(), __param$c(0, inject(CircleRender)), __metadata$c("design:paramtypes", [Object])], DefaultCanvasCirclePicker);

  var loadCirclePick$1 = !1;
  var circleCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadCirclePick$1 || (loadCirclePick$1 = !0, bind(CanvasCirclePicker).to(DefaultCanvasCirclePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasCirclePicker));
  });

  var __decorate$e = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$b = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$b = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultMathCirclePicker = /*#__PURE__*/function () {
    function DefaultMathCirclePicker(canvasRenderer) {
      _classCallCheck(this, DefaultMathCirclePicker);
      this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
    }
    _createClass(DefaultMathCirclePicker, [{
      key: "contains",
      value: function contains(circle, point, params) {
        if (!circle.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === circle.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var circleAttribute = getTheme(circle).circle;
        var _circle$attribute = circle.attribute,
          _circle$attribute$x = _circle$attribute.x,
          x = _circle$attribute$x === void 0 ? circleAttribute.x : _circle$attribute$x,
          _circle$attribute$y = _circle$attribute.y,
          y = _circle$attribute$y === void 0 ? circleAttribute.y : _circle$attribute$y;
        if (pickContext.highPerformanceSave(), circle.transMatrix.onlyTranslate()) {
          var _point = circle.getOffsetXY(circleAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(circle.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(circle, pickContext, x, y, {}, null, function (context, circleAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, circleAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = circleAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultMathCirclePicker;
  }();
  DefaultMathCirclePicker = __decorate$e([injectable(), __param$b(0, inject(CircleRender)), __metadata$b("design:paramtypes", [Object])], DefaultMathCirclePicker);

  var loadCirclePick = !1;
  var circleMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadCirclePick || (loadCirclePick = !0, bind(MathCirclePicker).to(DefaultMathCirclePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathCirclePicker));
  });

  var __decorate$d = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$a = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$a = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasTextPicker = /*#__PURE__*/function (_BasePicker) {
    _inherits(DefaultCanvasTextPicker, _BasePicker);
    var _super = _createSuper(DefaultCanvasTextPicker);
    function DefaultCanvasTextPicker(canvasRenderer) {
      var _this;
      _classCallCheck(this, DefaultCanvasTextPicker);
      _this = _super.call(this), _this.canvasRenderer = canvasRenderer, _this.type = "text", _this.numberType = TEXT_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasTextPicker, [{
      key: "contains",
      value: function contains(text, point, params) {
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var bounds = text.AABBBounds;
        if (!pickContext.camera) return !!bounds.containsPoint(point);
        pickContext.highPerformanceSave();
        var textAttribute = getTheme(text).text,
          _text$attribute$keepD = text.attribute.keepDirIn3d,
          keepDirIn3d = _text$attribute$keepD === void 0 ? textAttribute.keepDirIn3d : _text$attribute$keepD,
          computed3dMatrix = !keepDirIn3d,
          data = this.transform(text, textAttribute, pickContext, computed3dMatrix),
          x = data.x,
          y = data.y,
          z = data.z,
          lastModelMatrix = data.lastModelMatrix;
        this.canvasRenderer.z = z;
        var pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          var globalMatrix = text.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        var picked = !1;
        return this.canvasRenderer.drawShape(text, pickContext, x, y, {}, null, function (context, symbolAttribute, themeAttribute) {
          if (picked) return !0;
          var _text$attribute = text.attribute,
            _text$attribute$fontS = _text$attribute.fontSize,
            fontSize = _text$attribute$fontS === void 0 ? textAttribute.fontSize : _text$attribute$fontS,
            _text$attribute$textB = _text$attribute.textBaseline,
            textBaseline = _text$attribute$textB === void 0 ? textAttribute.textBaseline : _text$attribute$textB,
            _text$attribute$textA = _text$attribute.textAlign,
            textAlign = _text$attribute$textA === void 0 ? textAttribute.textAlign : _text$attribute$textA,
            bounds = text.AABBBounds,
            height = bounds.height(),
            width = bounds.width(),
            offsetY = textLayoutOffsetY(textBaseline, height, fontSize),
            offsetX = textDrawOffsetX(textAlign, width);
          return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked;
        }, function (context, symbolAttribute, themeAttribute) {
          return picked;
        }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasTextPicker;
  }(BasePicker);
  DefaultCanvasTextPicker = __decorate$d([injectable(), __param$a(0, inject(TextRender)), __metadata$a("design:paramtypes", [Object])], DefaultCanvasTextPicker);

  var loadTextPick$1 = !1;
  var textCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadTextPick$1 || (loadTextPick$1 = !0, bind(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasTextPicker));
  });

  var __decorate$c = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultMathTextPicker = /*#__PURE__*/function () {
    function DefaultMathTextPicker() {
      _classCallCheck(this, DefaultMathTextPicker);
      this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
    }
    _createClass(DefaultMathTextPicker, [{
      key: "contains",
      value: function contains(text, point, params) {
        return !!text.AABBBounds.containsPoint(point);
      }
    }]);
    return DefaultMathTextPicker;
  }();
  DefaultMathTextPicker = __decorate$c([injectable()], DefaultMathTextPicker);

  var loadTextPick = !1;
  var textMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadTextPick || (loadTextPick = !0, bind(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathTextPicker));
  });

  var __decorate$b = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$9 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$9 = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasPathPicker = /*#__PURE__*/function (_BasePicker) {
    _inherits(DefaultCanvasPathPicker, _BasePicker);
    var _super = _createSuper(DefaultCanvasPathPicker);
    function DefaultCanvasPathPicker(canvasRenderer) {
      var _this;
      _classCallCheck(this, DefaultCanvasPathPicker);
      _this = _super.call(this), _this.canvasRenderer = canvasRenderer, _this.type = "path", _this.numberType = PATH_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasPathPicker, [{
      key: "contains",
      value: function contains(path, point, params) {
        if (!path.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === path.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var pathAttribute = getTheme(path).path;
        pickContext.highPerformanceSave();
        var data = this.transform(path, pathAttribute, pickContext),
          x = data.x,
          y = data.y,
          z = data.z,
          lastModelMatrix = data.lastModelMatrix;
        var pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          var globalMatrix = path.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        var picked = !1;
        return this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, function (context, pathAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked);
        }, function (context, pathAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = pathAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
        }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasPathPicker;
  }(BasePicker);
  DefaultCanvasPathPicker = __decorate$b([injectable(), __param$9(0, inject(PathRender)), __metadata$9("design:paramtypes", [Object])], DefaultCanvasPathPicker);

  var loadPathPick$1 = !1;
  var pathCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadPathPick$1 || (loadPathPick$1 = !0, bind(CanvasPathPicker).to(DefaultCanvasPathPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPathPicker));
  });

  var __decorate$a = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$8 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$8 = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultMathPathPicker = /*#__PURE__*/function () {
    function DefaultMathPathPicker(canvasRenderer) {
      _classCallCheck(this, DefaultMathPathPicker);
      this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
    }
    _createClass(DefaultMathPathPicker, [{
      key: "contains",
      value: function contains(path, point, params) {
        if (!path.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === path.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var pathAttribute = getTheme(path).path;
        var _path$attribute = path.attribute,
          _path$attribute$x = _path$attribute.x,
          x = _path$attribute$x === void 0 ? pathAttribute.x : _path$attribute$x,
          _path$attribute$y = _path$attribute.y,
          y = _path$attribute$y === void 0 ? pathAttribute.y : _path$attribute$y;
        if (pickContext.highPerformanceSave(), path.transMatrix.onlyTranslate()) {
          var _point = path.getOffsetXY(pathAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(path.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, function (context, pathAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, pathAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = pathAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultMathPathPicker;
  }();
  DefaultMathPathPicker = __decorate$a([injectable(), __param$8(0, inject(PathRender)), __metadata$8("design:paramtypes", [Object])], DefaultMathPathPicker);

  var loadPathPick = !1;
  var pathMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadPathPick || (loadPathPick = !0, bind(MathPathPicker).to(DefaultMathPathPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPathPicker));
  });

  var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$7 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$7 = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasPolygonPicker = /*#__PURE__*/function () {
    function DefaultCanvasPolygonPicker(canvasRenderer) {
      _classCallCheck(this, DefaultCanvasPolygonPicker);
      this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasPolygonPicker, [{
      key: "contains",
      value: function contains(polygon, point, params) {
        if (!polygon.AABBBounds.contains(point.x, point.y)) return !1;
        if ("imprecise" === polygon.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var polygonAttribute = getTheme(polygon).polygon;
        var _polygon$attribute = polygon.attribute,
          _polygon$attribute$x = _polygon$attribute.x,
          x = _polygon$attribute$x === void 0 ? polygonAttribute.x : _polygon$attribute$x,
          _polygon$attribute$y = _polygon$attribute.y,
          y = _polygon$attribute$y === void 0 ? polygonAttribute.y : _polygon$attribute$y;
        if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {
          var _point = polygon.getOffsetXY(polygonAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(polygon.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, function (context, pathAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, pathAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = pathAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasPolygonPicker;
  }();
  DefaultCanvasPolygonPicker = __decorate$9([injectable(), __param$7(0, inject(PolygonRender)), __metadata$7("design:paramtypes", [Object])], DefaultCanvasPolygonPicker);

  var loadPolygonPick$1 = !1;
  var polygonCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadPolygonPick$1 || (loadPolygonPick$1 = !0, bind(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPolygonPicker));
  });

  var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$6 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$6 = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultMathPolygonPicker = /*#__PURE__*/function () {
    function DefaultMathPolygonPicker(canvasRenderer) {
      _classCallCheck(this, DefaultMathPolygonPicker);
      this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
    }
    _createClass(DefaultMathPolygonPicker, [{
      key: "contains",
      value: function contains(polygon, point, params) {
        if (!polygon.AABBBounds.contains(point.x, point.y)) return !1;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var pathAttribute = getTheme(polygon).polygon;
        var _polygon$attribute = polygon.attribute,
          _polygon$attribute$x = _polygon$attribute.x,
          x = _polygon$attribute$x === void 0 ? pathAttribute.x : _polygon$attribute$x,
          _polygon$attribute$y = _polygon$attribute.y,
          y = _polygon$attribute$y === void 0 ? pathAttribute.y : _polygon$attribute$y;
        if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {
          var _point = polygon.getOffsetXY(pathAttribute);
          x += _point.x, y += _point.y, pickContext.setTransformForCurrent();
        } else x = 0, y = 0, pickContext.transformFromMatrix(polygon.transMatrix, !0);
        var picked = !1;
        return this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, function (context, pathAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(point.x, point.y), picked);
        }, function (context, pathAttribute, themeAttribute) {
          if (picked) return !0;
          var lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth,
            pickStrokeBuffer = pathAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
          return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point.x, point.y), picked;
        }), pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultMathPolygonPicker;
  }();
  DefaultMathPolygonPicker = __decorate$8([injectable(), __param$6(0, inject(PolygonRender)), __metadata$6("design:paramtypes", [Object])], DefaultMathPolygonPicker);

  var loadPolygonPick = !1;
  var polygonMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadPolygonPick || (loadPolygonPick = !0, bind(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPolygonPicker));
  });

  var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$5 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$5 = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasGlyphPicker = /*#__PURE__*/function () {
    function DefaultCanvasGlyphPicker(canvasRenderer) {
      _classCallCheck(this, DefaultCanvasGlyphPicker);
      this.canvasRenderer = canvasRenderer, this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasGlyphPicker, [{
      key: "contains",
      value: function contains(glyph, point, params) {
        if (!glyph.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === glyph.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var pickerService = null == params ? void 0 : params.pickerService;
        if (pickerService) {
          var picked = !1;
          return glyph.getSubGraphic().forEach(function (g) {
            if (picked) return;
            var data = pickerService.pickItem(g, point, null, params);
            picked = !(!data || !data.graphic);
          }), picked;
        }
        return !1;
      }
    }]);
    return DefaultCanvasGlyphPicker;
  }();
  DefaultCanvasGlyphPicker = __decorate$7([injectable(), __param$5(0, inject(GlyphRender)), __metadata$5("design:paramtypes", [Object])], DefaultCanvasGlyphPicker);

  var loadGlyphPick$1 = !1;
  var glyphCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadGlyphPick$1 || (loadGlyphPick$1 = !0, bind(CanvasGlyphPicker).to(DefaultCanvasGlyphPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGlyphPicker));
  });

  var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$4 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$4 = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultMathGlyphPicker = /*#__PURE__*/function () {
    function DefaultMathGlyphPicker(canvasRenderer) {
      _classCallCheck(this, DefaultMathGlyphPicker);
      this.canvasRenderer = canvasRenderer, this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE;
    }
    _createClass(DefaultMathGlyphPicker, [{
      key: "contains",
      value: function contains(glyph, point, params) {
        if (!glyph.AABBBounds.containsPoint(point)) return !1;
        if ("imprecise" === glyph.attribute.pickMode) return !0;
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var pickerService = null == params ? void 0 : params.pickerService;
        if (pickerService) {
          var picked = !1;
          return glyph.getSubGraphic().forEach(function (g) {
            picked || (picked = !!pickerService.pickItem(g, point, null, params));
          }), picked;
        }
        return !1;
      }
    }]);
    return DefaultMathGlyphPicker;
  }();
  DefaultMathGlyphPicker = __decorate$6([injectable(), __param$4(0, inject(GlyphRender)), __metadata$4("design:paramtypes", [Object])], DefaultMathGlyphPicker);

  var loadGlyphPick = !1;
  var glyphMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadGlyphPick || (loadGlyphPick = !0, bind(MathGlyphPicker).to(DefaultMathGlyphPicker).inSingletonScope(), bind(DefaultMathGlyphPicker).toService(MathGlyphPicker));
  });

  var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$3 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$3 = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasRichTextPicker = /*#__PURE__*/function () {
    function DefaultCanvasRichTextPicker(canvasRenderer) {
      _classCallCheck(this, DefaultCanvasRichTextPicker);
      this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = RICHTEXT_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasRichTextPicker, [{
      key: "contains",
      value: function contains(richtext, point, params) {
        return !!richtext.AABBBounds.containsPoint(point);
      }
    }]);
    return DefaultCanvasRichTextPicker;
  }();
  DefaultCanvasRichTextPicker = __decorate$5([injectable(), __param$3(0, inject(RichTextRender)), __metadata$3("design:paramtypes", [Object])], DefaultCanvasRichTextPicker);

  var loadRichtextPick = !1;
  var richtextCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadRichtextPick || (loadRichtextPick = !0, bind(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRichTextPicker));
  });

  var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultMathImagePicker = /*#__PURE__*/function () {
    function DefaultMathImagePicker() {
      _classCallCheck(this, DefaultMathImagePicker);
      this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
    }
    _createClass(DefaultMathImagePicker, [{
      key: "contains",
      value: function contains(image, point, params) {
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        return !!pickContext && !!image.AABBBounds.containsPoint(point);
      }
    }]);
    return DefaultMathImagePicker;
  }();
  DefaultMathImagePicker = __decorate$4([injectable()], DefaultMathImagePicker);

  var loadRichTextPick = !1;
  var richTextMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadRichTextPick || (loadRichTextPick = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
  });

  var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var DefaultCanvasImagePicker = /*#__PURE__*/function () {
    function DefaultCanvasImagePicker() {
      _classCallCheck(this, DefaultCanvasImagePicker);
      this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
    }
    _createClass(DefaultCanvasImagePicker, [{
      key: "contains",
      value: function contains(image, point, params) {
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        return !!pickContext && !!image.AABBBounds.containsPoint(point);
      }
    }]);
    return DefaultCanvasImagePicker;
  }();
  DefaultCanvasImagePicker = __decorate$3([injectable()], DefaultCanvasImagePicker);

  var loadImagePick$1 = !1;
  var imageCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadImagePick$1 || (loadImagePick$1 = !0, bind(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasImagePicker));
  });

  var loadImagePick = !1;
  var imageMathPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadImagePick || (loadImagePick = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
  });

  var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$2 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$2 = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  new AABBBounds();
  var DefaultCanvasRect3dPicker = /*#__PURE__*/function (_BasePicker) {
    _inherits(DefaultCanvasRect3dPicker, _BasePicker);
    var _super = _createSuper(DefaultCanvasRect3dPicker);
    function DefaultCanvasRect3dPicker(canvasRenderer) {
      var _this;
      _classCallCheck(this, DefaultCanvasRect3dPicker);
      _this = _super.call(this), _this.canvasRenderer = canvasRenderer, _this.type = "rect3d", _this.numberType = RECT3D_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasRect3dPicker, [{
      key: "contains",
      value: function contains(rect, point, params) {
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var rectAttribute = getTheme(rect).rect;
        pickContext.highPerformanceSave();
        var data = this.transform(rect, rectAttribute, pickContext),
          x = data.x,
          y = data.y,
          z = data.z,
          lastModelMatrix = data.lastModelMatrix;
        var pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          var globalMatrix = rect.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        var picked = !1;
        return this.canvasRenderer.drawShape(rect, pickContext, x, y, params, null, function (context, arc3dAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked);
        }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasRect3dPicker;
  }(BasePicker);
  DefaultCanvasRect3dPicker = __decorate$2([injectable(), __param$2(0, inject(Rect3DRender)), __metadata$2("design:paramtypes", [Object])], DefaultCanvasRect3dPicker);

  var loadRect3dPick = !1;
  var rect3dCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadRect3dPick || (loadRect3dPick = !0, bind(CanvasRect3dPicker).to(DefaultCanvasRect3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRect3dPicker));
  });

  var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata$1 = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param$1 = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasArc3dPicker = /*#__PURE__*/function (_BasePicker) {
    _inherits(DefaultCanvasArc3dPicker, _BasePicker);
    var _super = _createSuper(DefaultCanvasArc3dPicker);
    function DefaultCanvasArc3dPicker(canvasRenderer) {
      var _this;
      _classCallCheck(this, DefaultCanvasArc3dPicker);
      _this = _super.call(this), _this.canvasRenderer = canvasRenderer, _this.type = "arc3d", _this.numberType = ARC3D_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasArc3dPicker, [{
      key: "contains",
      value: function contains(arc3d, point, params) {
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var arc3dAttribute = getTheme(arc3d).arc;
        pickContext.highPerformanceSave();
        var data = this.transform(arc3d, arc3dAttribute, pickContext),
          x = data.x,
          y = data.y,
          z = data.z,
          lastModelMatrix = data.lastModelMatrix;
        var pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          var globalMatrix = arc3d.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        var picked = !1;
        return this.canvasRenderer.drawShape(arc3d, pickContext, x, y, params, null, function (context, arc3dAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked);
        }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasArc3dPicker;
  }(BasePicker);
  DefaultCanvasArc3dPicker = __decorate$1([injectable(), __param$1(0, inject(Arc3dRender)), __metadata$1("design:paramtypes", [Object])], DefaultCanvasArc3dPicker);

  var loadArc3dPick = !1;
  var arc3dCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadArc3dPick || (loadArc3dPick = !0, bind(CanvasArc3dPicker).to(DefaultCanvasArc3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArc3dPicker));
  });

  var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
      var d,
        c = arguments.length,
        r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    },
    __metadata = undefined && undefined.__metadata || function (k, v) {
      if ("object" == (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
    },
    __param = undefined && undefined.__param || function (paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    };
  var DefaultCanvasPyramid3dPicker = /*#__PURE__*/function (_BasePicker) {
    _inherits(DefaultCanvasPyramid3dPicker, _BasePicker);
    var _super = _createSuper(DefaultCanvasPyramid3dPicker);
    function DefaultCanvasPyramid3dPicker(canvasRenderer) {
      var _this;
      _classCallCheck(this, DefaultCanvasPyramid3dPicker);
      _this = _super.call(this), _this.canvasRenderer = canvasRenderer, _this.type = "pyramid3d", _this.numberType = PYRAMID3D_NUMBER_TYPE;
      return _this;
    }
    _createClass(DefaultCanvasPyramid3dPicker, [{
      key: "contains",
      value: function contains(pyramid3d, point, params) {
        var _ref = null != params ? params : {},
          pickContext = _ref.pickContext;
        if (!pickContext) return !1;
        var pyramid3dAttribute = getTheme(pyramid3d).polygon;
        pickContext.highPerformanceSave();
        var data = this.transform(pyramid3d, pyramid3dAttribute, pickContext),
          x = data.x,
          y = data.y,
          z = data.z,
          lastModelMatrix = data.lastModelMatrix;
        var pickPoint = point;
        if (pickContext.camera) {
          pickPoint = point.clone();
          var globalMatrix = pyramid3d.parent.globalTransMatrix;
          pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
        }
        this.canvasRenderer.z = z;
        var picked = !1;
        return this.canvasRenderer.drawShape(pyramid3d, pickContext, x, y, {}, null, function (context, pyramid3dAttribute, themeAttribute) {
          return !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked);
        }, function (context, pyramid3dAttribute, themeAttribute) {
          return !1;
        }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
      }
    }]);
    return DefaultCanvasPyramid3dPicker;
  }(BasePicker);
  DefaultCanvasPyramid3dPicker = __decorate([injectable(), __param(0, inject(Pyramid3dRender)), __metadata("design:paramtypes", [Object])], DefaultCanvasPyramid3dPicker);

  var loadPyramid3dPick = !1;
  var pyramid3dCanvasPickModule = new ContainerModule(function (bind, unbind, isBound, rebind) {
    loadPyramid3dPick || (loadPyramid3dPick = !0, bind(CanvasPyramid3dPicker).to(DefaultCanvasPyramid3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPyramid3dPicker));
  });

  var browser = isBrowserEnv();

  function _registerArc() {
    _registerArc.__loaded || (_registerArc.__loaded = !0, registerArcGraphic(), container.load(arcModule), container.load(browser ? arcCanvasPickModule : arcMathPickModule));
  }
  _registerArc.__loaded = !1;
  var registerArc = _registerArc;

  function _registerArc3d() {
    _registerArc3d.__loaded || (_registerArc3d.__loaded = !0, registerArc3dGraphic(), container.load(arc3dModule), container.load(arc3dCanvasPickModule));
  }
  _registerArc3d.__loaded = !1;
  var registerArc3d = _registerArc3d;

  function _registerArea() {
    _registerArea.__loaded || (_registerArea.__loaded = !0, registerAreaGraphic(), container.load(areaModule), container.load(browser ? areaCanvasPickModule : areaMathPickModule));
  }
  _registerArea.__loaded = !1;
  var registerArea = _registerArea;

  function _registerCircle() {
    _registerCircle.__loaded || (_registerCircle.__loaded = !0, registerCircleGraphic(), container.load(circleModule), container.load(browser ? circleCanvasPickModule : circleMathPickModule));
  }
  _registerCircle.__loaded = !1;
  var registerCircle = _registerCircle;

  function _registerGlyph() {
    _registerGlyph.__loaded || (_registerGlyph.__loaded = !0, registerGlyphGraphic(), container.load(glyphModule), container.load(browser ? glyphCanvasPickModule : glyphMathPickModule));
  }
  _registerGlyph.__loaded = !1;
  var registerGlyph = _registerGlyph;

  function _registerGroup() {
    _registerGroup.__loaded || (_registerGroup.__loaded = !0, registerGroupGraphic());
  }
  _registerGroup.__loaded = !1;
  var registerGroup = _registerGroup;

  function _registerImage() {
    _registerImage.__loaded || (_registerImage.__loaded = !0, registerImageGraphic(), container.load(imageModule), container.load(browser ? imageCanvasPickModule : imageMathPickModule));
  }
  _registerImage.__loaded = !1;
  var registerImage = _registerImage;

  function _registerLine() {
    _registerLine.__loaded || (_registerLine.__loaded = !0, registerLineGraphic(), container.load(lineModule), container.load(browser ? lineCanvasPickModule : lineMathPickModule));
  }
  _registerLine.__loaded = !1;
  var registerLine = _registerLine;

  function _registerPath() {
    _registerPath.__loaded || (_registerPath.__loaded = !0, registerPathGraphic(), container.load(pathModule), container.load(browser ? pathCanvasPickModule : pathMathPickModule));
  }
  _registerPath.__loaded = !1;
  var registerPath = _registerPath;

  function _registerPolygon() {
    _registerPolygon.__loaded || (_registerPolygon.__loaded = !0, registerPolygonGraphic(), container.load(polygonModule), container.load(browser ? polygonCanvasPickModule : polygonMathPickModule));
  }
  _registerPolygon.__loaded = !1;
  var registerPolygon = _registerPolygon;

  function _registerPyramid3d() {
    _registerPyramid3d.__loaded || (_registerPyramid3d.__loaded = !0, registerPyramid3dGraphic(), container.load(pyramid3dModule), container.load(pyramid3dCanvasPickModule));
  }
  _registerPyramid3d.__loaded = !1;
  var registerPyramid3d = _registerPyramid3d;

  function _registerRect() {
    _registerRect.__loaded || (_registerRect.__loaded = !0, registerRectGraphic(), container.load(rectModule), container.load(browser ? rectCanvasPickModule : rectMathPickModule));
  }
  _registerRect.__loaded = !1;
  var registerRect = _registerRect;

  function _registerRect3d() {
    _registerRect3d.__loaded || (_registerRect3d.__loaded = !0, registerRect3dGraphic(), container.load(rect3dModule), container.load(rect3dCanvasPickModule));
  }
  _registerRect3d.__loaded = !1;
  var registerRect3d = _registerRect3d;

  function _registerRichtext() {
    _registerRichtext.__loaded || (_registerRichtext.__loaded = !0, registerRichtextGraphic(), container.load(richtextModule), container.load(browser ? richtextCanvasPickModule : richTextMathPickModule));
  }
  _registerRichtext.__loaded = !1;
  var registerRichtext = _registerRichtext;

  function _registerShadowRoot() {
    _registerShadowRoot.__loaded || (_registerShadowRoot.__loaded = !0, registerShadowRootGraphic());
  }
  _registerShadowRoot.__loaded = !1;
  var registerShadowRoot = _registerShadowRoot;

  function _registerSymbol() {
    _registerSymbol.__loaded || (_registerSymbol.__loaded = !0, registerSymbolGraphic(), container.load(symbolModule), container.load(browser ? symbolCanvasPickModule : symbolMathPickModule));
  }
  _registerSymbol.__loaded = !1;
  var registerSymbol = _registerSymbol;

  function _registerText() {
    _registerText.__loaded || (_registerText.__loaded = !0, registerTextGraphic(), container.load(textModule), container.load(browser ? textCanvasPickModule : textMathPickModule));
  }
  _registerText.__loaded = !1;
  var registerText = _registerText;

  function _registerWrapText() {
    _registerWrapText.__loaded || (_registerWrapText.__loaded = !0, registerWrapTextGraphic());
  }
  _registerWrapText.__loaded = !1;
  var registerWrapText = _registerWrapText;

  var roughModule = _roughModule;

  const version = "0.18.10";
  preLoadAllModule();
  if (isBrowserEnv()) {
      loadBrowserEnv(container);
  }
  else if (isNodeEnv()) {
      loadNodeEnv(container);
  }
  registerArc();
  registerArc3d();
  registerArea();
  registerCircle();
  registerGlyph();
  registerGroup();
  registerImage();
  registerLine();
  registerPath();
  registerPolygon();
  registerPyramid3d();
  registerRect();
  registerRect3d();
  registerRichtext();
  registerShadowRoot();
  registerSymbol();
  registerText();
  registerWrapText();

  exports.ACustomAnimate = ACustomAnimate;
  exports.ARC3D_NUMBER_TYPE = ARC3D_NUMBER_TYPE;
  exports.ARC_NUMBER_TYPE = ARC_NUMBER_TYPE;
  exports.AREA_NUMBER_TYPE = AREA_NUMBER_TYPE;
  exports.Animate = Animate;
  exports.AnimateGroup = AnimateGroup;
  exports.AnimateGroup1 = AnimateGroup1;
  exports.Application = Application;
  exports.Arc = Arc;
  exports.Arc3d = Arc3d;
  exports.Arc3dRender = Arc3dRender;
  exports.ArcRender = ArcRender;
  exports.ArcRenderContribution = ArcRenderContribution;
  exports.Area = Area;
  exports.AreaRender = AreaRender;
  exports.AreaRenderContribution = AreaRenderContribution;
  exports.AttributeAnimate = AttributeAnimate;
  exports.AutoEnablePlugins = AutoEnablePlugins;
  exports.BaseRender = BaseRender;
  exports.Basis = Basis;
  exports.BeforeRenderConstribution = BeforeRenderConstribution;
  exports.BoundsContext = BoundsContext;
  exports.BoundsPicker = BoundsPicker;
  exports.CIRCLE_NUMBER_TYPE = CIRCLE_NUMBER_TYPE;
  exports.Canvas3DDrawItemInterceptor = Canvas3DDrawItemInterceptor;
  exports.CanvasFactory = CanvasFactory;
  exports.CanvasTextLayout = CanvasTextLayout;
  exports.CbAnimate = CbAnimate;
  exports.Circle = Circle;
  exports.CircleRender = CircleRender;
  exports.CircleRenderContribution = CircleRenderContribution;
  exports.ClipAngleAnimate = ClipAngleAnimate;
  exports.ClipDirectionAnimate = ClipDirectionAnimate;
  exports.ClipGraphicAnimate = ClipGraphicAnimate;
  exports.ClipRadiusAnimate = ClipRadiusAnimate;
  exports.ColorInterpolate = ColorInterpolate;
  exports.ColorStore = ColorStore;
  exports.CommonRenderContribution = CommonRenderContribution;
  exports.Container = Container;
  exports.ContainerModule = ContainerModule;
  exports.Context2dFactory = Context2dFactory;
  exports.ContributionProvider = ContributionProvider;
  exports.CurveContext = CurveContext;
  exports.CustomEvent = CustomEvent;
  exports.CustomPath2D = CustomPath2D;
  exports.CustomSymbolClass = CustomSymbolClass;
  exports.DebugDrawItemInterceptorContribution = DebugDrawItemInterceptorContribution;
  exports.DefaultArcAllocate = DefaultArcAllocate;
  exports.DefaultArcAttribute = DefaultArcAttribute;
  exports.DefaultArcRenderContribution = DefaultArcRenderContribution;
  exports.DefaultAreaAllocate = DefaultAreaAllocate;
  exports.DefaultAreaAttribute = DefaultAreaAttribute;
  exports.DefaultAreaTextureRenderContribution = DefaultAreaTextureRenderContribution;
  exports.DefaultAttribute = DefaultAttribute;
  exports.DefaultBaseBackgroundRenderContribution = DefaultBaseBackgroundRenderContribution;
  exports.DefaultBaseTextureRenderContribution = DefaultBaseTextureRenderContribution;
  exports.DefaultCanvasAllocate = DefaultCanvasAllocate;
  exports.DefaultCircleAllocate = DefaultCircleAllocate;
  exports.DefaultCircleAttribute = DefaultCircleAttribute;
  exports.DefaultCircleRenderContribution = DefaultCircleRenderContribution;
  exports.DefaultConnectAttribute = DefaultConnectAttribute;
  exports.DefaultDebugAttribute = DefaultDebugAttribute;
  exports.DefaultFillStyle = DefaultFillStyle;
  exports.DefaultGlyphAttribute = DefaultGlyphAttribute;
  exports.DefaultGraphicAllocate = DefaultGraphicAllocate;
  exports.DefaultGraphicMemoryManager = DefaultGraphicMemoryManager;
  exports.DefaultGroupAttribute = DefaultGroupAttribute;
  exports.DefaultGroupBackgroundRenderContribution = DefaultGroupBackgroundRenderContribution;
  exports.DefaultImageAttribute = DefaultImageAttribute;
  exports.DefaultImageBackgroundRenderContribution = DefaultImageBackgroundRenderContribution;
  exports.DefaultLayout = DefaultLayout;
  exports.DefaultLineAllocate = DefaultLineAllocate;
  exports.DefaultLineAttribute = DefaultLineAttribute;
  exports.DefaultMat4Allocate = DefaultMat4Allocate;
  exports.DefaultMatrixAllocate = DefaultMatrixAllocate;
  exports.DefaultMorphingAnimateConfig = DefaultMorphingAnimateConfig;
  exports.DefaultPathAllocate = DefaultPathAllocate;
  exports.DefaultPathAttribute = DefaultPathAttribute;
  exports.DefaultPickStyle = DefaultPickStyle;
  exports.DefaultPolygonAttribute = DefaultPolygonAttribute;
  exports.DefaultRect3dAttribute = DefaultRect3dAttribute;
  exports.DefaultRectAllocate = DefaultRectAllocate;
  exports.DefaultRectAttribute = DefaultRectAttribute;
  exports.DefaultRectRenderContribution = DefaultRectRenderContribution;
  exports.DefaultRichTextAttribute = DefaultRichTextAttribute;
  exports.DefaultRichTextIconAttribute = DefaultRichTextIconAttribute;
  exports.DefaultStateAnimateConfig = DefaultStateAnimateConfig;
  exports.DefaultStrokeStyle = DefaultStrokeStyle;
  exports.DefaultStyle = DefaultStyle;
  exports.DefaultSymbolAllocate = DefaultSymbolAllocate;
  exports.DefaultSymbolAttribute = DefaultSymbolAttribute;
  exports.DefaultSymbolRenderContribution = DefaultSymbolRenderContribution;
  exports.DefaultTextAllocate = DefaultTextAllocate;
  exports.DefaultTextAttribute = DefaultTextAttribute;
  exports.DefaultTextStyle = DefaultTextStyle;
  exports.DefaultTicker = DefaultTicker;
  exports.DefaultTimeline = DefaultTimeline;
  exports.DefaultTransform = DefaultTransform;
  exports.DragNDrop = DragNDrop;
  exports.DrawContribution = DrawContribution;
  exports.DrawItemInterceptor = DrawItemInterceptor;
  exports.DynamicLayerHandlerContribution = DynamicLayerHandlerContribution;
  exports.EnvContribution = EnvContribution;
  exports.EventManager = EventManager;
  exports.EventSystem = EventSystem;
  exports.EventTarget = EventTarget;
  exports.FadeInPlus = FadeInPlus;
  exports.FederatedEvent = FederatedEvent;
  exports.FederatedMouseEvent = FederatedMouseEvent;
  exports.FederatedPointerEvent = FederatedPointerEvent;
  exports.FederatedWheelEvent = FederatedWheelEvent;
  exports.Fragment = Fragment;
  exports.GLYPH_NUMBER_TYPE = GLYPH_NUMBER_TYPE;
  exports.GRAPHIC_UPDATE_TAG_KEY = GRAPHIC_UPDATE_TAG_KEY;
  exports.GROUP_NUMBER_TYPE = GROUP_NUMBER_TYPE;
  exports.Generator = Generator;
  exports.Gesture = Gesture;
  exports.GlobalPickerService = GlobalPickerService;
  exports.Glyph = Glyph;
  exports.GlyphRender = GlyphRender;
  exports.Graphic = Graphic;
  exports.GraphicAnimate = GraphicAnimate;
  exports.GraphicCreator = GraphicCreator$1;
  exports.GraphicPicker = GraphicPicker;
  exports.GraphicRender = GraphicRender;
  exports.GraphicService = GraphicService;
  exports.GraphicUtil = GraphicUtil;
  exports.Group = Group;
  exports.GroupFadeIn = GroupFadeIn;
  exports.GroupFadeOut = GroupFadeOut;
  exports.GroupRender = GroupRender;
  exports.GroupRenderContribution = GroupRenderContribution;
  exports.IMAGE_NUMBER_TYPE = IMAGE_NUMBER_TYPE;
  exports.Image = Image;
  exports.ImageRender = ImageRender;
  exports.ImageRenderContribution = ImageRenderContribution;
  exports.IncreaseCount = IncreaseCount;
  exports.IncrementalDrawContribution = IncrementalDrawContribution;
  exports.InputText = InputText;
  exports.InteractiveDrawItemInterceptorContribution = InteractiveDrawItemInterceptorContribution;
  exports.InteractiveSubRenderContribution = InteractiveSubRenderContribution;
  exports.LINE_NUMBER_TYPE = LINE_NUMBER_TYPE;
  exports.Layer = Layer;
  exports.LayerService = LayerService;
  exports.Line = Line$1;
  exports.LineRender = LineRender;
  exports.Linear = Linear;
  exports.LinearClosed = LinearClosed;
  exports.ManualTickHandler = ManualTickHandler;
  exports.ManualTicker = ManualTicker;
  exports.Mat4Allocate = Mat4Allocate;
  exports.MatrixAllocate = MatrixAllocate;
  exports.Meteor = Meteor;
  exports.MonotoneX = MonotoneX;
  exports.MonotoneY = MonotoneY;
  exports.MorphingPath = MorphingPath;
  exports.MotionPath = MotionPath;
  exports.MultiToOneMorphingPath = MultiToOneMorphingPath;
  exports.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
  exports.Node = Node;
  exports.PATH_NUMBER_TYPE = PATH_NUMBER_TYPE;
  exports.POLYGON_NUMBER_TYPE = POLYGON_NUMBER_TYPE;
  exports.PURE_STYLE_KEY = PURE_STYLE_KEY;
  exports.PYRAMID3D_NUMBER_TYPE = PYRAMID3D_NUMBER_TYPE;
  exports.Path = Path;
  exports.PathRender = PathRender;
  exports.PathRenderContribution = PathRenderContribution;
  exports.PickItemInterceptor = PickItemInterceptor;
  exports.PickerService = PickerService;
  exports.PluginService = PluginService;
  exports.Polygon = Polygon;
  exports.PolygonRender = PolygonRender;
  exports.PolygonRenderContribution = PolygonRenderContribution;
  exports.Pyramid3d = Pyramid3d;
  exports.Pyramid3dRender = Pyramid3dRender;
  exports.RAFTickHandler = RAFTickHandler;
  exports.REACT_TO_CANOPUS_EVENTS = REACT_TO_CANOPUS_EVENTS;
  exports.REACT_TO_CANOPUS_EVENTS_LIST = REACT_TO_CANOPUS_EVENTS_LIST;
  exports.RECT3D_NUMBER_TYPE = RECT3D_NUMBER_TYPE;
  exports.RECT_NUMBER_TYPE = RECT_NUMBER_TYPE;
  exports.RICHTEXT_NUMBER_TYPE = RICHTEXT_NUMBER_TYPE;
  exports.RafBasedSTO = RafBasedSTO;
  exports.Rect = Rect;
  exports.Rect3DRender = Rect3DRender;
  exports.Rect3d = Rect3d;
  exports.RectRender = RectRender;
  exports.RectRenderContribution = RectRenderContribution;
  exports.ReflectSegContext = ReflectSegContext;
  exports.RenderSelector = RenderSelector;
  exports.RenderService = RenderService;
  exports.ResourceLoader = ResourceLoader;
  exports.RichText = RichText;
  exports.RichTextRender = RichTextRender;
  exports.RotateBySphereAnimate = RotateBySphereAnimate;
  exports.SVG_ATTRIBUTE_MAP = SVG_ATTRIBUTE_MAP;
  exports.SVG_ATTRIBUTE_MAP_KEYS = SVG_ATTRIBUTE_MAP_KEYS;
  exports.SVG_PARSE_ATTRIBUTE_MAP = SVG_PARSE_ATTRIBUTE_MAP;
  exports.SVG_PARSE_ATTRIBUTE_MAP_KEYS = SVG_PARSE_ATTRIBUTE_MAP_KEYS;
  exports.SYMBOL_NUMBER_TYPE = SYMBOL_NUMBER_TYPE;
  exports.SegContext = SegContext;
  exports.ShadowRoot = ShadowRoot;
  exports.ShadowRootDrawItemInterceptorContribution = ShadowRootDrawItemInterceptorContribution;
  exports.Stage = Stage;
  exports.StaticLayerHandlerContribution = StaticLayerHandlerContribution;
  exports.Step = Step$1;
  exports.StreamLight = StreamLight;
  exports.SubAnimate = SubAnimate;
  exports.Symbol = _Symbol;
  exports.SymbolRender = SymbolRender;
  exports.SymbolRenderContribution = SymbolRenderContribution;
  exports.TEXT_NUMBER_TYPE = TEXT_NUMBER_TYPE;
  exports.TagPointsUpdate = TagPointsUpdate;
  exports.Text = Text;
  exports.TextMeasureContribution = TextMeasureContribution;
  exports.TextRender = TextRender;
  exports.TextRenderContribution = TextRenderContribution;
  exports.Theme = Theme;
  exports.TimeOutTickHandler = TimeOutTickHandler;
  exports.TransformUtil = TransformUtil;
  exports.VArc = VArc;
  exports.VArc3d = VArc3d;
  exports.VArea = VArea;
  exports.VCircle = VCircle;
  exports.VGlobal = VGlobal;
  exports.VGlyph = VGlyph;
  exports.VGroup = VGroup;
  exports.VImage = VImage;
  exports.VLine = VLine;
  exports.VPath = VPath;
  exports.VPolygon = VPolygon;
  exports.VPyramid3d = VPyramid3d;
  exports.VRect = VRect;
  exports.VRect3d = VRect3d;
  exports.VRichText = VRichText;
  exports.VSymbol = VSymbol;
  exports.VText = VText;
  exports.VWindow = VWindow;
  exports.VirtualLayerHandlerContribution = VirtualLayerHandlerContribution;
  exports.WILDCARD = WILDCARD;
  exports.WindowHandlerContribution = WindowHandlerContribution;
  exports.WrapText = WrapText;
  exports.XMLParser = XMLParser;
  exports._registerArc = _registerArc;
  exports.addArcToBezierPath = addArcToBezierPath$1;
  exports.addAttributeToPrototype = addAttributeToPrototype;
  exports.alignBezierCurves = alignBezierCurves;
  exports.alignSubpath = alignSubpath;
  exports.application = application;
  exports.applyTransformOnBezierCurves = applyTransformOnBezierCurves;
  exports.arc3dCanvasPickModule = arc3dCanvasPickModule;
  exports.arc3dModule = arc3dModule;
  exports.arcCanvasPickModule = arcCanvasPickModule;
  exports.arcMathPickModule = arcMathPickModule;
  exports.arcModule = arcModule;
  exports.areaCanvasPickModule = areaCanvasPickModule;
  exports.areaMathPickModule = areaMathPickModule;
  exports.areaModule = areaModule;
  exports.bezier = bezier;
  exports.bezierCurversToPath = bezierCurversToPath;
  exports.binarySplitPolygon = binarySplitPolygon;
  exports.bindContributionProvider = bindContributionProvider;
  exports.bindContributionProviderNoSingletonScope = bindContributionProviderNoSingletonScope;
  exports.boundStroke = boundStroke;
  exports.browserEnvModule = browserEnvModule;
  exports.builtInSymbolStrMap = builtInSymbolStrMap;
  exports.builtinSymbols = builtinSymbols;
  exports.builtinSymbolsMap = builtinSymbolsMap;
  exports.calcLineCache = calcLineCache$1;
  exports.calculateLineHeight = calculateLineHeight;
  exports.canvasAllocate = canvasAllocate;
  exports.centroidOfSubpath = centroidOfSubpath;
  exports.circleBounds = circleBounds;
  exports.circleCanvasPickModule = circleCanvasPickModule;
  exports.circleMathPickModule = circleMathPickModule;
  exports.circleModule = circleModule;
  exports.clock = clock;
  exports.cloneGraphic = cloneGraphic;
  exports.colorEqual = colorEqual;
  exports.colorStringInterpolationToStr = colorStringInterpolationToStr;
  exports.container = container;
  exports.cornerTangents = cornerTangents;
  exports.createArc = createArc;
  exports.createArc3d = createArc3d;
  exports.createArea = createArea;
  exports.createCircle = createCircle;
  exports.createColor = createColor;
  exports.createConicalGradient = createConicalGradient;
  exports.createGlyph = createGlyph;
  exports.createGroup = createGroup;
  exports.createImage = createImage;
  exports.createLine = createLine;
  exports.createMat4 = createMat4;
  exports.createPath = createPath;
  exports.createPolygon = createPolygon;
  exports.createPyramid3d = createPyramid3d;
  exports.createRect = createRect;
  exports.createRect3d = createRect3d;
  exports.createRectPath = createRectPath;
  exports.createRichText = createRichText;
  exports.createShadowRoot = createShadowRoot;
  exports.createStage = createStage;
  exports.createSymbol = createSymbol;
  exports.createText = createText;
  exports.createWrapText = createWrapText;
  exports.cubicCalc = cubicCalc;
  exports.cubicLength = cubicLength;
  exports.cubicPointAt = cubicPointAt;
  exports.cubicSubdivide = cubicSubdivide;
  exports.decodeReactDom = decodeReactDom;
  exports.defaultArcAllocate = defaultArcAllocate;
  exports.defaultArcBackgroundRenderContribution = defaultArcBackgroundRenderContribution;
  exports.defaultArcRenderContribution = defaultArcRenderContribution;
  exports.defaultArcTextureRenderContribution = defaultArcTextureRenderContribution;
  exports.defaultAreaAllocate = defaultAreaAllocate;
  exports.defaultBaseBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;
  exports.defaultBaseTextureRenderContribution = defaultBaseTextureRenderContribution;
  exports.defaultCircleAllocate = defaultCircleAllocate;
  exports.defaultCircleBackgroundRenderContribution = defaultCircleBackgroundRenderContribution;
  exports.defaultCircleRenderContribution = defaultCircleRenderContribution;
  exports.defaultCircleTextureRenderContribution = defaultCircleTextureRenderContribution;
  exports.defaultGraphicMemoryManager = defaultGraphicMemoryManager;
  exports.defaultGroupBackgroundRenderContribution = defaultGroupBackgroundRenderContribution;
  exports.defaultImageBackgroundRenderContribution = defaultImageBackgroundRenderContribution;
  exports.defaultLineAllocate = defaultLineAllocate;
  exports.defaultPathAllocate = defaultPathAllocate;
  exports.defaultRectAllocate = defaultRectAllocate;
  exports.defaultRectBackgroundRenderContribution = defaultRectBackgroundRenderContribution;
  exports.defaultRectRenderContribution = defaultRectRenderContribution;
  exports.defaultRectTextureRenderContribution = defaultRectTextureRenderContribution;
  exports.defaultSymbolAllocate = defaultSymbolAllocate;
  exports.defaultSymbolBackgroundRenderContribution = defaultSymbolBackgroundRenderContribution;
  exports.defaultSymbolRenderContribution = defaultSymbolRenderContribution;
  exports.defaultSymbolTextureRenderContribution = defaultSymbolTextureRenderContribution;
  exports.defaultTextAllocate = defaultTextAllocate;
  exports.defaultTicker = defaultTicker;
  exports.defaultTimeline = defaultTimeline;
  exports.drawArc = drawArc;
  exports.drawArcPath = drawArcPath$1;
  exports.drawAreaSegments = drawAreaSegments;
  exports.drawIncrementalAreaSegments = drawIncrementalAreaSegments;
  exports.drawIncrementalSegments = drawIncrementalSegments;
  exports.drawPathProxy = drawPathProxy;
  exports.drawSegments = drawSegments;
  exports.enumCommandMap = enumCommandMap;
  exports.feishuEnvModule = feishuEnvModule;
  exports.fillVisible = fillVisible;
  exports.findBestMorphingRotation = findBestMorphingRotation;
  exports.findNextGraphic = findNextGraphic;
  exports.flatten_simplify = flatten_simplify;
  exports.foreach = foreach;
  exports.foreachAsync = foreachAsync;
  exports.genBasisSegments = genBasisSegments;
  exports.genBasisTypeSegments = genBasisTypeSegments;
  exports.genLinearClosedSegments = genLinearClosedSegments;
  exports.genLinearClosedTypeSegments = genLinearClosedTypeSegments;
  exports.genLinearSegments = genLinearSegments;
  exports.genLinearTypeSegments = genLinearTypeSegments;
  exports.genMonotoneXSegments = genMonotoneXSegments;
  exports.genMonotoneXTypeSegments = genMonotoneXTypeSegments;
  exports.genMonotoneYSegments = genMonotoneYSegments;
  exports.genMonotoneYTypeSegments = genMonotoneYTypeSegments;
  exports.genNumberType = genNumberType;
  exports.genStepSegments = genStepSegments;
  exports.genStepTypeSegments = genStepTypeSegments;
  exports.getAttributeFromDefaultAttrList = getAttributeFromDefaultAttrList;
  exports.getConicGradientAt = getConicGradientAt;
  exports.getContextFont = getContextFont;
  exports.getCurrentEnv = getCurrentEnv;
  exports.getExtraModelMatrix = getExtraModelMatrix;
  exports.getModelMatrix = getModelMatrix;
  exports.getRichTextBounds = getRichTextBounds;
  exports.getScaledStroke = getScaledStroke;
  exports.getTextBounds = getTextBounds;
  exports.getTheme = getTheme;
  exports.getThemeFromGroup = getThemeFromGroup;
  exports.globalTheme = globalTheme;
  exports.glyphCanvasPickModule = glyphCanvasPickModule;
  exports.glyphMathPickModule = glyphMathPickModule;
  exports.glyphModule = glyphModule;
  exports.graphicCreator = graphicCreator;
  exports.graphicService = graphicService;
  exports.graphicUtil = graphicUtil;
  exports.imageCanvasPickModule = imageCanvasPickModule;
  exports.imageMathPickModule = imageMathPickModule;
  exports.imageModule = imageModule;
  exports.incrementalAddTo = incrementalAddTo;
  exports.initAllEnv = initAllEnv;
  exports.initBrowserEnv = initBrowserEnv;
  exports.initFeishuEnv = initFeishuEnv;
  exports.initLynxEnv = initLynxEnv;
  exports.initNodeEnv = initNodeEnv;
  exports.initTTEnv = initTTEnv;
  exports.initTaroEnv = initTaroEnv;
  exports.initWxEnv = initWxEnv;
  exports.inject = inject;
  exports.injectable = injectable;
  exports.interpolateColor = interpolateColor;
  exports.interpolateGradientConicalColor = interpolateGradientConicalColor;
  exports.interpolateGradientLinearColor = interpolateGradientLinearColor;
  exports.interpolateGradientRadialColor = interpolateGradientRadialColor;
  exports.interpolatePureColorArray = interpolatePureColorArray;
  exports.intersect = intersect;
  exports.isBrowserEnv = isBrowserEnv;
  exports.isNodeEnv = isNodeEnv;
  exports.isSvg = isSvg;
  exports.isTransformKey = isTransformKey;
  exports.isXML = isXML;
  exports.jsx = jsx;
  exports.layerService = layerService;
  exports.lineCanvasPickModule = lineCanvasPickModule;
  exports.lineMathPickModule = lineMathPickModule;
  exports.lineModule = lineModule;
  exports.loadAllEnv = loadAllEnv;
  exports.loadAllModule = loadAllModule;
  exports.loadBrowserEnv = loadBrowserEnv;
  exports.loadFeishuEnv = loadFeishuEnv;
  exports.loadLynxEnv = loadLynxEnv;
  exports.loadNodeEnv = loadNodeEnv;
  exports.loadTTEnv = loadTTEnv;
  exports.loadTaroEnv = loadTaroEnv;
  exports.loadWxEnv = loadWxEnv;
  exports.lookAt = lookAt;
  exports.lynxEnvModule = lynxEnvModule;
  exports.mat3Tomat4 = mat3Tomat4;
  exports.mat4Allocate = mat4Allocate;
  exports.matrixAllocate = matrixAllocate;
  exports.morphPath = morphPath;
  exports.multiInject = multiInject;
  exports.multiToOneMorph = multiToOneMorph;
  exports.multiply = multiply;
  exports.multiplyMat4Mat3 = multiplyMat4Mat3;
  exports.multiplyMat4Mat4 = multiplyMat4Mat4;
  exports.named = named;
  exports.newThemeObj = newThemeObj;
  exports.nodeEnvModule = nodeEnvModule;
  exports.oneToMultiMorph = oneToMultiMorph;
  exports.ortho = ortho;
  exports.parsePadding = parsePadding;
  exports.parseStroke = parseStroke;
  exports.parseSvgPath = parseSvgPath;
  exports.pathCanvasPickModule = pathCanvasPickModule;
  exports.pathMathPickModule = pathMathPickModule;
  exports.pathModule = pathModule;
  exports.pathToBezierCurves = pathToBezierCurves;
  exports.point = _point$1;
  exports.pointEqual = pointEqual;
  exports.pointInterpolation = pointInterpolation;
  exports.pointInterpolationHighPerformance = pointInterpolationHighPerformance;
  exports.pointsEqual = pointsEqual;
  exports.pointsInterpolation = pointsInterpolation;
  exports.polygonCanvasPickModule = polygonCanvasPickModule;
  exports.polygonMathPickModule = polygonMathPickModule;
  exports.polygonModule = polygonModule;
  exports.preLoadAllModule = preLoadAllModule;
  exports.pyramid3dCanvasPickModule = pyramid3dCanvasPickModule;
  exports.pyramid3dModule = pyramid3dModule;
  exports.rafBasedSto = rafBasedSto;
  exports.rect3dCanvasPickModule = rect3dCanvasPickModule;
  exports.rect3dModule = rect3dModule;
  exports.rectCanvasPickModule = rectCanvasPickModule;
  exports.rectFillVisible = rectFillVisible;
  exports.rectMathPickModule = rectMathPickModule;
  exports.rectModule = rectModule;
  exports.rectStrokeVisible = rectStrokeVisible;
  exports.recursiveCallBinarySplit = recursiveCallBinarySplit;
  exports.registerArc = registerArc;
  exports.registerArc3d = registerArc3d;
  exports.registerArc3dGraphic = registerArc3dGraphic;
  exports.registerArcGraphic = registerArcGraphic;
  exports.registerArea = registerArea;
  exports.registerAreaGraphic = registerAreaGraphic;
  exports.registerCircle = registerCircle;
  exports.registerCircleGraphic = registerCircleGraphic;
  exports.registerGlyph = registerGlyph;
  exports.registerGlyphGraphic = registerGlyphGraphic;
  exports.registerGroup = registerGroup;
  exports.registerGroupGraphic = registerGroupGraphic;
  exports.registerImage = registerImage;
  exports.registerImageGraphic = registerImageGraphic;
  exports.registerLine = registerLine;
  exports.registerLineGraphic = registerLineGraphic;
  exports.registerPath = registerPath;
  exports.registerPathGraphic = registerPathGraphic;
  exports.registerPolygon = registerPolygon;
  exports.registerPolygonGraphic = registerPolygonGraphic;
  exports.registerPyramid3d = registerPyramid3d;
  exports.registerPyramid3dGraphic = registerPyramid3dGraphic;
  exports.registerRect = registerRect;
  exports.registerRect3d = registerRect3d;
  exports.registerRect3dGraphic = registerRect3dGraphic;
  exports.registerRectGraphic = registerRectGraphic;
  exports.registerRichtext = registerRichtext;
  exports.registerRichtextGraphic = registerRichtextGraphic;
  exports.registerShadowRoot = registerShadowRoot;
  exports.registerShadowRootGraphic = registerShadowRootGraphic;
  exports.registerSymbol = registerSymbol;
  exports.registerSymbolGraphic = registerSymbolGraphic;
  exports.registerText = registerText;
  exports.registerTextGraphic = registerTextGraphic;
  exports.registerWrapText = registerWrapText;
  exports.registerWrapTextGraphic = registerWrapTextGraphic;
  exports.renderCommandList = renderCommandList;
  exports.rewriteProto = rewriteProto;
  exports.richTextMathPickModule = richTextMathPickModule;
  exports.richtextCanvasPickModule = richtextCanvasPickModule;
  exports.richtextModule = richtextModule;
  exports.rotateX = rotateX;
  exports.rotateY = rotateY;
  exports.roughModule = roughModule;
  exports.runFill = runFill;
  exports.runStroke = runStroke;
  exports.segments = segments;
  exports.shouldUseMat4 = shouldUseMat4;
  exports.snapLength = snapLength;
  exports.splitArc = splitArc;
  exports.splitArea = splitArea;
  exports.splitCircle = splitCircle;
  exports.splitGraphic = splitGraphic;
  exports.splitLine = splitLine;
  exports.splitPath = splitPath;
  exports.splitPolygon = splitPolygon;
  exports.splitRect = splitRect;
  exports.splitToGrids = splitToGrids;
  exports.strCommandMap = strCommandMap;
  exports.strokeVisible = strokeVisible;
  exports.symbolCanvasPickModule = symbolCanvasPickModule;
  exports.symbolMathPickModule = symbolMathPickModule;
  exports.symbolModule = symbolModule;
  exports.taroEnvModule = taroEnvModule;
  exports.textCanvasPickModule = textCanvasPickModule;
  exports.textDrawOffsetX = textDrawOffsetX;
  exports.textDrawOffsetY = textDrawOffsetY;
  exports.textLayoutOffsetY = textLayoutOffsetY;
  exports.textMathPickModule = textMathPickModule;
  exports.textModule = textModule;
  exports.transformKeys = transformKeys;
  exports.transformMat4 = transformMat4;
  exports.transformUtil = transformUtil;
  exports.translate = translate;
  exports.ttEnvModule = ttEnvModule;
  exports.version = version;
  exports.verticalLayout = verticalLayout;
  exports.vglobal = vglobal;
  exports.waitForAllSubLayers = waitForAllSubLayers;
  exports.wrapCanvas = wrapCanvas;
  exports.wrapContext = wrapContext;
  exports.wxEnvModule = wxEnvModule;
  exports.xul = xul;

}));
